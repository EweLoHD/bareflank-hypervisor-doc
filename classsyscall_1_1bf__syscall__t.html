<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank Hypervisor: syscall::bf_syscall_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bareflank Hypervisor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsyscall_1_1bf__syscall__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classsyscall_1_1bf__syscall__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">syscall::bf_syscall_t Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs, please see the Microkernel ABI Specification.  
 <a href="classsyscall_1_1bf__syscall__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mocks_2bf__syscall__t_8hpp_source.html">bf_syscall_t.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a581d962f74017a660a78e9ebc4522011"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a581d962f74017a660a78e9ebc4522011">initialize</a> (bsl::safe_u32 const &amp;version, <a class="el" href="namespacesyscall.html#a9cd54917e15d0b4f28199ec88380b8f0">bf_callback_handler_bootstrap_t</a> const pmut_bootstrap_handler, <a class="el" href="namespacesyscall.html#a6e2b46c2a0bee5dacb4906558723b00c">bf_callback_handler_vmexit_t</a> const pmut_vmexit_handler, <a class="el" href="namespacesyscall.html#a0b901eaa1c2f3424d67879f2d5a593c8">bf_callback_handler_fail_t</a> const pmut_fail_handler) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a581d962f74017a660a78e9ebc4522011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by verifying version compatibility, opening a handle and registering the provided callbacks.  <a href="classsyscall_1_1bf__syscall__t.html#a581d962f74017a660a78e9ebc4522011">More...</a><br /></td></tr>
<tr class="separator:a581d962f74017a660a78e9ebc4522011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ddd4ce4a0281fc41e39f6f4d64ae93"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a08ddd4ce4a0281fc41e39f6f4d64ae93">set_initialize</a> (bsl::errc_type const &amp;errc) noexcept</td></tr>
<tr class="memdesc:a08ddd4ce4a0281fc41e39f6f4d64ae93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of initialize. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a08ddd4ce4a0281fc41e39f6f4d64ae93">More...</a><br /></td></tr>
<tr class="separator:a08ddd4ce4a0281fc41e39f6f4d64ae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349e358e66194c43e2ca87fccf61c56a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a349e358e66194c43e2ca87fccf61c56a">initialize_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a349e358e66194c43e2ca87fccf61c56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times initialize has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a349e358e66194c43e2ca87fccf61c56a">More...</a><br /></td></tr>
<tr class="separator:a349e358e66194c43e2ca87fccf61c56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec9bf8e06592161b3803cd8da2d8cd6"><td class="memItemLeft" align="right" valign="top"><a id="abec9bf8e06592161b3803cd8da2d8cd6" name="abec9bf8e06592161b3803cd8da2d8cd6"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> () noexcept</td></tr>
<tr class="memdesc:abec9bf8e06592161b3803cd8da2d8cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by closing the handle. <br /></td></tr>
<tr class="separator:abec9bf8e06592161b3803cd8da2d8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbfcf6c373c660c2e31b7c49bb43984"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a1dbfcf6c373c660c2e31b7c49bb43984">release_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a1dbfcf6c373c660c2e31b7c49bb43984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times release has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a1dbfcf6c373c660c2e31b7c49bb43984">More...</a><br /></td></tr>
<tr class="separator:a1dbfcf6c373c660c2e31b7c49bb43984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d27e2c617852c19cfa4be9342c8378"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a53d27e2c617852c19cfa4be9342c8378">bf_tls_rax</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a53d27e2c617852c19cfa4be9342c8378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rax.  <a href="classsyscall_1_1bf__syscall__t.html#a53d27e2c617852c19cfa4be9342c8378">More...</a><br /></td></tr>
<tr class="separator:a53d27e2c617852c19cfa4be9342c8378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d94c7ee2352e816e8b526584647268e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a6d94c7ee2352e816e8b526584647268e">bf_tls_set_rax</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a6d94c7ee2352e816e8b526584647268e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rax.  <a href="classsyscall_1_1bf__syscall__t.html#a6d94c7ee2352e816e8b526584647268e">More...</a><br /></td></tr>
<tr class="separator:a6d94c7ee2352e816e8b526584647268e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409f6b5e424cbe8788c66c095a350a38"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a409f6b5e424cbe8788c66c095a350a38">bf_tls_set_rax_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a409f6b5e424cbe8788c66c095a350a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_rax has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a409f6b5e424cbe8788c66c095a350a38">More...</a><br /></td></tr>
<tr class="separator:a409f6b5e424cbe8788c66c095a350a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1babc66df343b7265140beea81bcdb39"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a1babc66df343b7265140beea81bcdb39">bf_tls_rbx</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a1babc66df343b7265140beea81bcdb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rbx.  <a href="classsyscall_1_1bf__syscall__t.html#a1babc66df343b7265140beea81bcdb39">More...</a><br /></td></tr>
<tr class="separator:a1babc66df343b7265140beea81bcdb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cb47e52b4ad6226d45abc0987ce9af"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a75cb47e52b4ad6226d45abc0987ce9af">bf_tls_set_rbx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a75cb47e52b4ad6226d45abc0987ce9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rbx.  <a href="classsyscall_1_1bf__syscall__t.html#a75cb47e52b4ad6226d45abc0987ce9af">More...</a><br /></td></tr>
<tr class="separator:a75cb47e52b4ad6226d45abc0987ce9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d6aa2cda8cc47e6b2c0acd803cdd7e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ab7d6aa2cda8cc47e6b2c0acd803cdd7e">bf_tls_set_rbx_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ab7d6aa2cda8cc47e6b2c0acd803cdd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_rbx has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ab7d6aa2cda8cc47e6b2c0acd803cdd7e">More...</a><br /></td></tr>
<tr class="separator:ab7d6aa2cda8cc47e6b2c0acd803cdd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7a01634b852f33423f69750effd0f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a0e7a01634b852f33423f69750effd0f4">bf_tls_rcx</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a0e7a01634b852f33423f69750effd0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rcx.  <a href="classsyscall_1_1bf__syscall__t.html#a0e7a01634b852f33423f69750effd0f4">More...</a><br /></td></tr>
<tr class="separator:a0e7a01634b852f33423f69750effd0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c14a8acece08bfd6a9bef2abbf313e3"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a4c14a8acece08bfd6a9bef2abbf313e3">bf_tls_set_rcx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a4c14a8acece08bfd6a9bef2abbf313e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rcx.  <a href="classsyscall_1_1bf__syscall__t.html#a4c14a8acece08bfd6a9bef2abbf313e3">More...</a><br /></td></tr>
<tr class="separator:a4c14a8acece08bfd6a9bef2abbf313e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9690844720478ff4248ec4f6a6d70cd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad9690844720478ff4248ec4f6a6d70cd">bf_tls_set_rcx_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ad9690844720478ff4248ec4f6a6d70cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_rcx has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ad9690844720478ff4248ec4f6a6d70cd">More...</a><br /></td></tr>
<tr class="separator:ad9690844720478ff4248ec4f6a6d70cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6206d928d512296f8a991e721b13b311"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a6206d928d512296f8a991e721b13b311">bf_tls_rdx</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a6206d928d512296f8a991e721b13b311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rdx.  <a href="classsyscall_1_1bf__syscall__t.html#a6206d928d512296f8a991e721b13b311">More...</a><br /></td></tr>
<tr class="separator:a6206d928d512296f8a991e721b13b311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e274ad87143a3f5fa6d46db30a92140"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5e274ad87143a3f5fa6d46db30a92140">bf_tls_set_rdx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a5e274ad87143a3f5fa6d46db30a92140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rdx.  <a href="classsyscall_1_1bf__syscall__t.html#a5e274ad87143a3f5fa6d46db30a92140">More...</a><br /></td></tr>
<tr class="separator:a5e274ad87143a3f5fa6d46db30a92140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa800cb8db2cc010faa214f9575a487ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa800cb8db2cc010faa214f9575a487ec">bf_tls_set_rdx_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:aa800cb8db2cc010faa214f9575a487ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_rdx has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aa800cb8db2cc010faa214f9575a487ec">More...</a><br /></td></tr>
<tr class="separator:aa800cb8db2cc010faa214f9575a487ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4dbeba43527e5890ffe3e7d4f99c0b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a1a4dbeba43527e5890ffe3e7d4f99c0b">bf_tls_rbp</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a1a4dbeba43527e5890ffe3e7d4f99c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rbp.  <a href="classsyscall_1_1bf__syscall__t.html#a1a4dbeba43527e5890ffe3e7d4f99c0b">More...</a><br /></td></tr>
<tr class="separator:a1a4dbeba43527e5890ffe3e7d4f99c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6c838410d5d9fcae29957c3dfe39a1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a8c6c838410d5d9fcae29957c3dfe39a1">bf_tls_set_rbp</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a8c6c838410d5d9fcae29957c3dfe39a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rbp.  <a href="classsyscall_1_1bf__syscall__t.html#a8c6c838410d5d9fcae29957c3dfe39a1">More...</a><br /></td></tr>
<tr class="separator:a8c6c838410d5d9fcae29957c3dfe39a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b33d8ab200ff7c957ddad6084dad91"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad0b33d8ab200ff7c957ddad6084dad91">bf_tls_set_rbp_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ad0b33d8ab200ff7c957ddad6084dad91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_rbp has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ad0b33d8ab200ff7c957ddad6084dad91">More...</a><br /></td></tr>
<tr class="separator:ad0b33d8ab200ff7c957ddad6084dad91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1b31c0d096a1ab65fc57e3ff565a03"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5c1b31c0d096a1ab65fc57e3ff565a03">bf_tls_rsi</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a5c1b31c0d096a1ab65fc57e3ff565a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rsi.  <a href="classsyscall_1_1bf__syscall__t.html#a5c1b31c0d096a1ab65fc57e3ff565a03">More...</a><br /></td></tr>
<tr class="separator:a5c1b31c0d096a1ab65fc57e3ff565a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99398cc6bf32939bdf633c3067ef9b73"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a99398cc6bf32939bdf633c3067ef9b73">bf_tls_set_rsi</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a99398cc6bf32939bdf633c3067ef9b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rsi.  <a href="classsyscall_1_1bf__syscall__t.html#a99398cc6bf32939bdf633c3067ef9b73">More...</a><br /></td></tr>
<tr class="separator:a99398cc6bf32939bdf633c3067ef9b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b2c26958e01663664ebc3285b34321"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a23b2c26958e01663664ebc3285b34321">bf_tls_set_rsi_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a23b2c26958e01663664ebc3285b34321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_rsi has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a23b2c26958e01663664ebc3285b34321">More...</a><br /></td></tr>
<tr class="separator:a23b2c26958e01663664ebc3285b34321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0a684b3263130287537b2511216265"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3c0a684b3263130287537b2511216265">bf_tls_rdi</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a3c0a684b3263130287537b2511216265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rdi.  <a href="classsyscall_1_1bf__syscall__t.html#a3c0a684b3263130287537b2511216265">More...</a><br /></td></tr>
<tr class="separator:a3c0a684b3263130287537b2511216265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9805fce4d2e56e24f6f6cdf9c06c280f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9805fce4d2e56e24f6f6cdf9c06c280f">bf_tls_set_rdi</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a9805fce4d2e56e24f6f6cdf9c06c280f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rdi.  <a href="classsyscall_1_1bf__syscall__t.html#a9805fce4d2e56e24f6f6cdf9c06c280f">More...</a><br /></td></tr>
<tr class="separator:a9805fce4d2e56e24f6f6cdf9c06c280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34869d8036420ba62d1bf77a4dd9daf5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a34869d8036420ba62d1bf77a4dd9daf5">bf_tls_set_rdi_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a34869d8036420ba62d1bf77a4dd9daf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_rdi has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a34869d8036420ba62d1bf77a4dd9daf5">More...</a><br /></td></tr>
<tr class="separator:a34869d8036420ba62d1bf77a4dd9daf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2e5940a71025bccc00e46aedaa79e7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3b2e5940a71025bccc00e46aedaa79e7">bf_tls_r8</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a3b2e5940a71025bccc00e46aedaa79e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r8.  <a href="classsyscall_1_1bf__syscall__t.html#a3b2e5940a71025bccc00e46aedaa79e7">More...</a><br /></td></tr>
<tr class="separator:a3b2e5940a71025bccc00e46aedaa79e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e38b52a40c96eeb94f7348dcb994e2f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a6e38b52a40c96eeb94f7348dcb994e2f">bf_tls_set_r8</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a6e38b52a40c96eeb94f7348dcb994e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r8.  <a href="classsyscall_1_1bf__syscall__t.html#a6e38b52a40c96eeb94f7348dcb994e2f">More...</a><br /></td></tr>
<tr class="separator:a6e38b52a40c96eeb94f7348dcb994e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e60e3d9d636eb75eea790e4b5b2f39f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a6e60e3d9d636eb75eea790e4b5b2f39f">bf_tls_set_r8_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a6e60e3d9d636eb75eea790e4b5b2f39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_r8 has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a6e60e3d9d636eb75eea790e4b5b2f39f">More...</a><br /></td></tr>
<tr class="separator:a6e60e3d9d636eb75eea790e4b5b2f39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589fda1683bac0785515ed0a5b4bba49"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a589fda1683bac0785515ed0a5b4bba49">bf_tls_r9</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a589fda1683bac0785515ed0a5b4bba49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r9.  <a href="classsyscall_1_1bf__syscall__t.html#a589fda1683bac0785515ed0a5b4bba49">More...</a><br /></td></tr>
<tr class="separator:a589fda1683bac0785515ed0a5b4bba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ce5eb149c246bb6670f16038e63381"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa8ce5eb149c246bb6670f16038e63381">bf_tls_set_r9</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aa8ce5eb149c246bb6670f16038e63381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r9.  <a href="classsyscall_1_1bf__syscall__t.html#aa8ce5eb149c246bb6670f16038e63381">More...</a><br /></td></tr>
<tr class="separator:aa8ce5eb149c246bb6670f16038e63381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584557840667e0a306606d0bafbf923f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a584557840667e0a306606d0bafbf923f">bf_tls_set_r9_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a584557840667e0a306606d0bafbf923f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_r9 has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a584557840667e0a306606d0bafbf923f">More...</a><br /></td></tr>
<tr class="separator:a584557840667e0a306606d0bafbf923f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6686db96ea48ea21efa1fb81b3ab7e0c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a6686db96ea48ea21efa1fb81b3ab7e0c">bf_tls_r10</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a6686db96ea48ea21efa1fb81b3ab7e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r10.  <a href="classsyscall_1_1bf__syscall__t.html#a6686db96ea48ea21efa1fb81b3ab7e0c">More...</a><br /></td></tr>
<tr class="separator:a6686db96ea48ea21efa1fb81b3ab7e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae33dd0ecd7d1045029e63bddb57d17a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aae33dd0ecd7d1045029e63bddb57d17a">bf_tls_set_r10</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aae33dd0ecd7d1045029e63bddb57d17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r10.  <a href="classsyscall_1_1bf__syscall__t.html#aae33dd0ecd7d1045029e63bddb57d17a">More...</a><br /></td></tr>
<tr class="separator:aae33dd0ecd7d1045029e63bddb57d17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51dd1df03f3ecbc47f50c376bb2dc7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af51dd1df03f3ecbc47f50c376bb2dc7c">bf_tls_set_r10_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:af51dd1df03f3ecbc47f50c376bb2dc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_r10 has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#af51dd1df03f3ecbc47f50c376bb2dc7c">More...</a><br /></td></tr>
<tr class="separator:af51dd1df03f3ecbc47f50c376bb2dc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56d669c774f7789a3c25e0ec5702335"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac56d669c774f7789a3c25e0ec5702335">bf_tls_r11</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ac56d669c774f7789a3c25e0ec5702335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r11.  <a href="classsyscall_1_1bf__syscall__t.html#ac56d669c774f7789a3c25e0ec5702335">More...</a><br /></td></tr>
<tr class="separator:ac56d669c774f7789a3c25e0ec5702335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a863102011808e9cb8f4934fb7ce2bd"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3a863102011808e9cb8f4934fb7ce2bd">bf_tls_set_r11</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a3a863102011808e9cb8f4934fb7ce2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r11.  <a href="classsyscall_1_1bf__syscall__t.html#a3a863102011808e9cb8f4934fb7ce2bd">More...</a><br /></td></tr>
<tr class="separator:a3a863102011808e9cb8f4934fb7ce2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5eb1c5c7cbda9c1bd865ae13451303"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a4b5eb1c5c7cbda9c1bd865ae13451303">bf_tls_set_r11_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a4b5eb1c5c7cbda9c1bd865ae13451303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_r11 has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a4b5eb1c5c7cbda9c1bd865ae13451303">More...</a><br /></td></tr>
<tr class="separator:a4b5eb1c5c7cbda9c1bd865ae13451303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c3bcfd8a6e49e8ae2b414e3c50199f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad9c3bcfd8a6e49e8ae2b414e3c50199f">bf_tls_r12</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ad9c3bcfd8a6e49e8ae2b414e3c50199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r12.  <a href="classsyscall_1_1bf__syscall__t.html#ad9c3bcfd8a6e49e8ae2b414e3c50199f">More...</a><br /></td></tr>
<tr class="separator:ad9c3bcfd8a6e49e8ae2b414e3c50199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fa94a48fb4f9240306440861e72796"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a67fa94a48fb4f9240306440861e72796">bf_tls_set_r12</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a67fa94a48fb4f9240306440861e72796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r12.  <a href="classsyscall_1_1bf__syscall__t.html#a67fa94a48fb4f9240306440861e72796">More...</a><br /></td></tr>
<tr class="separator:a67fa94a48fb4f9240306440861e72796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2189bf27b4a1a2f45c964bb9095aff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aef2189bf27b4a1a2f45c964bb9095aff">bf_tls_set_r12_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:aef2189bf27b4a1a2f45c964bb9095aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_r12 has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aef2189bf27b4a1a2f45c964bb9095aff">More...</a><br /></td></tr>
<tr class="separator:aef2189bf27b4a1a2f45c964bb9095aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33dbc59e96470b4cdf0c96487c5c95e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af33dbc59e96470b4cdf0c96487c5c95e">bf_tls_r13</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:af33dbc59e96470b4cdf0c96487c5c95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r13.  <a href="classsyscall_1_1bf__syscall__t.html#af33dbc59e96470b4cdf0c96487c5c95e">More...</a><br /></td></tr>
<tr class="separator:af33dbc59e96470b4cdf0c96487c5c95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdaa1b703f812a99c4f20146beacfa4"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#adfdaa1b703f812a99c4f20146beacfa4">bf_tls_set_r13</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:adfdaa1b703f812a99c4f20146beacfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r13.  <a href="classsyscall_1_1bf__syscall__t.html#adfdaa1b703f812a99c4f20146beacfa4">More...</a><br /></td></tr>
<tr class="separator:adfdaa1b703f812a99c4f20146beacfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b95ad79276121a7054010cd7d4a2b0d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7b95ad79276121a7054010cd7d4a2b0d">bf_tls_set_r13_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a7b95ad79276121a7054010cd7d4a2b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_r13 has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a7b95ad79276121a7054010cd7d4a2b0d">More...</a><br /></td></tr>
<tr class="separator:a7b95ad79276121a7054010cd7d4a2b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7900b502ae05c2ec0c649d55d2120ea"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af7900b502ae05c2ec0c649d55d2120ea">bf_tls_r14</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:af7900b502ae05c2ec0c649d55d2120ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r14.  <a href="classsyscall_1_1bf__syscall__t.html#af7900b502ae05c2ec0c649d55d2120ea">More...</a><br /></td></tr>
<tr class="separator:af7900b502ae05c2ec0c649d55d2120ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314a6fd63fdbd26c8789ab06829d7456"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a314a6fd63fdbd26c8789ab06829d7456">bf_tls_set_r14</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a314a6fd63fdbd26c8789ab06829d7456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r14.  <a href="classsyscall_1_1bf__syscall__t.html#a314a6fd63fdbd26c8789ab06829d7456">More...</a><br /></td></tr>
<tr class="separator:a314a6fd63fdbd26c8789ab06829d7456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4fb8a6a6e745becdc6ec627dfe80e9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7c4fb8a6a6e745becdc6ec627dfe80e9">bf_tls_set_r14_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a7c4fb8a6a6e745becdc6ec627dfe80e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_r14 has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a7c4fb8a6a6e745becdc6ec627dfe80e9">More...</a><br /></td></tr>
<tr class="separator:a7c4fb8a6a6e745becdc6ec627dfe80e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b3c42ea7b5af2cb01108cd051d5fb2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a19b3c42ea7b5af2cb01108cd051d5fb2">bf_tls_r15</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a19b3c42ea7b5af2cb01108cd051d5fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r15.  <a href="classsyscall_1_1bf__syscall__t.html#a19b3c42ea7b5af2cb01108cd051d5fb2">More...</a><br /></td></tr>
<tr class="separator:a19b3c42ea7b5af2cb01108cd051d5fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae034b61b0c8860503c53444fea4136"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2ae034b61b0c8860503c53444fea4136">bf_tls_set_r15</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a2ae034b61b0c8860503c53444fea4136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r15.  <a href="classsyscall_1_1bf__syscall__t.html#a2ae034b61b0c8860503c53444fea4136">More...</a><br /></td></tr>
<tr class="separator:a2ae034b61b0c8860503c53444fea4136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559945a6c694220228f2e064d4d8bb49"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a559945a6c694220228f2e064d4d8bb49">bf_tls_set_r15_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a559945a6c694220228f2e064d4d8bb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_tls_set_r15 has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a559945a6c694220228f2e064d4d8bb49">More...</a><br /></td></tr>
<tr class="separator:a559945a6c694220228f2e064d4d8bb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdbacb64e3a66fe8deed91d530c0a3b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2bdbacb64e3a66fe8deed91d530c0a3b">bf_tls_extid</a> () const noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a2bdbacb64e3a66fe8deed91d530c0a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.extid.  <a href="classsyscall_1_1bf__syscall__t.html#a2bdbacb64e3a66fe8deed91d530c0a3b">More...</a><br /></td></tr>
<tr class="separator:a2bdbacb64e3a66fe8deed91d530c0a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f72868646bbf22f4578435fd41b378"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ae9f72868646bbf22f4578435fd41b378">bf_tls_set_extid</a> (bsl::safe_u16 const &amp;val) noexcept</td></tr>
<tr class="memdesc:ae9f72868646bbf22f4578435fd41b378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.extid (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ae9f72868646bbf22f4578435fd41b378">More...</a><br /></td></tr>
<tr class="separator:ae9f72868646bbf22f4578435fd41b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c338b6f6364850255d7b46cdf2cb0cf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a4c338b6f6364850255d7b46cdf2cb0cf">bf_tls_vmid</a> () const noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a4c338b6f6364850255d7b46cdf2cb0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vmid.  <a href="classsyscall_1_1bf__syscall__t.html#a4c338b6f6364850255d7b46cdf2cb0cf">More...</a><br /></td></tr>
<tr class="separator:a4c338b6f6364850255d7b46cdf2cb0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f797965cd102615f2845102dc69c87"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a81f797965cd102615f2845102dc69c87">bf_tls_set_vmid</a> (bsl::safe_u16 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a81f797965cd102615f2845102dc69c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.vmid (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a81f797965cd102615f2845102dc69c87">More...</a><br /></td></tr>
<tr class="separator:a81f797965cd102615f2845102dc69c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569fa9c3681f3ac3c733a135cbb177e5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a569fa9c3681f3ac3c733a135cbb177e5">bf_tls_vpid</a> () const noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a569fa9c3681f3ac3c733a135cbb177e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vpid.  <a href="classsyscall_1_1bf__syscall__t.html#a569fa9c3681f3ac3c733a135cbb177e5">More...</a><br /></td></tr>
<tr class="separator:a569fa9c3681f3ac3c733a135cbb177e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251cf8ec883ee4547ecaaaf68c95e2a1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a251cf8ec883ee4547ecaaaf68c95e2a1">bf_tls_set_vpid</a> (bsl::safe_u16 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a251cf8ec883ee4547ecaaaf68c95e2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.vpid (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a251cf8ec883ee4547ecaaaf68c95e2a1">More...</a><br /></td></tr>
<tr class="separator:a251cf8ec883ee4547ecaaaf68c95e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4644f8f5bf4ff1d81053094417d3c31"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac4644f8f5bf4ff1d81053094417d3c31">bf_tls_vsid</a> () const noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:ac4644f8f5bf4ff1d81053094417d3c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vsid.  <a href="classsyscall_1_1bf__syscall__t.html#ac4644f8f5bf4ff1d81053094417d3c31">More...</a><br /></td></tr>
<tr class="separator:ac4644f8f5bf4ff1d81053094417d3c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba23dc2f3e768f6ce065eb3dc8a4ee0e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aba23dc2f3e768f6ce065eb3dc8a4ee0e">bf_tls_set_vsid</a> (bsl::safe_u16 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aba23dc2f3e768f6ce065eb3dc8a4ee0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.vsid (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aba23dc2f3e768f6ce065eb3dc8a4ee0e">More...</a><br /></td></tr>
<tr class="separator:aba23dc2f3e768f6ce065eb3dc8a4ee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57241deea2d0728f8ef1010ad3e6354b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a57241deea2d0728f8ef1010ad3e6354b">bf_tls_ppid</a> () const noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a57241deea2d0728f8ef1010ad3e6354b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.ppid.  <a href="classsyscall_1_1bf__syscall__t.html#a57241deea2d0728f8ef1010ad3e6354b">More...</a><br /></td></tr>
<tr class="separator:a57241deea2d0728f8ef1010ad3e6354b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea38fbf023bc3a978bb22be59110eb08"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aea38fbf023bc3a978bb22be59110eb08">bf_tls_set_ppid</a> (bsl::safe_u16 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aea38fbf023bc3a978bb22be59110eb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.ppid (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aea38fbf023bc3a978bb22be59110eb08">More...</a><br /></td></tr>
<tr class="separator:aea38fbf023bc3a978bb22be59110eb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c79135d8efef39a7625b6d3fd75b98"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a88c79135d8efef39a7625b6d3fd75b98">bf_tls_online_pps</a> () const noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a88c79135d8efef39a7625b6d3fd75b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.online_pps.  <a href="classsyscall_1_1bf__syscall__t.html#a88c79135d8efef39a7625b6d3fd75b98">More...</a><br /></td></tr>
<tr class="separator:a88c79135d8efef39a7625b6d3fd75b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512ede7a30c45ac8c1532ed8d73c5b78"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a512ede7a30c45ac8c1532ed8d73c5b78">bf_tls_set_online_pps</a> (bsl::safe_u16 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a512ede7a30c45ac8c1532ed8d73c5b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.online_pps (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a512ede7a30c45ac8c1532ed8d73c5b78">More...</a><br /></td></tr>
<tr class="separator:a512ede7a30c45ac8c1532ed8d73c5b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8a0fcf4ca2f0ed46d0feef9b58eed3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9e8a0fcf4ca2f0ed46d0feef9b58eed3">is_the_active_vm_the_root_vm</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a9e8a0fcf4ca2f0ed46d0feef9b58eed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the active VM is the root VM. Returns false otherwise.  <a href="classsyscall_1_1bf__syscall__t.html#a9e8a0fcf4ca2f0ed46d0feef9b58eed3">More...</a><br /></td></tr>
<tr class="separator:a9e8a0fcf4ca2f0ed46d0feef9b58eed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891d55979ba9d9d57a0d2827ac5d4894"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a891d55979ba9d9d57a0d2827ac5d4894">is_vp_a_root_vp</a> (bsl::safe_u16 const &amp;vpid) const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a891d55979ba9d9d57a0d2827ac5d4894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid().  <a href="classsyscall_1_1bf__syscall__t.html#a891d55979ba9d9d57a0d2827ac5d4894">More...</a><br /></td></tr>
<tr class="separator:a891d55979ba9d9d57a0d2827ac5d4894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf91388323861b3ad9bcdcb24f8ab1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a75cf91388323861b3ad9bcdcb24f8ab1">is_vs_a_root_vs</a> (bsl::safe_u16 const &amp;vsid) const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a75cf91388323861b3ad9bcdcb24f8ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid().  <a href="classsyscall_1_1bf__syscall__t.html#a75cf91388323861b3ad9bcdcb24f8ab1">More...</a><br /></td></tr>
<tr class="separator:a75cf91388323861b3ad9bcdcb24f8ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f4c6acc6dcae301b4bd0cca721752d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a88f4c6acc6dcae301b4bd0cca721752d">bf_vm_op_create_vm</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a88f4c6acc6dcae301b4bd0cca721752d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VM and return it's ID.  <a href="classsyscall_1_1bf__syscall__t.html#a88f4c6acc6dcae301b4bd0cca721752d">More...</a><br /></td></tr>
<tr class="separator:a88f4c6acc6dcae301b4bd0cca721752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63aea2efc992d6747002b4c221ac031"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad63aea2efc992d6747002b4c221ac031">set_bf_vm_op_create_vm</a> (bsl::safe_u16 const &amp;vmid) noexcept</td></tr>
<tr class="memdesc:ad63aea2efc992d6747002b4c221ac031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vm_op_create_vm. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ad63aea2efc992d6747002b4c221ac031">More...</a><br /></td></tr>
<tr class="separator:ad63aea2efc992d6747002b4c221ac031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1650ebcaea08ffe5616ae8e5ec38898"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ae1650ebcaea08ffe5616ae8e5ec38898">bf_vm_op_create_vm_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ae1650ebcaea08ffe5616ae8e5ec38898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vm_op_create_vm has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ae1650ebcaea08ffe5616ae8e5ec38898">More...</a><br /></td></tr>
<tr class="separator:ae1650ebcaea08ffe5616ae8e5ec38898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa2fbcaf0f75e1bb38d6b2419c2a0f728">bf_vm_op_destroy_vm</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VM given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#aa2fbcaf0f75e1bb38d6b2419c2a0f728">More...</a><br /></td></tr>
<tr class="separator:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38b1ea18f76f926467f45c756e5dfbf"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ae38b1ea18f76f926467f45c756e5dfbf">set_bf_vm_op_destroy_vm</a> (bsl::safe_u16 const &amp;vmid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:ae38b1ea18f76f926467f45c756e5dfbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vm_op_destroy_vm. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ae38b1ea18f76f926467f45c756e5dfbf">More...</a><br /></td></tr>
<tr class="separator:ae38b1ea18f76f926467f45c756e5dfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e6558b296504004631e0b2493ba20"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5d1e6558b296504004631e0b2493ba20">bf_vm_op_destroy_vm_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a5d1e6558b296504004631e0b2493ba20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vm_op_destroy_vm has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a5d1e6558b296504004631e0b2493ba20">More...</a><br /></td></tr>
<tr class="separator:a5d1e6558b296504004631e0b2493ba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbe512644173318a7542718922e6675"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dbe512644173318a7542718922e6675"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a8dbe512644173318a7542718922e6675">bf_vm_op_map_direct</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u64 const &amp;phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a8dbe512644173318a7542718922e6675"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to map a physical address into the VM's direct map. This is the same as directly accessing the direct map with the difference being that software can provide a physical address and receive the precalculated virtual address.  <a href="classsyscall_1_1bf__syscall__t.html#a8dbe512644173318a7542718922e6675">More...</a><br /></td></tr>
<tr class="separator:a8dbe512644173318a7542718922e6675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac671ca3eb92574511278b5c54207479d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac671ca3eb92574511278b5c54207479d">set_bf_vm_op_map_direct</a> (bsl::safe_u16 const &amp;vmid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:ac671ca3eb92574511278b5c54207479d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vm_op_map_direct. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ac671ca3eb92574511278b5c54207479d">More...</a><br /></td></tr>
<tr class="separator:ac671ca3eb92574511278b5c54207479d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb5b60f13cf7d67d35f1536198442ee"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a1fb5b60f13cf7d67d35f1536198442ee">bf_vm_op_map_direct_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a1fb5b60f13cf7d67d35f1536198442ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vm_op_map_direct has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a1fb5b60f13cf7d67d35f1536198442ee">More...</a><br /></td></tr>
<tr class="separator:a1fb5b60f13cf7d67d35f1536198442ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632632beab87dbc4094684bf465285a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a632632beab87dbc4094684bf465285a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a632632beab87dbc4094684bf465285a8">bf_vm_op_unmap_direct</a> (bsl::safe_u16 const &amp;vmid, T *const pmut_virt) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a632632beab87dbc4094684bf465285a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct_broadcast, this syscall does not flush the TLB on any other PP, meaning this unmap is local to the PP the call is made on. Attempting to unmap a virtual address from the direct map that has been accessed on any other PP other than the PP this syscall is executed on will result in undefined behavior. This syscall is designed to support mapping and then immediately unmapping a physical address on a single PP during a single VMExit. It can also be used to map on a PP and then use unmap on the same PP during multiple VMExits, but special care must be taken to ensure no other PP can access the map, otherwise UB will occur.  <a href="classsyscall_1_1bf__syscall__t.html#a632632beab87dbc4094684bf465285a8">More...</a><br /></td></tr>
<tr class="separator:a632632beab87dbc4094684bf465285a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172b50038e0ebd30cfbd3b863f874fb8"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a172b50038e0ebd30cfbd3b863f874fb8">set_bf_vm_op_unmap_direct</a> (bsl::safe_u16 const &amp;vmid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a172b50038e0ebd30cfbd3b863f874fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vm_op_unmap_direct. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a172b50038e0ebd30cfbd3b863f874fb8">More...</a><br /></td></tr>
<tr class="separator:a172b50038e0ebd30cfbd3b863f874fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a64a79f906b03966df37b91ed335cc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a32a64a79f906b03966df37b91ed335cc">bf_vm_op_unmap_direct_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a32a64a79f906b03966df37b91ed335cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vm_op_unmap_direct has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a32a64a79f906b03966df37b91ed335cc">More...</a><br /></td></tr>
<tr class="separator:a32a64a79f906b03966df37b91ed335cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8454c2c8f80cf0fe30eabe7539bce8a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8454c2c8f80cf0fe30eabe7539bce8a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a8454c2c8f80cf0fe30eabe7539bce8a7">bf_vm_op_unmap_direct_broadcast</a> (bsl::safe_u16 const &amp;vmid, T *const pmut_virt) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a8454c2c8f80cf0fe30eabe7539bce8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct, this syscall performs a broadcast TLB flush which means it can be safely used on all direct mapped addresses. The downside of using this function is that it can be a lot slower than bf_vm_op_unmap_direct, especially on systems with a lot of PPs.  <a href="classsyscall_1_1bf__syscall__t.html#a8454c2c8f80cf0fe30eabe7539bce8a7">More...</a><br /></td></tr>
<tr class="separator:a8454c2c8f80cf0fe30eabe7539bce8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa609445eb96f0ec0b18bae400fd5190a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa609445eb96f0ec0b18bae400fd5190a">set_bf_vm_op_unmap_direct_broadcast</a> (bsl::safe_u16 const &amp;vmid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:aa609445eb96f0ec0b18bae400fd5190a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vm_op_unmap_direct_broadcast. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aa609445eb96f0ec0b18bae400fd5190a">More...</a><br /></td></tr>
<tr class="separator:aa609445eb96f0ec0b18bae400fd5190a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e5d2d7df3a0de221852b829bbb93d7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a71e5d2d7df3a0de221852b829bbb93d7">bf_vm_op_unmap_direct_broadcast_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a71e5d2d7df3a0de221852b829bbb93d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vm_op_unmap_direct_broadcast has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a71e5d2d7df3a0de221852b829bbb93d7">More...</a><br /></td></tr>
<tr class="separator:a71e5d2d7df3a0de221852b829bbb93d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bdf9512b2bac2103cd9712f10e0100"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a22bdf9512b2bac2103cd9712f10e0100">bf_vm_op_tlb_flush</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a22bdf9512b2bac2103cd9712f10e0100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the ID of a VM, invalidates a TLB entry for a given GLA on the PP that this is executed on.  <a href="classsyscall_1_1bf__syscall__t.html#a22bdf9512b2bac2103cd9712f10e0100">More...</a><br /></td></tr>
<tr class="separator:a22bdf9512b2bac2103cd9712f10e0100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a584c0439f2353d7a5e0ad92bf3d9d5"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a1a584c0439f2353d7a5e0ad92bf3d9d5">set_bf_vm_op_tlb_flush</a> (bsl::safe_u16 const &amp;vmid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a1a584c0439f2353d7a5e0ad92bf3d9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vm_op_tlb_flush. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a1a584c0439f2353d7a5e0ad92bf3d9d5">More...</a><br /></td></tr>
<tr class="separator:a1a584c0439f2353d7a5e0ad92bf3d9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbc0fc25a4e4d668836612a2b291973"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#affbc0fc25a4e4d668836612a2b291973">bf_vm_op_tlb_flush_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:affbc0fc25a4e4d668836612a2b291973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vm_op_tlb_flush has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#affbc0fc25a4e4d668836612a2b291973">More...</a><br /></td></tr>
<tr class="separator:affbc0fc25a4e4d668836612a2b291973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3775e0ff37788114cb5f25d2688a5df8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3775e0ff37788114cb5f25d2688a5df8">bf_vp_op_create_vp</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a3775e0ff37788114cb5f25d2688a5df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VP given the IDs of the VM and PP the VP will be assigned to. Upon success, this syscall returns the ID of the newly created VP.  <a href="classsyscall_1_1bf__syscall__t.html#a3775e0ff37788114cb5f25d2688a5df8">More...</a><br /></td></tr>
<tr class="separator:a3775e0ff37788114cb5f25d2688a5df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bb08e13734593fc07cd9091ab418f1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af3bb08e13734593fc07cd9091ab418f1">set_bf_vp_op_create_vp</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid) noexcept</td></tr>
<tr class="memdesc:af3bb08e13734593fc07cd9091ab418f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vp_op_create_vp. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#af3bb08e13734593fc07cd9091ab418f1">More...</a><br /></td></tr>
<tr class="separator:af3bb08e13734593fc07cd9091ab418f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d35f9aab7c98ea02ffb099d7d1671bc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5d35f9aab7c98ea02ffb099d7d1671bc">bf_vp_op_create_vp_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a5d35f9aab7c98ea02ffb099d7d1671bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vp_op_create_vp has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a5d35f9aab7c98ea02ffb099d7d1671bc">More...</a><br /></td></tr>
<tr class="separator:a5d35f9aab7c98ea02ffb099d7d1671bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ebebe1d613b466425d54f29ef8f69a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a21ebebe1d613b466425d54f29ef8f69a">bf_vp_op_destroy_vp</a> (bsl::safe_u16 const &amp;vpid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a21ebebe1d613b466425d54f29ef8f69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VP given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#a21ebebe1d613b466425d54f29ef8f69a">More...</a><br /></td></tr>
<tr class="separator:a21ebebe1d613b466425d54f29ef8f69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443e97dfd8c77389c41941a2f6a2c2ce"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a443e97dfd8c77389c41941a2f6a2c2ce">set_bf_vp_op_destroy_vp</a> (bsl::safe_u16 const &amp;vpid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a443e97dfd8c77389c41941a2f6a2c2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vp_op_destroy_vp. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a443e97dfd8c77389c41941a2f6a2c2ce">More...</a><br /></td></tr>
<tr class="separator:a443e97dfd8c77389c41941a2f6a2c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4afa842ee1627785d9271ca79ddf19"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#abf4afa842ee1627785d9271ca79ddf19">bf_vp_op_destroy_vp_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:abf4afa842ee1627785d9271ca79ddf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vp_op_destroy_vp has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#abf4afa842ee1627785d9271ca79ddf19">More...</a><br /></td></tr>
<tr class="separator:abf4afa842ee1627785d9271ca79ddf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00703a6f47968414c287ab76cc7e97c6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a00703a6f47968414c287ab76cc7e97c6">bf_vs_op_create_vs</a> (bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;ppid) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a00703a6f47968414c287ab76cc7e97c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VS and return it's ID.  <a href="classsyscall_1_1bf__syscall__t.html#a00703a6f47968414c287ab76cc7e97c6">More...</a><br /></td></tr>
<tr class="separator:a00703a6f47968414c287ab76cc7e97c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86b3d6b8615f30a0b3ba71f32f84be1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad86b3d6b8615f30a0b3ba71f32f84be1">set_bf_vs_op_create_vs</a> (bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;ppid, bsl::safe_u16 const &amp;vspid) noexcept</td></tr>
<tr class="memdesc:ad86b3d6b8615f30a0b3ba71f32f84be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_create_vs. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ad86b3d6b8615f30a0b3ba71f32f84be1">More...</a><br /></td></tr>
<tr class="separator:ad86b3d6b8615f30a0b3ba71f32f84be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb0098e8b370eb5db4fc07e095da339"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#abbb0098e8b370eb5db4fc07e095da339">bf_vs_op_create_vs_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:abbb0098e8b370eb5db4fc07e095da339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_create_vs has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#abbb0098e8b370eb5db4fc07e095da339">More...</a><br /></td></tr>
<tr class="separator:abbb0098e8b370eb5db4fc07e095da339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724a2594d24a643e29e10f2022f4cd76"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a724a2594d24a643e29e10f2022f4cd76">bf_vs_op_destroy_vs</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a724a2594d24a643e29e10f2022f4cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VS given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#a724a2594d24a643e29e10f2022f4cd76">More...</a><br /></td></tr>
<tr class="separator:a724a2594d24a643e29e10f2022f4cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ca0fa46efc07071365bc469b710c34"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ae8ca0fa46efc07071365bc469b710c34">set_bf_vs_op_destroy_vs</a> (bsl::safe_u16 const &amp;vsid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:ae8ca0fa46efc07071365bc469b710c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_destroy_vs. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ae8ca0fa46efc07071365bc469b710c34">More...</a><br /></td></tr>
<tr class="separator:ae8ca0fa46efc07071365bc469b710c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab348a6eb128b388bc15d6c100942c2ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ab348a6eb128b388bc15d6c100942c2ec">bf_vs_op_destroy_vs_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ab348a6eb128b388bc15d6c100942c2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_destroy_vs has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ab348a6eb128b388bc15d6c100942c2ec">More...</a><br /></td></tr>
<tr class="separator:ab348a6eb128b388bc15d6c100942c2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7f94f5da4b7fd47aef467ff09324c8a2">bf_vs_op_init_as_root</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to initialize a VS using the root VP state provided by the loader using the current PPID.  <a href="classsyscall_1_1bf__syscall__t.html#a7f94f5da4b7fd47aef467ff09324c8a2">More...</a><br /></td></tr>
<tr class="separator:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6146c2c82fc4c06bb05ec42e8b59a7d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ab6146c2c82fc4c06bb05ec42e8b59a7d">set_bf_vs_op_init_as_root</a> (bsl::safe_u16 const &amp;vsid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:ab6146c2c82fc4c06bb05ec42e8b59a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_init_as_root. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ab6146c2c82fc4c06bb05ec42e8b59a7d">More...</a><br /></td></tr>
<tr class="separator:ab6146c2c82fc4c06bb05ec42e8b59a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52adc0c0b915b6ebccefa3b42a22a37"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa52adc0c0b915b6ebccefa3b42a22a37">bf_vs_op_init_as_root_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:aa52adc0c0b915b6ebccefa3b42a22a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_init_as_root has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aa52adc0c0b915b6ebccefa3b42a22a37">More...</a><br /></td></tr>
<tr class="separator:aa52adc0c0b915b6ebccefa3b42a22a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a77282b8dd8dd3d06830811cfdde4b8e6">bf_vs_op_read</a> (bsl::safe_u16 const &amp;vsid, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg) const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a CPU register from the VS given a bf_reg_t. Note that the bf_reg_t is architecture specific.  <a href="classsyscall_1_1bf__syscall__t.html#a77282b8dd8dd3d06830811cfdde4b8e6">More...</a><br /></td></tr>
<tr class="separator:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951d7685c2876681a2a0656cd3141c76"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a951d7685c2876681a2a0656cd3141c76">set_bf_vs_op_read</a> (bsl::safe_u16 const &amp;vsid, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg, bsl::safe_u64 const &amp;value) noexcept</td></tr>
<tr class="memdesc:a951d7685c2876681a2a0656cd3141c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_read. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a951d7685c2876681a2a0656cd3141c76">More...</a><br /></td></tr>
<tr class="separator:a951d7685c2876681a2a0656cd3141c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908cbed8d315f98cf49252b8e3446fcd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a908cbed8d315f98cf49252b8e3446fcd">bf_vs_op_write</a> (bsl::safe_u16 const &amp;vsid, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg, bsl::safe_u64 const &amp;value) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a908cbed8d315f98cf49252b8e3446fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to a CPU register in the VS given a bf_reg_t and the value to write. Note that the bf_reg_t is architecture specific.  <a href="classsyscall_1_1bf__syscall__t.html#a908cbed8d315f98cf49252b8e3446fcd">More...</a><br /></td></tr>
<tr class="separator:a908cbed8d315f98cf49252b8e3446fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab792ae6598aafddbe0b3c6d0e6d90555"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ab792ae6598aafddbe0b3c6d0e6d90555">set_bf_vs_op_write</a> (bsl::safe_u16 const &amp;vsid, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg, bsl::safe_u64 const &amp;value, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:ab792ae6598aafddbe0b3c6d0e6d90555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_write. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ab792ae6598aafddbe0b3c6d0e6d90555">More...</a><br /></td></tr>
<tr class="separator:ab792ae6598aafddbe0b3c6d0e6d90555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee24eac8700266625f022720d42023de"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aee24eac8700266625f022720d42023de">bf_vs_op_write_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:aee24eac8700266625f022720d42023de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_write has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aee24eac8700266625f022720d42023de">More...</a><br /></td></tr>
<tr class="separator:aee24eac8700266625f022720d42023de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31edaef67e15222b8192fd07a079a66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa31edaef67e15222b8192fd07a079a66">bf_vs_op_run</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa31edaef67e15222b8192fd07a079a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#aa31edaef67e15222b8192fd07a079a66">More...</a><br /></td></tr>
<tr class="separator:aa31edaef67e15222b8192fd07a079a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5700047425a90449af8c087c745aaf72"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5700047425a90449af8c087c745aaf72">set_bf_vs_op_run</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a5700047425a90449af8c087c745aaf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_run. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a5700047425a90449af8c087c745aaf72">More...</a><br /></td></tr>
<tr class="separator:a5700047425a90449af8c087c745aaf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fbe374773e35550ff0b4c21b183c5e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a30fbe374773e35550ff0b4c21b183c5e">bf_vs_op_run_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a30fbe374773e35550ff0b4c21b183c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_run has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a30fbe374773e35550ff0b4c21b183c5e">More...</a><br /></td></tr>
<tr class="separator:a30fbe374773e35550ff0b4c21b183c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2a36f6f20561a82c61cc3b1252db25"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5e2a36f6f20561a82c61cc3b1252db25">bf_vs_op_run_current</a> () noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a5e2a36f6f20561a82c61cc3b1252db25"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_vs_op_run_current tells the microkernel to execute the currently active VS, VP and VM.  <a href="classsyscall_1_1bf__syscall__t.html#a5e2a36f6f20561a82c61cc3b1252db25">More...</a><br /></td></tr>
<tr class="separator:a5e2a36f6f20561a82c61cc3b1252db25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be296adfc8fc6e74faacb70164ca2f1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5be296adfc8fc6e74faacb70164ca2f1">set_bf_vs_op_run_current</a> (bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a5be296adfc8fc6e74faacb70164ca2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_run_current. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a5be296adfc8fc6e74faacb70164ca2f1">More...</a><br /></td></tr>
<tr class="separator:a5be296adfc8fc6e74faacb70164ca2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d78f650e63d7c43752934bd704138bf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3d78f650e63d7c43752934bd704138bf">bf_vs_op_run_current_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a3d78f650e63d7c43752934bd704138bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_run_current has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a3d78f650e63d7c43752934bd704138bf">More...</a><br /></td></tr>
<tr class="separator:a3d78f650e63d7c43752934bd704138bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315ebee647ee24661c9b93b65f933d64"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a315ebee647ee24661c9b93b65f933d64">bf_vs_op_advance_ip_and_run</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a315ebee647ee24661c9b93b65f933d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#a315ebee647ee24661c9b93b65f933d64">More...</a><br /></td></tr>
<tr class="separator:a315ebee647ee24661c9b93b65f933d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd11cfb9f5a9745ee414f58889e3bd69"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#acd11cfb9f5a9745ee414f58889e3bd69">set_bf_vs_op_advance_ip_and_run</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:acd11cfb9f5a9745ee414f58889e3bd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_advance_ip_and_run. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#acd11cfb9f5a9745ee414f58889e3bd69">More...</a><br /></td></tr>
<tr class="separator:acd11cfb9f5a9745ee414f58889e3bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445bfd2336c6ebd5bc75e7629463ed1d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a445bfd2336c6ebd5bc75e7629463ed1d">bf_vs_op_advance_ip_and_run_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a445bfd2336c6ebd5bc75e7629463ed1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_advance_ip_and_run has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a445bfd2336c6ebd5bc75e7629463ed1d">More...</a><br /></td></tr>
<tr class="separator:a445bfd2336c6ebd5bc75e7629463ed1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af7bf62e706e5ce6bc770c6374ec89ec5">bf_vs_op_advance_ip_and_run_current</a> () noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#af7bf62e706e5ce6bc770c6374ec89ec5">More...</a><br /></td></tr>
<tr class="separator:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42201183d277c95c728fc976da6d037"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa42201183d277c95c728fc976da6d037">set_bf_vs_op_advance_ip_and_run_current</a> (bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:aa42201183d277c95c728fc976da6d037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_advance_ip_and_run_current. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aa42201183d277c95c728fc976da6d037">More...</a><br /></td></tr>
<tr class="separator:aa42201183d277c95c728fc976da6d037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe063eba2f730be5bfa9f72374571469"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#afe063eba2f730be5bfa9f72374571469">bf_vs_op_advance_ip_and_run_current_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:afe063eba2f730be5bfa9f72374571469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_advance_ip_and_run_current has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#afe063eba2f730be5bfa9f72374571469">More...</a><br /></td></tr>
<tr class="separator:afe063eba2f730be5bfa9f72374571469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571436e51276a3e613246df1a45d5a1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a571436e51276a3e613246df1a45d5a1b">bf_vs_op_promote</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a571436e51276a3e613246df1a45d5a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to promote the requested VS. This will stop the hypervisor complete on the physical processor that this syscall is executed on and replace it's state with the state in the VS. Note that this syscall only returns on error.  <a href="classsyscall_1_1bf__syscall__t.html#a571436e51276a3e613246df1a45d5a1b">More...</a><br /></td></tr>
<tr class="separator:a571436e51276a3e613246df1a45d5a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae580f8f0e2624f130fb0a7a0f429a028"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ae580f8f0e2624f130fb0a7a0f429a028">set_bf_vs_op_promote</a> (bsl::safe_u16 const &amp;vsid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:ae580f8f0e2624f130fb0a7a0f429a028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_promote. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ae580f8f0e2624f130fb0a7a0f429a028">More...</a><br /></td></tr>
<tr class="separator:ae580f8f0e2624f130fb0a7a0f429a028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5d98a2ce315b200225c9f6fb2778ea"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aac5d98a2ce315b200225c9f6fb2778ea">bf_vs_op_promote_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:aac5d98a2ce315b200225c9f6fb2778ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_promote has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aac5d98a2ce315b200225c9f6fb2778ea">More...</a><br /></td></tr>
<tr class="separator:aac5d98a2ce315b200225c9f6fb2778ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92bed718a8641bf68bd5af9078b6fc0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad92bed718a8641bf68bd5af9078b6fc0">bf_vs_op_clear</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ad92bed718a8641bf68bd5af9078b6fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_vs_op_clear tells the microkernel to clear the VS's hardware cache, if one exists. How this is used depends entirely on the hardware and is associated with AMD's VMCB Clean Bits, and Intel's VMClear instruction. See the associated documentation for more details. On AMD, this ABI clears the entire VMCB. For more fine grained control, use the write ABIs to manually modify the VMCB.  <a href="classsyscall_1_1bf__syscall__t.html#ad92bed718a8641bf68bd5af9078b6fc0">More...</a><br /></td></tr>
<tr class="separator:ad92bed718a8641bf68bd5af9078b6fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ce4bd639f19b29fdef4b8d866ac68d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac8ce4bd639f19b29fdef4b8d866ac68d">set_bf_vs_op_clear</a> (bsl::safe_u16 const &amp;vsid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:ac8ce4bd639f19b29fdef4b8d866ac68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_clear. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ac8ce4bd639f19b29fdef4b8d866ac68d">More...</a><br /></td></tr>
<tr class="separator:ac8ce4bd639f19b29fdef4b8d866ac68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55acfe49e16ee0ceebaad4f9b55819a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa55acfe49e16ee0ceebaad4f9b55819a">bf_vs_op_clear_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:aa55acfe49e16ee0ceebaad4f9b55819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_clear has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aa55acfe49e16ee0ceebaad4f9b55819a">More...</a><br /></td></tr>
<tr class="separator:aa55acfe49e16ee0ceebaad4f9b55819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec08e8cd3cd1b5649d61e7077e1a151"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#abec08e8cd3cd1b5649d61e7077e1a151">bf_vs_op_migrate</a> (bsl::safe_u16 const &amp;vsid, bsl::safe_u16 const &amp;ppid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:abec08e8cd3cd1b5649d61e7077e1a151"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#abec08e8cd3cd1b5649d61e7077e1a151">More...</a><br /></td></tr>
<tr class="separator:abec08e8cd3cd1b5649d61e7077e1a151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cf390cc8749c1e50dfa9b60bf8909b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad0cf390cc8749c1e50dfa9b60bf8909b">set_bf_vs_op_migrate</a> (bsl::safe_u16 const &amp;vsid, bsl::safe_u16 const &amp;ppid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:ad0cf390cc8749c1e50dfa9b60bf8909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_migrate. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ad0cf390cc8749c1e50dfa9b60bf8909b">More...</a><br /></td></tr>
<tr class="separator:ad0cf390cc8749c1e50dfa9b60bf8909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa315f911f7b1b4cc49df8de0baef9df7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa315f911f7b1b4cc49df8de0baef9df7">bf_vs_op_migrate_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:aa315f911f7b1b4cc49df8de0baef9df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_migrate has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aa315f911f7b1b4cc49df8de0baef9df7">More...</a><br /></td></tr>
<tr class="separator:aa315f911f7b1b4cc49df8de0baef9df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3e33ac1f5b3e2947355d38cf76363bdf">bf_vs_op_set_active</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#a3e33ac1f5b3e2947355d38cf76363bdf">More...</a><br /></td></tr>
<tr class="separator:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f42864d9def5c50ac1856078b88458f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2f42864d9def5c50ac1856078b88458f">set_bf_vs_op_set_active</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a2f42864d9def5c50ac1856078b88458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_set_active. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a2f42864d9def5c50ac1856078b88458f">More...</a><br /></td></tr>
<tr class="separator:a2f42864d9def5c50ac1856078b88458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27ce6b2323a772ae232d085b0e853de"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac27ce6b2323a772ae232d085b0e853de">bf_vs_op_set_active_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ac27ce6b2323a772ae232d085b0e853de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_set_active has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ac27ce6b2323a772ae232d085b0e853de">More...</a><br /></td></tr>
<tr class="separator:ac27ce6b2323a772ae232d085b0e853de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48188bdfdaa4e525e0910a0f89f5f409"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a48188bdfdaa4e525e0910a0f89f5f409">bf_vs_op_advance_ip_and_set_active</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a48188bdfdaa4e525e0910a0f89f5f409"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#a48188bdfdaa4e525e0910a0f89f5f409">More...</a><br /></td></tr>
<tr class="separator:a48188bdfdaa4e525e0910a0f89f5f409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0726bb1b7718dee39843424c79a6080c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a0726bb1b7718dee39843424c79a6080c">set_bf_vs_op_advance_ip_and_set_active</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a0726bb1b7718dee39843424c79a6080c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_advance_ip_and_set_active. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a0726bb1b7718dee39843424c79a6080c">More...</a><br /></td></tr>
<tr class="separator:a0726bb1b7718dee39843424c79a6080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59d64e9e93df0541d7dbc5cdf6dd60d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad59d64e9e93df0541d7dbc5cdf6dd60d">bf_vs_op_advance_ip_and_set_active_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ad59d64e9e93df0541d7dbc5cdf6dd60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_advance_ip_and_set_active has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#ad59d64e9e93df0541d7dbc5cdf6dd60d">More...</a><br /></td></tr>
<tr class="separator:ad59d64e9e93df0541d7dbc5cdf6dd60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">bf_vs_op_tlb_flush</a> (bsl::safe_u16 const &amp;vsid, bsl::safe_u64 const &amp;gla) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the ID of a VS, invalidates a TLB entry for a given GLA on the PP that this is executed on.  <a href="classsyscall_1_1bf__syscall__t.html#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">More...</a><br /></td></tr>
<tr class="separator:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfce59ab025927fae2a7afe9416c105"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a1cfce59ab025927fae2a7afe9416c105">set_bf_vs_op_tlb_flush</a> (bsl::safe_u16 const &amp;vsid, bsl::safe_u64 const &amp;gla, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a1cfce59ab025927fae2a7afe9416c105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_vs_op_tlb_flush. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a1cfce59ab025927fae2a7afe9416c105">More...</a><br /></td></tr>
<tr class="separator:a1cfce59ab025927fae2a7afe9416c105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a60fafd1fd1909185fe8c251ae32fe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a19a60fafd1fd1909185fe8c251ae32fe">bf_vs_op_tlb_flush_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a19a60fafd1fd1909185fe8c251ae32fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_vs_op_tlb_flush has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a19a60fafd1fd1909185fe8c251ae32fe">More...</a><br /></td></tr>
<tr class="separator:a19a60fafd1fd1909185fe8c251ae32fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed00f6cfb54e47de19b8e30c48dc399f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aed00f6cfb54e47de19b8e30c48dc399f">bf_intrinsic_op_rdmsr</a> (bsl::safe_u32 const &amp;msr) const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aed00f6cfb54e47de19b8e30c48dc399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an MSR directly from the CPU given the address of the MSR to read. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be read, and which MSRs that can be read is up to the microkernel's internal policy as well as which architecture the hypervisor is running on.  <a href="classsyscall_1_1bf__syscall__t.html#aed00f6cfb54e47de19b8e30c48dc399f">More...</a><br /></td></tr>
<tr class="separator:aed00f6cfb54e47de19b8e30c48dc399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391c23e27c18d7f00731040592fdc6b6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a391c23e27c18d7f00731040592fdc6b6">set_bf_intrinsic_op_rdmsr</a> (bsl::safe_u32 const &amp;msr, bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a391c23e27c18d7f00731040592fdc6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_intrinsic_op_rdmsr. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a391c23e27c18d7f00731040592fdc6b6">More...</a><br /></td></tr>
<tr class="separator:a391c23e27c18d7f00731040592fdc6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c04c9e4ec995aff660b55c08c1a69"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad06c04c9e4ec995aff660b55c08c1a69">bf_intrinsic_op_wrmsr</a> (bsl::safe_u32 const &amp;msr, bsl::safe_u64 const &amp;val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ad06c04c9e4ec995aff660b55c08c1a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to an MSR directly from the CPU given the address of the MSR to write as well as the value to write. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be written to, and which MSRs that can be written to is up to the microkernel's internal policy as well as which architecture the hypervisor is running on.  <a href="classsyscall_1_1bf__syscall__t.html#ad06c04c9e4ec995aff660b55c08c1a69">More...</a><br /></td></tr>
<tr class="separator:ad06c04c9e4ec995aff660b55c08c1a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d155d1dd633b50b4e2e80bc08d0d8"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a759d155d1dd633b50b4e2e80bc08d0d8">set_bf_intrinsic_op_wrmsr</a> (bsl::safe_u32 const &amp;msr, bsl::safe_u64 const &amp;val, bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a759d155d1dd633b50b4e2e80bc08d0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_intrinsic_op_wrmsr. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a759d155d1dd633b50b4e2e80bc08d0d8">More...</a><br /></td></tr>
<tr class="separator:a759d155d1dd633b50b4e2e80bc08d0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260e1694d4d8bb0029e04b6a79c01e5b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a260e1694d4d8bb0029e04b6a79c01e5b">bf_intrinsic_op_wrmsr_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a260e1694d4d8bb0029e04b6a79c01e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_intrinsic_op_wrmsr has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a260e1694d4d8bb0029e04b6a79c01e5b">More...</a><br /></td></tr>
<tr class="separator:a260e1694d4d8bb0029e04b6a79c01e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2787d14fcb93d6c3f423a9f55d691149"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2787d14fcb93d6c3f423a9f55d691149"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2787d14fcb93d6c3f423a9f55d691149">bf_mem_op_alloc_page</a> (bsl::safe_u64 &amp;mut_phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a2787d14fcb93d6c3f423a9f55d691149"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM.  <a href="classsyscall_1_1bf__syscall__t.html#a2787d14fcb93d6c3f423a9f55d691149">More...</a><br /></td></tr>
<tr class="separator:a2787d14fcb93d6c3f423a9f55d691149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af410bb63b75855bafb20c0a1ba21bf97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af410bb63b75855bafb20c0a1ba21bf97"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af410bb63b75855bafb20c0a1ba21bf97">bf_mem_op_alloc_page</a> () noexcept -&gt; T *</td></tr>
<tr class="memdesc:af410bb63b75855bafb20c0a1ba21bf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM.  <a href="classsyscall_1_1bf__syscall__t.html#af410bb63b75855bafb20c0a1ba21bf97">More...</a><br /></td></tr>
<tr class="separator:af410bb63b75855bafb20c0a1ba21bf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c8b96b2846acc247c9e775eb6f61ed"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af2c8b96b2846acc247c9e775eb6f61ed">set_bf_mem_op_alloc_page</a> (bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:af2c8b96b2846acc247c9e775eb6f61ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_mem_op_alloc_page. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#af2c8b96b2846acc247c9e775eb6f61ed">More...</a><br /></td></tr>
<tr class="separator:af2c8b96b2846acc247c9e775eb6f61ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67e410f59fda175f526220ca6eac966"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af67e410f59fda175f526220ca6eac966">bf_mem_op_alloc_page_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:af67e410f59fda175f526220ca6eac966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_mem_op_alloc_page has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#af67e410f59fda175f526220ca6eac966">More...</a><br /></td></tr>
<tr class="separator:af67e410f59fda175f526220ca6eac966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7c5125fd5cdcd5a02a3aeb73904c8a04">bf_mem_op_alloc_huge</a> (bsl::safe_u64 const &amp;size, bsl::safe_u64 &amp;mut_phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following:  <a href="classsyscall_1_1bf__syscall__t.html#a7c5125fd5cdcd5a02a3aeb73904c8a04">More...</a><br /></td></tr>
<tr class="separator:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#adeca2bbb88777ffb85913e26d8e42ee7">bf_mem_op_alloc_huge</a> (bsl::safe_u64 const &amp;size) noexcept -&gt; T *</td></tr>
<tr class="memdesc:adeca2bbb88777ffb85913e26d8e42ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following:  <a href="classsyscall_1_1bf__syscall__t.html#adeca2bbb88777ffb85913e26d8e42ee7">More...</a><br /></td></tr>
<tr class="separator:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772497d77514bc12dd4c470edecbba2c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a772497d77514bc12dd4c470edecbba2c">set_bf_mem_op_alloc_huge</a> (bsl::errc_type const errc) noexcept</td></tr>
<tr class="memdesc:a772497d77514bc12dd4c470edecbba2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the return value of bf_mem_op_alloc_huge. (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#a772497d77514bc12dd4c470edecbba2c">More...</a><br /></td></tr>
<tr class="separator:a772497d77514bc12dd4c470edecbba2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20961a2f66ce12b6266e5bb1f95273a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa20961a2f66ce12b6266e5bb1f95273a">bf_mem_op_alloc_huge_count</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:aa20961a2f66ce12b6266e5bb1f95273a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of times bf_mem_op_alloc_huge has been called (unit testing only)  <a href="classsyscall_1_1bf__syscall__t.html#aa20961a2f66ce12b6266e5bb1f95273a">More...</a><br /></td></tr>
<tr class="separator:aa20961a2f66ce12b6266e5bb1f95273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581d962f74017a660a78e9ebc4522011"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a581d962f74017a660a78e9ebc4522011">initialize</a> (bsl::safe_u32 const &amp;version, <a class="el" href="namespacesyscall.html#a9cd54917e15d0b4f28199ec88380b8f0">bf_callback_handler_bootstrap_t</a> const pmut_bootstrap_handler, <a class="el" href="namespacesyscall.html#a6e2b46c2a0bee5dacb4906558723b00c">bf_callback_handler_vmexit_t</a> const pmut_vmexit_handler, <a class="el" href="namespacesyscall.html#a0b901eaa1c2f3424d67879f2d5a593c8">bf_callback_handler_fail_t</a> const pmut_fail_handler) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a581d962f74017a660a78e9ebc4522011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by verifying version compatibility, opening a handle and registering the provided callbacks.  <a href="classsyscall_1_1bf__syscall__t.html#a581d962f74017a660a78e9ebc4522011">More...</a><br /></td></tr>
<tr class="separator:a581d962f74017a660a78e9ebc4522011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec9bf8e06592161b3803cd8da2d8cd6"><td class="memItemLeft" align="right" valign="top"><a id="abec9bf8e06592161b3803cd8da2d8cd6" name="abec9bf8e06592161b3803cd8da2d8cd6"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> () noexcept</td></tr>
<tr class="memdesc:abec9bf8e06592161b3803cd8da2d8cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by closing the handle. <br /></td></tr>
<tr class="separator:abec9bf8e06592161b3803cd8da2d8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ced8951c280ceb9cf26ad5a477aa2cf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2ced8951c280ceb9cf26ad5a477aa2cf">handle</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a2ced8951c280ceb9cf26ad5a477aa2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the handle that is used for syscalls. If this class has not been initialized, a default (likely 0) handle is returned.  <a href="classsyscall_1_1bf__syscall__t.html#a2ced8951c280ceb9cf26ad5a477aa2cf">More...</a><br /></td></tr>
<tr class="separator:a2ced8951c280ceb9cf26ad5a477aa2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f4c6acc6dcae301b4bd0cca721752d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a88f4c6acc6dcae301b4bd0cca721752d">bf_vm_op_create_vm</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a88f4c6acc6dcae301b4bd0cca721752d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VM and return it's ID.  <a href="classsyscall_1_1bf__syscall__t.html#a88f4c6acc6dcae301b4bd0cca721752d">More...</a><br /></td></tr>
<tr class="separator:a88f4c6acc6dcae301b4bd0cca721752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa2fbcaf0f75e1bb38d6b2419c2a0f728">bf_vm_op_destroy_vm</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VM given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#aa2fbcaf0f75e1bb38d6b2419c2a0f728">More...</a><br /></td></tr>
<tr class="separator:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbe512644173318a7542718922e6675"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dbe512644173318a7542718922e6675"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a8dbe512644173318a7542718922e6675">bf_vm_op_map_direct</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u64 const &amp;phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a8dbe512644173318a7542718922e6675"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to map a physical address into the VM's direct map. This is the same as directly accessing the direct map with the difference being that software can provide a physical address and receive the precalculated virtual address.  <a href="classsyscall_1_1bf__syscall__t.html#a8dbe512644173318a7542718922e6675">More...</a><br /></td></tr>
<tr class="separator:a8dbe512644173318a7542718922e6675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139ae56700242c7faa45cf0dc06ff615"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a139ae56700242c7faa45cf0dc06ff615"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a139ae56700242c7faa45cf0dc06ff615">bf_vm_op_unmap_direct</a> (bsl::safe_u16 const &amp;vmid, T const *const ptr) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a139ae56700242c7faa45cf0dc06ff615"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct_broadcast, this syscall does not flush the TLB on any other PP, meaning this unmap is local to the PP the call is made on. Attempting to unmap a virtual address from the direct map that has been accessed on any other PP other than the PP this syscall is executed on will result in undefined behavior. This syscall is designed to support mapping and then immediately unmapping a physical address on a single PP during a single VMExit. It can also be used to map on a PP and then use unmap on the same PP during multiple VMExits, but special care must be taken to ensure no other PP can access the map, otherwise UB will occur.  <a href="classsyscall_1_1bf__syscall__t.html#a139ae56700242c7faa45cf0dc06ff615">More...</a><br /></td></tr>
<tr class="separator:a139ae56700242c7faa45cf0dc06ff615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9e55acd5c6abc88969e4fec072b9bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf9e55acd5c6abc88969e4fec072b9bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aaf9e55acd5c6abc88969e4fec072b9bb">bf_vm_op_unmap_direct_broadcast</a> (bsl::safe_u16 const &amp;vmid, T const *const ptr) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aaf9e55acd5c6abc88969e4fec072b9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct, this syscall performs a broadcast TLB flush which means it can be safely used on all direct mapped addresses. The downside of using this function is that it can be a lot slower than bf_vm_op_unmap_direct, especially on systems with a lot of PPs.  <a href="classsyscall_1_1bf__syscall__t.html#aaf9e55acd5c6abc88969e4fec072b9bb">More...</a><br /></td></tr>
<tr class="separator:aaf9e55acd5c6abc88969e4fec072b9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bdf9512b2bac2103cd9712f10e0100"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a22bdf9512b2bac2103cd9712f10e0100">bf_vm_op_tlb_flush</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a22bdf9512b2bac2103cd9712f10e0100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the ID of a VM, invalidates a TLB entry for a given GLA on the PP that this is executed on.  <a href="classsyscall_1_1bf__syscall__t.html#a22bdf9512b2bac2103cd9712f10e0100">More...</a><br /></td></tr>
<tr class="separator:a22bdf9512b2bac2103cd9712f10e0100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3775e0ff37788114cb5f25d2688a5df8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3775e0ff37788114cb5f25d2688a5df8">bf_vp_op_create_vp</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a3775e0ff37788114cb5f25d2688a5df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VP given the IDs of the VM and PP the VP will be assigned to. Upon success, this syscall returns the ID of the newly created VP.  <a href="classsyscall_1_1bf__syscall__t.html#a3775e0ff37788114cb5f25d2688a5df8">More...</a><br /></td></tr>
<tr class="separator:a3775e0ff37788114cb5f25d2688a5df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ebebe1d613b466425d54f29ef8f69a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a21ebebe1d613b466425d54f29ef8f69a">bf_vp_op_destroy_vp</a> (bsl::safe_u16 const &amp;vpid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a21ebebe1d613b466425d54f29ef8f69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VP given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#a21ebebe1d613b466425d54f29ef8f69a">More...</a><br /></td></tr>
<tr class="separator:a21ebebe1d613b466425d54f29ef8f69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00703a6f47968414c287ab76cc7e97c6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a00703a6f47968414c287ab76cc7e97c6">bf_vs_op_create_vs</a> (bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;ppid) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a00703a6f47968414c287ab76cc7e97c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VS and return it's ID.  <a href="classsyscall_1_1bf__syscall__t.html#a00703a6f47968414c287ab76cc7e97c6">More...</a><br /></td></tr>
<tr class="separator:a00703a6f47968414c287ab76cc7e97c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724a2594d24a643e29e10f2022f4cd76"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a724a2594d24a643e29e10f2022f4cd76">bf_vs_op_destroy_vs</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a724a2594d24a643e29e10f2022f4cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VS given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#a724a2594d24a643e29e10f2022f4cd76">More...</a><br /></td></tr>
<tr class="separator:a724a2594d24a643e29e10f2022f4cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7f94f5da4b7fd47aef467ff09324c8a2">bf_vs_op_init_as_root</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to initialize a VS using the root VP state provided by the loader using the current PPID.  <a href="classsyscall_1_1bf__syscall__t.html#a7f94f5da4b7fd47aef467ff09324c8a2">More...</a><br /></td></tr>
<tr class="separator:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a77282b8dd8dd3d06830811cfdde4b8e6">bf_vs_op_read</a> (bsl::safe_u16 const &amp;vsid, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg) const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a CPU register from the VS given a bf_reg_t. Note that the bf_reg_t is architecture specific.  <a href="classsyscall_1_1bf__syscall__t.html#a77282b8dd8dd3d06830811cfdde4b8e6">More...</a><br /></td></tr>
<tr class="separator:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908cbed8d315f98cf49252b8e3446fcd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a908cbed8d315f98cf49252b8e3446fcd">bf_vs_op_write</a> (bsl::safe_u16 const &amp;vsid, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg, bsl::safe_u64 const &amp;value) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a908cbed8d315f98cf49252b8e3446fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to a CPU register in the VS given a bf_reg_t and the value to write. Note that the bf_reg_t is architecture specific.  <a href="classsyscall_1_1bf__syscall__t.html#a908cbed8d315f98cf49252b8e3446fcd">More...</a><br /></td></tr>
<tr class="separator:a908cbed8d315f98cf49252b8e3446fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31edaef67e15222b8192fd07a079a66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa31edaef67e15222b8192fd07a079a66">bf_vs_op_run</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa31edaef67e15222b8192fd07a079a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a VS given the ID of the VM, VP and VS to execute. The VS must be assigned to the provided VP and the provided VP must be assigned to the provided VM. The VP and VS must not be executing on any other PP, and the VS must be assigned to the PP this syscall is executed on. Upon success, this syscall will not return.  <a href="classsyscall_1_1bf__syscall__t.html#aa31edaef67e15222b8192fd07a079a66">More...</a><br /></td></tr>
<tr class="separator:aa31edaef67e15222b8192fd07a079a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2a36f6f20561a82c61cc3b1252db25"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5e2a36f6f20561a82c61cc3b1252db25">bf_vs_op_run_current</a> () noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a5e2a36f6f20561a82c61cc3b1252db25"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_vs_op_run_current tells the microkernel to execute the currently active VS, VP and VM.  <a href="classsyscall_1_1bf__syscall__t.html#a5e2a36f6f20561a82c61cc3b1252db25">More...</a><br /></td></tr>
<tr class="separator:a5e2a36f6f20561a82c61cc3b1252db25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315ebee647ee24661c9b93b65f933d64"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a315ebee647ee24661c9b93b65f933d64">bf_vs_op_advance_ip_and_run</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a315ebee647ee24661c9b93b65f933d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the IP and executes a VS given the ID of the VM, VP and VS to execute. The VS must be assigned to the provided VP and the provided VP must be assigned to the provided VM. The VP and VS must not be executing on any other PP, and the VS must be assigned to the PP this syscall is executed on. Upon success, this syscall will not return.  <a href="classsyscall_1_1bf__syscall__t.html#a315ebee647ee24661c9b93b65f933d64">More...</a><br /></td></tr>
<tr class="separator:a315ebee647ee24661c9b93b65f933d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af7bf62e706e5ce6bc770c6374ec89ec5">bf_vs_op_advance_ip_and_run_current</a> () noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_vs_op_advance_ip_and_run_current tells the microkernel to advance the IP of and execute the currently active VS, VP and VM.  <a href="classsyscall_1_1bf__syscall__t.html#af7bf62e706e5ce6bc770c6374ec89ec5">More...</a><br /></td></tr>
<tr class="separator:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571436e51276a3e613246df1a45d5a1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a571436e51276a3e613246df1a45d5a1b">bf_vs_op_promote</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a571436e51276a3e613246df1a45d5a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to promote the requested VS. This will stop the hypervisor complete on the physical processor that this syscall is executed on and replace it's state with the state in the VS. Note that this syscall only returns on error.  <a href="classsyscall_1_1bf__syscall__t.html#a571436e51276a3e613246df1a45d5a1b">More...</a><br /></td></tr>
<tr class="separator:a571436e51276a3e613246df1a45d5a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92bed718a8641bf68bd5af9078b6fc0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad92bed718a8641bf68bd5af9078b6fc0">bf_vs_op_clear</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ad92bed718a8641bf68bd5af9078b6fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_vs_op_clear tells the microkernel to clear the VS's hardware cache, if one exists. How this is used depends entirely on the hardware and is associated with AMD's VMCB Clean Bits, and Intel's VMClear instruction. See the associated documentation for more details. On AMD, this ABI clears the entire VMCB. For more fine grained control, use the write ABIs to manually modify the VMCB.  <a href="classsyscall_1_1bf__syscall__t.html#ad92bed718a8641bf68bd5af9078b6fc0">More...</a><br /></td></tr>
<tr class="separator:ad92bed718a8641bf68bd5af9078b6fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec08e8cd3cd1b5649d61e7077e1a151"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#abec08e8cd3cd1b5649d61e7077e1a151">bf_vs_op_migrate</a> (bsl::safe_u16 const &amp;vsid, bsl::safe_u16 const &amp;ppid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:abec08e8cd3cd1b5649d61e7077e1a151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrates a VS to the provided PP. The VS must not be active.  <a href="classsyscall_1_1bf__syscall__t.html#abec08e8cd3cd1b5649d61e7077e1a151">More...</a><br /></td></tr>
<tr class="separator:abec08e8cd3cd1b5649d61e7077e1a151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3e33ac1f5b3e2947355d38cf76363bdf">bf_vs_op_set_active</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#a3e33ac1f5b3e2947355d38cf76363bdf">More...</a><br /></td></tr>
<tr class="separator:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48188bdfdaa4e525e0910a0f89f5f409"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a48188bdfdaa4e525e0910a0f89f5f409">bf_vs_op_advance_ip_and_set_active</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a48188bdfdaa4e525e0910a0f89f5f409"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#a48188bdfdaa4e525e0910a0f89f5f409">More...</a><br /></td></tr>
<tr class="separator:a48188bdfdaa4e525e0910a0f89f5f409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">bf_vs_op_tlb_flush</a> (bsl::safe_u16 const &amp;vsid, bsl::safe_u64 const &amp;gla) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the ID of a VS, invalidates a TLB entry for a given GLA on the PP that this is executed on.  <a href="classsyscall_1_1bf__syscall__t.html#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">More...</a><br /></td></tr>
<tr class="separator:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed00f6cfb54e47de19b8e30c48dc399f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aed00f6cfb54e47de19b8e30c48dc399f">bf_intrinsic_op_rdmsr</a> (bsl::safe_u32 const &amp;msr) const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aed00f6cfb54e47de19b8e30c48dc399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an MSR directly from the CPU given the address of the MSR to read. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be read, and which MSRs that can be read is up to the microkernel's internal policy as well as which architecture the hypervisor is running on.  <a href="classsyscall_1_1bf__syscall__t.html#aed00f6cfb54e47de19b8e30c48dc399f">More...</a><br /></td></tr>
<tr class="separator:aed00f6cfb54e47de19b8e30c48dc399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c04c9e4ec995aff660b55c08c1a69"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad06c04c9e4ec995aff660b55c08c1a69">bf_intrinsic_op_wrmsr</a> (bsl::safe_u32 const &amp;msr, bsl::safe_u64 const &amp;val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ad06c04c9e4ec995aff660b55c08c1a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to an MSR directly from the CPU given the address of the MSR to write as well as the value to write. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be written to, and which MSRs that can be written to is up to the microkernel's internal policy as well as which architecture the hypervisor is running on.  <a href="classsyscall_1_1bf__syscall__t.html#ad06c04c9e4ec995aff660b55c08c1a69">More...</a><br /></td></tr>
<tr class="separator:ad06c04c9e4ec995aff660b55c08c1a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2787d14fcb93d6c3f423a9f55d691149"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2787d14fcb93d6c3f423a9f55d691149"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2787d14fcb93d6c3f423a9f55d691149">bf_mem_op_alloc_page</a> (bsl::safe_u64 &amp;mut_phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a2787d14fcb93d6c3f423a9f55d691149"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM.  <a href="classsyscall_1_1bf__syscall__t.html#a2787d14fcb93d6c3f423a9f55d691149">More...</a><br /></td></tr>
<tr class="separator:a2787d14fcb93d6c3f423a9f55d691149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af410bb63b75855bafb20c0a1ba21bf97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af410bb63b75855bafb20c0a1ba21bf97"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af410bb63b75855bafb20c0a1ba21bf97">bf_mem_op_alloc_page</a> () noexcept -&gt; T *</td></tr>
<tr class="memdesc:af410bb63b75855bafb20c0a1ba21bf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM.  <a href="classsyscall_1_1bf__syscall__t.html#af410bb63b75855bafb20c0a1ba21bf97">More...</a><br /></td></tr>
<tr class="separator:af410bb63b75855bafb20c0a1ba21bf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7c5125fd5cdcd5a02a3aeb73904c8a04">bf_mem_op_alloc_huge</a> (bsl::safe_u64 const &amp;size, bsl::safe_u64 &amp;mut_phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following:  <a href="classsyscall_1_1bf__syscall__t.html#a7c5125fd5cdcd5a02a3aeb73904c8a04">More...</a><br /></td></tr>
<tr class="separator:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#adeca2bbb88777ffb85913e26d8e42ee7">bf_mem_op_alloc_huge</a> (bsl::safe_u64 const &amp;size) noexcept -&gt; T *</td></tr>
<tr class="memdesc:adeca2bbb88777ffb85913e26d8e42ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following:  <a href="classsyscall_1_1bf__syscall__t.html#adeca2bbb88777ffb85913e26d8e42ee7">More...</a><br /></td></tr>
<tr class="separator:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a70af417fbf6a855ca587d82d018f457d"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a70af417fbf6a855ca587d82d018f457d">is_vm_the_root_vm</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a70af417fbf6a855ca587d82d018f457d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VMID is the ID of the root VM. Returns false otherwise.  <a href="classsyscall_1_1bf__syscall__t.html#a70af417fbf6a855ca587d82d018f457d">More...</a><br /></td></tr>
<tr class="separator:a70af417fbf6a855ca587d82d018f457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32644c527c752a63686c5710ebe7bae"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad32644c527c752a63686c5710ebe7bae">bf_tls_rax</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ad32644c527c752a63686c5710ebe7bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rax.  <a href="classsyscall_1_1bf__syscall__t.html#ad32644c527c752a63686c5710ebe7bae">More...</a><br /></td></tr>
<tr class="separator:ad32644c527c752a63686c5710ebe7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9acd4d82aee2bc405b11306f889f58"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2e9acd4d82aee2bc405b11306f889f58">bf_tls_set_rax</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a2e9acd4d82aee2bc405b11306f889f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rax.  <a href="classsyscall_1_1bf__syscall__t.html#a2e9acd4d82aee2bc405b11306f889f58">More...</a><br /></td></tr>
<tr class="separator:a2e9acd4d82aee2bc405b11306f889f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33f1320f9301da364b3080b6710e8d6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad33f1320f9301da364b3080b6710e8d6">bf_tls_rbx</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ad33f1320f9301da364b3080b6710e8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rbx.  <a href="classsyscall_1_1bf__syscall__t.html#ad33f1320f9301da364b3080b6710e8d6">More...</a><br /></td></tr>
<tr class="separator:ad33f1320f9301da364b3080b6710e8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9790de8d7d91a94793e09bd53f03377b"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9790de8d7d91a94793e09bd53f03377b">bf_tls_set_rbx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a9790de8d7d91a94793e09bd53f03377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rbx.  <a href="classsyscall_1_1bf__syscall__t.html#a9790de8d7d91a94793e09bd53f03377b">More...</a><br /></td></tr>
<tr class="separator:a9790de8d7d91a94793e09bd53f03377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b0b8367bfa55a5566b2edb20db154b"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a70b0b8367bfa55a5566b2edb20db154b">bf_tls_rcx</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a70b0b8367bfa55a5566b2edb20db154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rcx.  <a href="classsyscall_1_1bf__syscall__t.html#a70b0b8367bfa55a5566b2edb20db154b">More...</a><br /></td></tr>
<tr class="separator:a70b0b8367bfa55a5566b2edb20db154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e5599e55b11896e5e283b14cebfa5"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a585e5599e55b11896e5e283b14cebfa5">bf_tls_set_rcx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a585e5599e55b11896e5e283b14cebfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rcx.  <a href="classsyscall_1_1bf__syscall__t.html#a585e5599e55b11896e5e283b14cebfa5">More...</a><br /></td></tr>
<tr class="separator:a585e5599e55b11896e5e283b14cebfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e407d78c0442751cc69c0fe659225a"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad2e407d78c0442751cc69c0fe659225a">bf_tls_rdx</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ad2e407d78c0442751cc69c0fe659225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rdx.  <a href="classsyscall_1_1bf__syscall__t.html#ad2e407d78c0442751cc69c0fe659225a">More...</a><br /></td></tr>
<tr class="separator:ad2e407d78c0442751cc69c0fe659225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3050ded79cc7955b48db01bfa29cc91b"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3050ded79cc7955b48db01bfa29cc91b">bf_tls_set_rdx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a3050ded79cc7955b48db01bfa29cc91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rdx.  <a href="classsyscall_1_1bf__syscall__t.html#a3050ded79cc7955b48db01bfa29cc91b">More...</a><br /></td></tr>
<tr class="separator:a3050ded79cc7955b48db01bfa29cc91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060d2eed4081b99da45faa59307b0ad7"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a060d2eed4081b99da45faa59307b0ad7">bf_tls_rbp</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a060d2eed4081b99da45faa59307b0ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rbp.  <a href="classsyscall_1_1bf__syscall__t.html#a060d2eed4081b99da45faa59307b0ad7">More...</a><br /></td></tr>
<tr class="separator:a060d2eed4081b99da45faa59307b0ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b496c5edf092ad96dd9d80d8682d63"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa3b496c5edf092ad96dd9d80d8682d63">bf_tls_set_rbp</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aa3b496c5edf092ad96dd9d80d8682d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rbp.  <a href="classsyscall_1_1bf__syscall__t.html#aa3b496c5edf092ad96dd9d80d8682d63">More...</a><br /></td></tr>
<tr class="separator:aa3b496c5edf092ad96dd9d80d8682d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3212ae58f5235454b0ff855c57a3ad9"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac3212ae58f5235454b0ff855c57a3ad9">bf_tls_rsi</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ac3212ae58f5235454b0ff855c57a3ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rsi.  <a href="classsyscall_1_1bf__syscall__t.html#ac3212ae58f5235454b0ff855c57a3ad9">More...</a><br /></td></tr>
<tr class="separator:ac3212ae58f5235454b0ff855c57a3ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e019e91c72a6af1092b25b27c6a876"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac9e019e91c72a6af1092b25b27c6a876">bf_tls_set_rsi</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:ac9e019e91c72a6af1092b25b27c6a876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rsi.  <a href="classsyscall_1_1bf__syscall__t.html#ac9e019e91c72a6af1092b25b27c6a876">More...</a><br /></td></tr>
<tr class="separator:ac9e019e91c72a6af1092b25b27c6a876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d0134ccc7f52edc6ad09935a0cd9e6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a64d0134ccc7f52edc6ad09935a0cd9e6">bf_tls_rdi</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a64d0134ccc7f52edc6ad09935a0cd9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rdi.  <a href="classsyscall_1_1bf__syscall__t.html#a64d0134ccc7f52edc6ad09935a0cd9e6">More...</a><br /></td></tr>
<tr class="separator:a64d0134ccc7f52edc6ad09935a0cd9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab094cde9f7e44801007856e7dcda6afc"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ab094cde9f7e44801007856e7dcda6afc">bf_tls_set_rdi</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:ab094cde9f7e44801007856e7dcda6afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rdi.  <a href="classsyscall_1_1bf__syscall__t.html#ab094cde9f7e44801007856e7dcda6afc">More...</a><br /></td></tr>
<tr class="separator:ab094cde9f7e44801007856e7dcda6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba6aebd69627e0500a16c1b4616504"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a53ba6aebd69627e0500a16c1b4616504">bf_tls_r8</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a53ba6aebd69627e0500a16c1b4616504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r8.  <a href="classsyscall_1_1bf__syscall__t.html#a53ba6aebd69627e0500a16c1b4616504">More...</a><br /></td></tr>
<tr class="separator:a53ba6aebd69627e0500a16c1b4616504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7864bf76ef53e59efd62dc11996736f0"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7864bf76ef53e59efd62dc11996736f0">bf_tls_set_r8</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a7864bf76ef53e59efd62dc11996736f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r8.  <a href="classsyscall_1_1bf__syscall__t.html#a7864bf76ef53e59efd62dc11996736f0">More...</a><br /></td></tr>
<tr class="separator:a7864bf76ef53e59efd62dc11996736f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9355fe923871138ee084c8b112c37dfa"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9355fe923871138ee084c8b112c37dfa">bf_tls_r9</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a9355fe923871138ee084c8b112c37dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r9.  <a href="classsyscall_1_1bf__syscall__t.html#a9355fe923871138ee084c8b112c37dfa">More...</a><br /></td></tr>
<tr class="separator:a9355fe923871138ee084c8b112c37dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8db39b8709a07100619fd76845f3a9d"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa8db39b8709a07100619fd76845f3a9d">bf_tls_set_r9</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aa8db39b8709a07100619fd76845f3a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r9.  <a href="classsyscall_1_1bf__syscall__t.html#aa8db39b8709a07100619fd76845f3a9d">More...</a><br /></td></tr>
<tr class="separator:aa8db39b8709a07100619fd76845f3a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a41e07266ecdffb89f87f7d7af52b33"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5a41e07266ecdffb89f87f7d7af52b33">bf_tls_r10</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a5a41e07266ecdffb89f87f7d7af52b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r10.  <a href="classsyscall_1_1bf__syscall__t.html#a5a41e07266ecdffb89f87f7d7af52b33">More...</a><br /></td></tr>
<tr class="separator:a5a41e07266ecdffb89f87f7d7af52b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb3d5ba6eac1b7f615e9ce3247d860"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a32cb3d5ba6eac1b7f615e9ce3247d860">bf_tls_set_r10</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a32cb3d5ba6eac1b7f615e9ce3247d860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r10.  <a href="classsyscall_1_1bf__syscall__t.html#a32cb3d5ba6eac1b7f615e9ce3247d860">More...</a><br /></td></tr>
<tr class="separator:a32cb3d5ba6eac1b7f615e9ce3247d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d93a8c9b4eddac11aa052d545dafbe"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a62d93a8c9b4eddac11aa052d545dafbe">bf_tls_r11</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a62d93a8c9b4eddac11aa052d545dafbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r11.  <a href="classsyscall_1_1bf__syscall__t.html#a62d93a8c9b4eddac11aa052d545dafbe">More...</a><br /></td></tr>
<tr class="separator:a62d93a8c9b4eddac11aa052d545dafbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e6b33270f41f4a5cd4afb64c84d01a"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad7e6b33270f41f4a5cd4afb64c84d01a">bf_tls_set_r11</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:ad7e6b33270f41f4a5cd4afb64c84d01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r11.  <a href="classsyscall_1_1bf__syscall__t.html#ad7e6b33270f41f4a5cd4afb64c84d01a">More...</a><br /></td></tr>
<tr class="separator:ad7e6b33270f41f4a5cd4afb64c84d01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441e9aaeb8ccaf9cb4ad24308ac2fff9"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a441e9aaeb8ccaf9cb4ad24308ac2fff9">bf_tls_r12</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a441e9aaeb8ccaf9cb4ad24308ac2fff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r12.  <a href="classsyscall_1_1bf__syscall__t.html#a441e9aaeb8ccaf9cb4ad24308ac2fff9">More...</a><br /></td></tr>
<tr class="separator:a441e9aaeb8ccaf9cb4ad24308ac2fff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a44a7a827210f302593813cebf1f64"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af1a44a7a827210f302593813cebf1f64">bf_tls_set_r12</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:af1a44a7a827210f302593813cebf1f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r12.  <a href="classsyscall_1_1bf__syscall__t.html#af1a44a7a827210f302593813cebf1f64">More...</a><br /></td></tr>
<tr class="separator:af1a44a7a827210f302593813cebf1f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e18adc4f4b1ee9213cd6699d32abd2"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a26e18adc4f4b1ee9213cd6699d32abd2">bf_tls_r13</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a26e18adc4f4b1ee9213cd6699d32abd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r13.  <a href="classsyscall_1_1bf__syscall__t.html#a26e18adc4f4b1ee9213cd6699d32abd2">More...</a><br /></td></tr>
<tr class="separator:a26e18adc4f4b1ee9213cd6699d32abd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2f5508b5b544c8973b4e5433a7ab19"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3a2f5508b5b544c8973b4e5433a7ab19">bf_tls_set_r13</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a3a2f5508b5b544c8973b4e5433a7ab19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r13.  <a href="classsyscall_1_1bf__syscall__t.html#a3a2f5508b5b544c8973b4e5433a7ab19">More...</a><br /></td></tr>
<tr class="separator:a3a2f5508b5b544c8973b4e5433a7ab19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4f056e1a81f0e8319bd8383772e9e4"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9b4f056e1a81f0e8319bd8383772e9e4">bf_tls_r14</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a9b4f056e1a81f0e8319bd8383772e9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r14.  <a href="classsyscall_1_1bf__syscall__t.html#a9b4f056e1a81f0e8319bd8383772e9e4">More...</a><br /></td></tr>
<tr class="separator:a9b4f056e1a81f0e8319bd8383772e9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7164a1d32fee2996b92994acd7859732"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7164a1d32fee2996b92994acd7859732">bf_tls_set_r14</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a7164a1d32fee2996b92994acd7859732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r14.  <a href="classsyscall_1_1bf__syscall__t.html#a7164a1d32fee2996b92994acd7859732">More...</a><br /></td></tr>
<tr class="separator:a7164a1d32fee2996b92994acd7859732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed597cc058c0897756a63a097976a9d3"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aed597cc058c0897756a63a097976a9d3">bf_tls_r15</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aed597cc058c0897756a63a097976a9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r15.  <a href="classsyscall_1_1bf__syscall__t.html#aed597cc058c0897756a63a097976a9d3">More...</a><br /></td></tr>
<tr class="separator:aed597cc058c0897756a63a097976a9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3123659a43b876378c07d97877b735"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a8f3123659a43b876378c07d97877b735">bf_tls_set_r15</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a8f3123659a43b876378c07d97877b735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r15.  <a href="classsyscall_1_1bf__syscall__t.html#a8f3123659a43b876378c07d97877b735">More...</a><br /></td></tr>
<tr class="separator:a8f3123659a43b876378c07d97877b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad760118cbd1ae66a60c335253468c"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a92ad760118cbd1ae66a60c335253468c">bf_tls_extid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a92ad760118cbd1ae66a60c335253468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.extid.  <a href="classsyscall_1_1bf__syscall__t.html#a92ad760118cbd1ae66a60c335253468c">More...</a><br /></td></tr>
<tr class="separator:a92ad760118cbd1ae66a60c335253468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0540fcde200282cd1296de26707a70"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#afb0540fcde200282cd1296de26707a70">bf_tls_vmid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:afb0540fcde200282cd1296de26707a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vmid.  <a href="classsyscall_1_1bf__syscall__t.html#afb0540fcde200282cd1296de26707a70">More...</a><br /></td></tr>
<tr class="separator:afb0540fcde200282cd1296de26707a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9a58dde8c3a45c99acfd674230e072"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7a9a58dde8c3a45c99acfd674230e072">bf_tls_vpid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a7a9a58dde8c3a45c99acfd674230e072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vpid.  <a href="classsyscall_1_1bf__syscall__t.html#a7a9a58dde8c3a45c99acfd674230e072">More...</a><br /></td></tr>
<tr class="separator:a7a9a58dde8c3a45c99acfd674230e072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35e5b74544f6bd3d312cac596843ce8"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa35e5b74544f6bd3d312cac596843ce8">bf_tls_vsid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:aa35e5b74544f6bd3d312cac596843ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vsid.  <a href="classsyscall_1_1bf__syscall__t.html#aa35e5b74544f6bd3d312cac596843ce8">More...</a><br /></td></tr>
<tr class="separator:aa35e5b74544f6bd3d312cac596843ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fceb107132749c977a8c651077ad3f8"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7fceb107132749c977a8c651077ad3f8">bf_tls_ppid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a7fceb107132749c977a8c651077ad3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.ppid.  <a href="classsyscall_1_1bf__syscall__t.html#a7fceb107132749c977a8c651077ad3f8">More...</a><br /></td></tr>
<tr class="separator:a7fceb107132749c977a8c651077ad3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5737ec6b2265cddddd9ed602af1ab6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ade5737ec6b2265cddddd9ed602af1ab6">bf_tls_online_pps</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:ade5737ec6b2265cddddd9ed602af1ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.online_pps.  <a href="classsyscall_1_1bf__syscall__t.html#ade5737ec6b2265cddddd9ed602af1ab6">More...</a><br /></td></tr>
<tr class="separator:ade5737ec6b2265cddddd9ed602af1ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c64d0f72191a89ce45489d25a222ac"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a40c64d0f72191a89ce45489d25a222ac">is_the_active_vm_the_root_vm</a> () noexcept -&gt; bool</td></tr>
<tr class="memdesc:a40c64d0f72191a89ce45489d25a222ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the active VM is the root VM. Returns false otherwise.  <a href="classsyscall_1_1bf__syscall__t.html#a40c64d0f72191a89ce45489d25a222ac">More...</a><br /></td></tr>
<tr class="separator:a40c64d0f72191a89ce45489d25a222ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70af417fbf6a855ca587d82d018f457d"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a70af417fbf6a855ca587d82d018f457d">is_vm_the_root_vm</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a70af417fbf6a855ca587d82d018f457d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VMID is the ID of the root VM. Returns false otherwise.  <a href="classsyscall_1_1bf__syscall__t.html#a70af417fbf6a855ca587d82d018f457d">More...</a><br /></td></tr>
<tr class="separator:a70af417fbf6a855ca587d82d018f457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f765958a06805a1ea5fabfa3333d23"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a38f765958a06805a1ea5fabfa3333d23">is_vp_a_root_vp</a> (bsl::safe_u16 const &amp;vpid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a38f765958a06805a1ea5fabfa3333d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid().  <a href="classsyscall_1_1bf__syscall__t.html#a38f765958a06805a1ea5fabfa3333d23">More...</a><br /></td></tr>
<tr class="separator:a38f765958a06805a1ea5fabfa3333d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d062e733c278938437d85e8f879eef7"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9d062e733c278938437d85e8f879eef7">is_vs_a_root_vs</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a9d062e733c278938437d85e8f879eef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid().  <a href="classsyscall_1_1bf__syscall__t.html#a9d062e733c278938437d85e8f879eef7">More...</a><br /></td></tr>
<tr class="separator:a9d062e733c278938437d85e8f879eef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs, please see the Microkernel ABI Specification. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a581d962f74017a660a78e9ebc4522011" name="a581d962f74017a660a78e9ebc4522011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581d962f74017a660a78e9ebc4522011">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::initialize </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a9cd54917e15d0b4f28199ec88380b8f0">bf_callback_handler_bootstrap_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_bootstrap_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a6e2b46c2a0bee5dacb4906558723b00c">bf_callback_handler_vmexit_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_vmexit_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a0b901eaa1c2f3424d67879f2d5a593c8">bf_callback_handler_fail_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_fail_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by verifying version compatibility, opening a handle and registering the provided callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>the version provided to the extension by the microkernel. If this API does not support the ABI versions that the microkernel supports, this function will fail. </td></tr>
    <tr><td class="paramname">pmut_bootstrap_handler</td><td>the bootstrap handler to register </td></tr>
    <tr><td class="paramname">pmut_vmexit_handler</td><td>the vmexit handler to register </td></tr>
    <tr><td class="paramname">pmut_fail_handler</td><td>the fail handler to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a08ddd4ce4a0281fc41e39f6f4d64ae93" name="a08ddd4ce4a0281fc41e39f6f4d64ae93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ddd4ce4a0281fc41e39f6f4d64ae93">&#9670;&nbsp;</a></span>set_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_initialize </td>
          <td>(</td>
          <td class="paramtype">bsl::errc_type const &amp;&#160;</td>
          <td class="paramname"><em>errc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of initialize. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a349e358e66194c43e2ca87fccf61c56a" name="a349e358e66194c43e2ca87fccf61c56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349e358e66194c43e2ca87fccf61c56a">&#9670;&nbsp;</a></span>initialize_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::initialize_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times initialize has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times initialize has been called </dd></dl>

</div>
</div>
<a id="a1dbfcf6c373c660c2e31b7c49bb43984" name="a1dbfcf6c373c660c2e31b7c49bb43984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbfcf6c373c660c2e31b7c49bb43984">&#9670;&nbsp;</a></span>release_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::release_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times release has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times release has been called </dd></dl>

</div>
</div>
<a id="a53d27e2c617852c19cfa4be9342c8378" name="a53d27e2c617852c19cfa4be9342c8378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d27e2c617852c19cfa4be9342c8378">&#9670;&nbsp;</a></span>bf_tls_rax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_rax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rax. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rax </dd></dl>

</div>
</div>
<a id="a6d94c7ee2352e816e8b526584647268e" name="a6d94c7ee2352e816e8b526584647268e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d94c7ee2352e816e8b526584647268e">&#9670;&nbsp;</a></span>bf_tls_set_rax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_rax </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rax to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409f6b5e424cbe8788c66c095a350a38" name="a409f6b5e424cbe8788c66c095a350a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409f6b5e424cbe8788c66c095a350a38">&#9670;&nbsp;</a></span>bf_tls_set_rax_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_rax_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_rax has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_rax has been called </dd></dl>

</div>
</div>
<a id="a1babc66df343b7265140beea81bcdb39" name="a1babc66df343b7265140beea81bcdb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1babc66df343b7265140beea81bcdb39">&#9670;&nbsp;</a></span>bf_tls_rbx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_rbx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rbx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rbx </dd></dl>

</div>
</div>
<a id="a75cb47e52b4ad6226d45abc0987ce9af" name="a75cb47e52b4ad6226d45abc0987ce9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cb47e52b4ad6226d45abc0987ce9af">&#9670;&nbsp;</a></span>bf_tls_set_rbx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_rbx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rbx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rbx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7d6aa2cda8cc47e6b2c0acd803cdd7e" name="ab7d6aa2cda8cc47e6b2c0acd803cdd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d6aa2cda8cc47e6b2c0acd803cdd7e">&#9670;&nbsp;</a></span>bf_tls_set_rbx_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_rbx_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_rbx has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_rbx has been called </dd></dl>

</div>
</div>
<a id="a0e7a01634b852f33423f69750effd0f4" name="a0e7a01634b852f33423f69750effd0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7a01634b852f33423f69750effd0f4">&#9670;&nbsp;</a></span>bf_tls_rcx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_rcx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rcx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rcx </dd></dl>

</div>
</div>
<a id="a4c14a8acece08bfd6a9bef2abbf313e3" name="a4c14a8acece08bfd6a9bef2abbf313e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c14a8acece08bfd6a9bef2abbf313e3">&#9670;&nbsp;</a></span>bf_tls_set_rcx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_rcx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rcx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rcx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9690844720478ff4248ec4f6a6d70cd" name="ad9690844720478ff4248ec4f6a6d70cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9690844720478ff4248ec4f6a6d70cd">&#9670;&nbsp;</a></span>bf_tls_set_rcx_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_rcx_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_rcx has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_rcx has been called </dd></dl>

</div>
</div>
<a id="a6206d928d512296f8a991e721b13b311" name="a6206d928d512296f8a991e721b13b311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6206d928d512296f8a991e721b13b311">&#9670;&nbsp;</a></span>bf_tls_rdx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_rdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rdx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rdx </dd></dl>

</div>
</div>
<a id="a5e274ad87143a3f5fa6d46db30a92140" name="a5e274ad87143a3f5fa6d46db30a92140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e274ad87143a3f5fa6d46db30a92140">&#9670;&nbsp;</a></span>bf_tls_set_rdx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_rdx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rdx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rdx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa800cb8db2cc010faa214f9575a487ec" name="aa800cb8db2cc010faa214f9575a487ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa800cb8db2cc010faa214f9575a487ec">&#9670;&nbsp;</a></span>bf_tls_set_rdx_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_rdx_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_rdx has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_rdx has been called </dd></dl>

</div>
</div>
<a id="a1a4dbeba43527e5890ffe3e7d4f99c0b" name="a1a4dbeba43527e5890ffe3e7d4f99c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4dbeba43527e5890ffe3e7d4f99c0b">&#9670;&nbsp;</a></span>bf_tls_rbp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_rbp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rbp. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rbp </dd></dl>

</div>
</div>
<a id="a8c6c838410d5d9fcae29957c3dfe39a1" name="a8c6c838410d5d9fcae29957c3dfe39a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6c838410d5d9fcae29957c3dfe39a1">&#9670;&nbsp;</a></span>bf_tls_set_rbp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_rbp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rbp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rbp to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0b33d8ab200ff7c957ddad6084dad91" name="ad0b33d8ab200ff7c957ddad6084dad91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b33d8ab200ff7c957ddad6084dad91">&#9670;&nbsp;</a></span>bf_tls_set_rbp_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_rbp_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_rbp has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_rbp has been called </dd></dl>

</div>
</div>
<a id="a5c1b31c0d096a1ab65fc57e3ff565a03" name="a5c1b31c0d096a1ab65fc57e3ff565a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1b31c0d096a1ab65fc57e3ff565a03">&#9670;&nbsp;</a></span>bf_tls_rsi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_rsi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rsi. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rsi </dd></dl>

</div>
</div>
<a id="a99398cc6bf32939bdf633c3067ef9b73" name="a99398cc6bf32939bdf633c3067ef9b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99398cc6bf32939bdf633c3067ef9b73">&#9670;&nbsp;</a></span>bf_tls_set_rsi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_rsi </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rsi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rsi to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23b2c26958e01663664ebc3285b34321" name="a23b2c26958e01663664ebc3285b34321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b2c26958e01663664ebc3285b34321">&#9670;&nbsp;</a></span>bf_tls_set_rsi_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_rsi_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_rsi has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_rsi has been called </dd></dl>

</div>
</div>
<a id="a3c0a684b3263130287537b2511216265" name="a3c0a684b3263130287537b2511216265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0a684b3263130287537b2511216265">&#9670;&nbsp;</a></span>bf_tls_rdi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_rdi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rdi. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rdi </dd></dl>

</div>
</div>
<a id="a9805fce4d2e56e24f6f6cdf9c06c280f" name="a9805fce4d2e56e24f6f6cdf9c06c280f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9805fce4d2e56e24f6f6cdf9c06c280f">&#9670;&nbsp;</a></span>bf_tls_set_rdi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_rdi </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rdi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rdi to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34869d8036420ba62d1bf77a4dd9daf5" name="a34869d8036420ba62d1bf77a4dd9daf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34869d8036420ba62d1bf77a4dd9daf5">&#9670;&nbsp;</a></span>bf_tls_set_rdi_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_rdi_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_rdi has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_rdi has been called </dd></dl>

</div>
</div>
<a id="a3b2e5940a71025bccc00e46aedaa79e7" name="a3b2e5940a71025bccc00e46aedaa79e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2e5940a71025bccc00e46aedaa79e7">&#9670;&nbsp;</a></span>bf_tls_r8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_r8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r8. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r8 </dd></dl>

</div>
</div>
<a id="a6e38b52a40c96eeb94f7348dcb994e2f" name="a6e38b52a40c96eeb94f7348dcb994e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e38b52a40c96eeb94f7348dcb994e2f">&#9670;&nbsp;</a></span>bf_tls_set_r8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_r8 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r8 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e60e3d9d636eb75eea790e4b5b2f39f" name="a6e60e3d9d636eb75eea790e4b5b2f39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e60e3d9d636eb75eea790e4b5b2f39f">&#9670;&nbsp;</a></span>bf_tls_set_r8_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_r8_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_r8 has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_r8 has been called </dd></dl>

</div>
</div>
<a id="a589fda1683bac0785515ed0a5b4bba49" name="a589fda1683bac0785515ed0a5b4bba49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589fda1683bac0785515ed0a5b4bba49">&#9670;&nbsp;</a></span>bf_tls_r9() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_r9 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r9. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r9 </dd></dl>

</div>
</div>
<a id="aa8ce5eb149c246bb6670f16038e63381" name="aa8ce5eb149c246bb6670f16038e63381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ce5eb149c246bb6670f16038e63381">&#9670;&nbsp;</a></span>bf_tls_set_r9() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_r9 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r9. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r9 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a584557840667e0a306606d0bafbf923f" name="a584557840667e0a306606d0bafbf923f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584557840667e0a306606d0bafbf923f">&#9670;&nbsp;</a></span>bf_tls_set_r9_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_r9_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_r9 has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_r9 has been called </dd></dl>

</div>
</div>
<a id="a6686db96ea48ea21efa1fb81b3ab7e0c" name="a6686db96ea48ea21efa1fb81b3ab7e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6686db96ea48ea21efa1fb81b3ab7e0c">&#9670;&nbsp;</a></span>bf_tls_r10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_r10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r10. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r10 </dd></dl>

</div>
</div>
<a id="aae33dd0ecd7d1045029e63bddb57d17a" name="aae33dd0ecd7d1045029e63bddb57d17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae33dd0ecd7d1045029e63bddb57d17a">&#9670;&nbsp;</a></span>bf_tls_set_r10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_r10 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r10 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af51dd1df03f3ecbc47f50c376bb2dc7c" name="af51dd1df03f3ecbc47f50c376bb2dc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51dd1df03f3ecbc47f50c376bb2dc7c">&#9670;&nbsp;</a></span>bf_tls_set_r10_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_r10_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_r10 has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_r10 has been called </dd></dl>

</div>
</div>
<a id="ac56d669c774f7789a3c25e0ec5702335" name="ac56d669c774f7789a3c25e0ec5702335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56d669c774f7789a3c25e0ec5702335">&#9670;&nbsp;</a></span>bf_tls_r11() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_r11 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r11. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r11 </dd></dl>

</div>
</div>
<a id="a3a863102011808e9cb8f4934fb7ce2bd" name="a3a863102011808e9cb8f4934fb7ce2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a863102011808e9cb8f4934fb7ce2bd">&#9670;&nbsp;</a></span>bf_tls_set_r11() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_r11 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r11. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r11 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b5eb1c5c7cbda9c1bd865ae13451303" name="a4b5eb1c5c7cbda9c1bd865ae13451303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5eb1c5c7cbda9c1bd865ae13451303">&#9670;&nbsp;</a></span>bf_tls_set_r11_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_r11_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_r11 has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_r11 has been called </dd></dl>

</div>
</div>
<a id="ad9c3bcfd8a6e49e8ae2b414e3c50199f" name="ad9c3bcfd8a6e49e8ae2b414e3c50199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c3bcfd8a6e49e8ae2b414e3c50199f">&#9670;&nbsp;</a></span>bf_tls_r12() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_r12 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r12. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r12 </dd></dl>

</div>
</div>
<a id="a67fa94a48fb4f9240306440861e72796" name="a67fa94a48fb4f9240306440861e72796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fa94a48fb4f9240306440861e72796">&#9670;&nbsp;</a></span>bf_tls_set_r12() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_r12 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r12. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r12 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef2189bf27b4a1a2f45c964bb9095aff" name="aef2189bf27b4a1a2f45c964bb9095aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2189bf27b4a1a2f45c964bb9095aff">&#9670;&nbsp;</a></span>bf_tls_set_r12_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_r12_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_r12 has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_r12 has been called </dd></dl>

</div>
</div>
<a id="af33dbc59e96470b4cdf0c96487c5c95e" name="af33dbc59e96470b4cdf0c96487c5c95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33dbc59e96470b4cdf0c96487c5c95e">&#9670;&nbsp;</a></span>bf_tls_r13() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_r13 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r13. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r13 </dd></dl>

</div>
</div>
<a id="adfdaa1b703f812a99c4f20146beacfa4" name="adfdaa1b703f812a99c4f20146beacfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdaa1b703f812a99c4f20146beacfa4">&#9670;&nbsp;</a></span>bf_tls_set_r13() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_r13 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r13. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r13 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b95ad79276121a7054010cd7d4a2b0d" name="a7b95ad79276121a7054010cd7d4a2b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b95ad79276121a7054010cd7d4a2b0d">&#9670;&nbsp;</a></span>bf_tls_set_r13_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_r13_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_r13 has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_r13 has been called </dd></dl>

</div>
</div>
<a id="af7900b502ae05c2ec0c649d55d2120ea" name="af7900b502ae05c2ec0c649d55d2120ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7900b502ae05c2ec0c649d55d2120ea">&#9670;&nbsp;</a></span>bf_tls_r14() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_r14 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r14. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r14 </dd></dl>

</div>
</div>
<a id="a314a6fd63fdbd26c8789ab06829d7456" name="a314a6fd63fdbd26c8789ab06829d7456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314a6fd63fdbd26c8789ab06829d7456">&#9670;&nbsp;</a></span>bf_tls_set_r14() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_r14 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r14. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r14 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c4fb8a6a6e745becdc6ec627dfe80e9" name="a7c4fb8a6a6e745becdc6ec627dfe80e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4fb8a6a6e745becdc6ec627dfe80e9">&#9670;&nbsp;</a></span>bf_tls_set_r14_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_r14_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_r14 has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_r14 has been called </dd></dl>

</div>
</div>
<a id="a19b3c42ea7b5af2cb01108cd051d5fb2" name="a19b3c42ea7b5af2cb01108cd051d5fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b3c42ea7b5af2cb01108cd051d5fb2">&#9670;&nbsp;</a></span>bf_tls_r15() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_r15 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r15. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r15 </dd></dl>

</div>
</div>
<a id="a2ae034b61b0c8860503c53444fea4136" name="a2ae034b61b0c8860503c53444fea4136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae034b61b0c8860503c53444fea4136">&#9670;&nbsp;</a></span>bf_tls_set_r15() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_r15 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r15. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r15 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a559945a6c694220228f2e064d4d8bb49" name="a559945a6c694220228f2e064d4d8bb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559945a6c694220228f2e064d4d8bb49">&#9670;&nbsp;</a></span>bf_tls_set_r15_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_set_r15_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_tls_set_r15 has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_tls_set_r15 has been called </dd></dl>

</div>
</div>
<a id="a2bdbacb64e3a66fe8deed91d530c0a3b" name="a2bdbacb64e3a66fe8deed91d530c0a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdbacb64e3a66fe8deed91d530c0a3b">&#9670;&nbsp;</a></span>bf_tls_extid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_extid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.extid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.extid </dd></dl>

</div>
</div>
<a id="ae9f72868646bbf22f4578435fd41b378" name="ae9f72868646bbf22f4578435fd41b378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f72868646bbf22f4578435fd41b378">&#9670;&nbsp;</a></span>bf_tls_set_extid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_extid </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.extid (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.extid to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c338b6f6364850255d7b46cdf2cb0cf" name="a4c338b6f6364850255d7b46cdf2cb0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c338b6f6364850255d7b46cdf2cb0cf">&#9670;&nbsp;</a></span>bf_tls_vmid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_vmid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vmid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vmid </dd></dl>

</div>
</div>
<a id="a81f797965cd102615f2845102dc69c87" name="a81f797965cd102615f2845102dc69c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f797965cd102615f2845102dc69c87">&#9670;&nbsp;</a></span>bf_tls_set_vmid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_vmid </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.vmid (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.vmid to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a569fa9c3681f3ac3c733a135cbb177e5" name="a569fa9c3681f3ac3c733a135cbb177e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569fa9c3681f3ac3c733a135cbb177e5">&#9670;&nbsp;</a></span>bf_tls_vpid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_vpid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vpid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vpid </dd></dl>

</div>
</div>
<a id="a251cf8ec883ee4547ecaaaf68c95e2a1" name="a251cf8ec883ee4547ecaaaf68c95e2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251cf8ec883ee4547ecaaaf68c95e2a1">&#9670;&nbsp;</a></span>bf_tls_set_vpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_vpid </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.vpid (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.vpid to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4644f8f5bf4ff1d81053094417d3c31" name="ac4644f8f5bf4ff1d81053094417d3c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4644f8f5bf4ff1d81053094417d3c31">&#9670;&nbsp;</a></span>bf_tls_vsid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_vsid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vsid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vsid </dd></dl>

</div>
</div>
<a id="aba23dc2f3e768f6ce065eb3dc8a4ee0e" name="aba23dc2f3e768f6ce065eb3dc8a4ee0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba23dc2f3e768f6ce065eb3dc8a4ee0e">&#9670;&nbsp;</a></span>bf_tls_set_vsid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_vsid </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.vsid (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.vsid to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57241deea2d0728f8ef1010ad3e6354b" name="a57241deea2d0728f8ef1010ad3e6354b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57241deea2d0728f8ef1010ad3e6354b">&#9670;&nbsp;</a></span>bf_tls_ppid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_ppid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.ppid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.ppid </dd></dl>

</div>
</div>
<a id="aea38fbf023bc3a978bb22be59110eb08" name="aea38fbf023bc3a978bb22be59110eb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea38fbf023bc3a978bb22be59110eb08">&#9670;&nbsp;</a></span>bf_tls_set_ppid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_ppid </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.ppid (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.ppid to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88c79135d8efef39a7625b6d3fd75b98" name="a88c79135d8efef39a7625b6d3fd75b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c79135d8efef39a7625b6d3fd75b98">&#9670;&nbsp;</a></span>bf_tls_online_pps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_tls_online_pps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.online_pps. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.online_pps </dd></dl>

</div>
</div>
<a id="a512ede7a30c45ac8c1532ed8d73c5b78" name="a512ede7a30c45ac8c1532ed8d73c5b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512ede7a30c45ac8c1532ed8d73c5b78">&#9670;&nbsp;</a></span>bf_tls_set_online_pps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::bf_tls_set_online_pps </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.online_pps (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.online_pps to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e8a0fcf4ca2f0ed46d0feef9b58eed3" name="a9e8a0fcf4ca2f0ed46d0feef9b58eed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8a0fcf4ca2f0ed46d0feef9b58eed3">&#9670;&nbsp;</a></span>is_the_active_vm_the_root_vm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::is_the_active_vm_the_root_vm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the active VM is the root VM. Returns false otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the active VM is the root VM. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a70af417fbf6a855ca587d82d018f457d" name="a70af417fbf6a855ca587d82d018f457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70af417fbf6a855ca587d82d018f457d">&#9670;&nbsp;</a></span>is_vm_the_root_vm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_vm_the_root_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VMID is the ID of the root VM. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>the ID of the VM to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VMID is the ID of the root VM. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a891d55979ba9d9d57a0d2827ac5d4894" name="a891d55979ba9d9d57a0d2827ac5d4894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891d55979ba9d9d57a0d2827ac5d4894">&#9670;&nbsp;</a></span>is_vp_a_root_vp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::is_vp_a_root_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>the ID of the VP to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid(). </dd></dl>

</div>
</div>
<a id="a75cf91388323861b3ad9bcdcb24f8ab1" name="a75cf91388323861b3ad9bcdcb24f8ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf91388323861b3ad9bcdcb24f8ab1">&#9670;&nbsp;</a></span>is_vs_a_root_vs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::is_vs_a_root_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>the ID of the VS to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid(). </dd></dl>

</div>
</div>
<a id="a88f4c6acc6dcae301b4bd0cca721752d" name="a88f4c6acc6dcae301b4bd0cca721752d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f4c6acc6dcae301b4bd0cca721752d">&#9670;&nbsp;</a></span>bf_vm_op_create_vm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_create_vm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VM and return it's ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ad63aea2efc992d6747002b4c221ac031" name="ad63aea2efc992d6747002b4c221ac031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63aea2efc992d6747002b4c221ac031">&#9670;&nbsp;</a></span>set_bf_vm_op_create_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vm_op_create_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vm_op_create_vm. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>the ID to return when executing bf_vm_op_create_vm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1650ebcaea08ffe5616ae8e5ec38898" name="ae1650ebcaea08ffe5616ae8e5ec38898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1650ebcaea08ffe5616ae8e5ec38898">&#9670;&nbsp;</a></span>bf_vm_op_create_vm_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_create_vm_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vm_op_create_vm has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vm_op_create_vm has been called </dd></dl>

</div>
</div>
<a id="aa2fbcaf0f75e1bb38d6b2419c2a0f728" name="aa2fbcaf0f75e1bb38d6b2419c2a0f728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fbcaf0f75e1bb38d6b2419c2a0f728">&#9670;&nbsp;</a></span>bf_vm_op_destroy_vm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_destroy_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VM given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ae38b1ea18f76f926467f45c756e5dfbf" name="ae38b1ea18f76f926467f45c756e5dfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38b1ea18f76f926467f45c756e5dfbf">&#9670;&nbsp;</a></span>set_bf_vm_op_destroy_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vm_op_destroy_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vm_op_destroy_vm. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to destroy </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vm_op_destroy_vm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d1e6558b296504004631e0b2493ba20" name="a5d1e6558b296504004631e0b2493ba20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1e6558b296504004631e0b2493ba20">&#9670;&nbsp;</a></span>bf_vm_op_destroy_vm_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_destroy_vm_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vm_op_destroy_vm has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vm_op_destroy_vm has been called </dd></dl>

</div>
</div>
<a id="a8dbe512644173318a7542718922e6675" name="a8dbe512644173318a7542718922e6675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbe512644173318a7542718922e6675">&#9670;&nbsp;</a></span>bf_vm_op_map_direct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_map_direct </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to map a physical address into the VM's direct map. This is the same as directly accessing the direct map with the difference being that software can provide a physical address and receive the precalculated virtual address. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to map the physical address to </td></tr>
    <tr><td class="paramname">phys</td><td>The physical address to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the map on success, returns a nullptr on failure. </dd></dl>
<p >NOTE:</p><ul>
<li>If we ever need to store T and return is so that a unit test can mess around with it, we can use the same pattern used by the page_pool_t, where a set of helper functions manage what types T can be, and set/get a pointer to T in a union for this class so that it just stores the union. This is needed because we can only store a void * since we will do know what T should be, and as a result we cannot return a T *, because in a constexpr, you cannot do a static cast from a void * to a T *.</li>
</ul>

</div>
</div>
<a id="ac671ca3eb92574511278b5c54207479d" name="ac671ca3eb92574511278b5c54207479d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac671ca3eb92574511278b5c54207479d">&#9670;&nbsp;</a></span>set_bf_vm_op_map_direct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vm_op_map_direct </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vm_op_map_direct. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to map the physical address to </td></tr>
    <tr><td class="paramname">errc</td><td>if set to any "failure" error code, bf_vm_op_map_direct will return a nullptr. Otherwise, the use of this function is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fb5b60f13cf7d67d35f1536198442ee" name="a1fb5b60f13cf7d67d35f1536198442ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb5b60f13cf7d67d35f1536198442ee">&#9670;&nbsp;</a></span>bf_vm_op_map_direct_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_map_direct_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vm_op_map_direct has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vm_op_map_direct has been called </dd></dl>

</div>
</div>
<a id="a632632beab87dbc4094684bf465285a8" name="a632632beab87dbc4094684bf465285a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632632beab87dbc4094684bf465285a8">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_unmap_direct </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>pmut_virt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct_broadcast, this syscall does not flush the TLB on any other PP, meaning this unmap is local to the PP the call is made on. Attempting to unmap a virtual address from the direct map that has been accessed on any other PP other than the PP this syscall is executed on will result in undefined behavior. This syscall is designed to support mapping and then immediately unmapping a physical address on a single PP during a single VMExit. It can also be used to map on a PP and then use unmap on the same PP during multiple VMExits, but special care must be taken to ensure no other PP can access the map, otherwise UB will occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to unmap the virtual address from </td></tr>
    <tr><td class="paramname">pmut_virt</td><td>The virtual address to unmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a172b50038e0ebd30cfbd3b863f874fb8" name="a172b50038e0ebd30cfbd3b863f874fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172b50038e0ebd30cfbd3b863f874fb8">&#9670;&nbsp;</a></span>set_bf_vm_op_unmap_direct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vm_op_unmap_direct </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vm_op_unmap_direct. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to unmap the virtual address from </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vm_op_unmap_direct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a64a79f906b03966df37b91ed335cc" name="a32a64a79f906b03966df37b91ed335cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a64a79f906b03966df37b91ed335cc">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_unmap_direct_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vm_op_unmap_direct has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vm_op_unmap_direct has been called </dd></dl>

</div>
</div>
<a id="a8454c2c8f80cf0fe30eabe7539bce8a7" name="a8454c2c8f80cf0fe30eabe7539bce8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8454c2c8f80cf0fe30eabe7539bce8a7">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct_broadcast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_unmap_direct_broadcast </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>pmut_virt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct, this syscall performs a broadcast TLB flush which means it can be safely used on all direct mapped addresses. The downside of using this function is that it can be a lot slower than bf_vm_op_unmap_direct, especially on systems with a lot of PPs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to unmap the virtual address from </td></tr>
    <tr><td class="paramname">pmut_virt</td><td>The virtual address to unmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aa609445eb96f0ec0b18bae400fd5190a" name="aa609445eb96f0ec0b18bae400fd5190a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa609445eb96f0ec0b18bae400fd5190a">&#9670;&nbsp;</a></span>set_bf_vm_op_unmap_direct_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vm_op_unmap_direct_broadcast </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vm_op_unmap_direct_broadcast. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to unmap the virtual address from </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vm_op_unmap_direct_broadcast </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71e5d2d7df3a0de221852b829bbb93d7" name="a71e5d2d7df3a0de221852b829bbb93d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e5d2d7df3a0de221852b829bbb93d7">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct_broadcast_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_unmap_direct_broadcast_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vm_op_unmap_direct_broadcast has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vm_op_unmap_direct_broadcast has been called </dd></dl>

</div>
</div>
<a id="a22bdf9512b2bac2103cd9712f10e0100" name="a22bdf9512b2bac2103cd9712f10e0100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bdf9512b2bac2103cd9712f10e0100">&#9670;&nbsp;</a></span>bf_vm_op_tlb_flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the ID of a VM, invalidates a TLB entry for a given GLA on the PP that this is executed on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to invalidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a1a584c0439f2353d7a5e0ad92bf3d9d5" name="a1a584c0439f2353d7a5e0ad92bf3d9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a584c0439f2353d7a5e0ad92bf3d9d5">&#9670;&nbsp;</a></span>set_bf_vm_op_tlb_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vm_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vm_op_tlb_flush. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to invalidate </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vm_op_tlb_flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affbc0fc25a4e4d668836612a2b291973" name="affbc0fc25a4e4d668836612a2b291973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbc0fc25a4e4d668836612a2b291973">&#9670;&nbsp;</a></span>bf_vm_op_tlb_flush_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_tlb_flush_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vm_op_tlb_flush has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vm_op_tlb_flush has been called </dd></dl>

</div>
</div>
<a id="a3775e0ff37788114cb5f25d2688a5df8" name="a3775e0ff37788114cb5f25d2688a5df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3775e0ff37788114cb5f25d2688a5df8">&#9670;&nbsp;</a></span>bf_vp_op_create_vp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vp_op_create_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VP given the IDs of the VM and PP the VP will be assigned to. Upon success, this syscall returns the ID of the newly created VP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to assign the newly created VP to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="af3bb08e13734593fc07cd9091ab418f1" name="af3bb08e13734593fc07cd9091ab418f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bb08e13734593fc07cd9091ab418f1">&#9670;&nbsp;</a></span>set_bf_vp_op_create_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vp_op_create_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vp_op_create_vp. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to assign the newly created VP to </td></tr>
    <tr><td class="paramname">vpid</td><td>the ID to return when executing set_bf_vp_op_create_vp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d35f9aab7c98ea02ffb099d7d1671bc" name="a5d35f9aab7c98ea02ffb099d7d1671bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d35f9aab7c98ea02ffb099d7d1671bc">&#9670;&nbsp;</a></span>bf_vp_op_create_vp_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vp_op_create_vp_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vp_op_create_vp has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vp_op_create_vp has been called </dd></dl>

</div>
</div>
<a id="a21ebebe1d613b466425d54f29ef8f69a" name="a21ebebe1d613b466425d54f29ef8f69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ebebe1d613b466425d54f29ef8f69a">&#9670;&nbsp;</a></span>bf_vp_op_destroy_vp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vp_op_destroy_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VP given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a443e97dfd8c77389c41941a2f6a2c2ce" name="a443e97dfd8c77389c41941a2f6a2c2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443e97dfd8c77389c41941a2f6a2c2ce">&#9670;&nbsp;</a></span>set_bf_vp_op_destroy_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vp_op_destroy_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vp_op_destroy_vp. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP to destroy </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vp_op_destroy_vp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf4afa842ee1627785d9271ca79ddf19" name="abf4afa842ee1627785d9271ca79ddf19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4afa842ee1627785d9271ca79ddf19">&#9670;&nbsp;</a></span>bf_vp_op_destroy_vp_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vp_op_destroy_vp_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vp_op_destroy_vp has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vp_op_destroy_vp has been called </dd></dl>

</div>
</div>
<a id="a00703a6f47968414c287ab76cc7e97c6" name="a00703a6f47968414c287ab76cc7e97c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00703a6f47968414c287ab76cc7e97c6">&#9670;&nbsp;</a></span>bf_vs_op_create_vs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_create_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VS and return it's ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP to assign the newly created VS to </td></tr>
    <tr><td class="paramname">ppid</td><td>The resulting VSID of the newly created VS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ad86b3d6b8615f30a0b3ba71f32f84be1" name="ad86b3d6b8615f30a0b3ba71f32f84be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86b3d6b8615f30a0b3ba71f32f84be1">&#9670;&nbsp;</a></span>set_bf_vs_op_create_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_create_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vspid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_create_vs. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP to assign the newly created VS to </td></tr>
    <tr><td class="paramname">ppid</td><td>The resulting VSID of the newly created VS </td></tr>
    <tr><td class="paramname">vspid</td><td>the ID to return when executing set_bf_vs_op_create_vs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbb0098e8b370eb5db4fc07e095da339" name="abbb0098e8b370eb5db4fc07e095da339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb0098e8b370eb5db4fc07e095da339">&#9670;&nbsp;</a></span>bf_vs_op_create_vs_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_create_vs_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_create_vs has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_create_vs has been called </dd></dl>

</div>
</div>
<a id="a724a2594d24a643e29e10f2022f4cd76" name="a724a2594d24a643e29e10f2022f4cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724a2594d24a643e29e10f2022f4cd76">&#9670;&nbsp;</a></span>bf_vs_op_destroy_vs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_destroy_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VS given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ae8ca0fa46efc07071365bc469b710c34" name="ae8ca0fa46efc07071365bc469b710c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ca0fa46efc07071365bc469b710c34">&#9670;&nbsp;</a></span>set_bf_vs_op_destroy_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_destroy_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_destroy_vs. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to destroy </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_destroy_vs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab348a6eb128b388bc15d6c100942c2ec" name="ab348a6eb128b388bc15d6c100942c2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab348a6eb128b388bc15d6c100942c2ec">&#9670;&nbsp;</a></span>bf_vs_op_destroy_vs_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_destroy_vs_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_destroy_vs has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_destroy_vs has been called </dd></dl>

</div>
</div>
<a id="a7f94f5da4b7fd47aef467ff09324c8a2" name="a7f94f5da4b7fd47aef467ff09324c8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f94f5da4b7fd47aef467ff09324c8a2">&#9670;&nbsp;</a></span>bf_vs_op_init_as_root() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_init_as_root </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to initialize a VS using the root VP state provided by the loader using the current PPID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to initialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ab6146c2c82fc4c06bb05ec42e8b59a7d" name="ab6146c2c82fc4c06bb05ec42e8b59a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6146c2c82fc4c06bb05ec42e8b59a7d">&#9670;&nbsp;</a></span>set_bf_vs_op_init_as_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_init_as_root </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_init_as_root. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to initialize </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_init_as_root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa52adc0c0b915b6ebccefa3b42a22a37" name="aa52adc0c0b915b6ebccefa3b42a22a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52adc0c0b915b6ebccefa3b42a22a37">&#9670;&nbsp;</a></span>bf_vs_op_init_as_root_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_init_as_root_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_init_as_root has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_init_as_root has been called </dd></dl>

</div>
</div>
<a id="a77282b8dd8dd3d06830811cfdde4b8e6" name="a77282b8dd8dd3d06830811cfdde4b8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77282b8dd8dd3d06830811cfdde4b8e6">&#9670;&nbsp;</a></span>bf_vs_op_read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_read </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a CPU register from the VS given a bf_reg_t. Note that the bf_reg_t is architecture specific. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to read from </td></tr>
    <tr><td class="paramname">reg</td><td>A bf_reg_t defining which register to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value read, or bsl::safe_u64::failure() on failure. </dd></dl>

</div>
</div>
<a id="a951d7685c2876681a2a0656cd3141c76" name="a951d7685c2876681a2a0656cd3141c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951d7685c2876681a2a0656cd3141c76">&#9670;&nbsp;</a></span>set_bf_vs_op_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_read </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_read. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to read from </td></tr>
    <tr><td class="paramname">reg</td><td>A bf_reg_t defining which register to read </td></tr>
    <tr><td class="paramname">value</td><td>the value to return when executing bf_vs_op_read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a908cbed8d315f98cf49252b8e3446fcd" name="a908cbed8d315f98cf49252b8e3446fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908cbed8d315f98cf49252b8e3446fcd">&#9670;&nbsp;</a></span>bf_vs_op_write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_write </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to a CPU register in the VS given a bf_reg_t and the value to write. Note that the bf_reg_t is architecture specific. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to write to </td></tr>
    <tr><td class="paramname">reg</td><td>A bf_reg_t defining which register to write to </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the requested register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ab792ae6598aafddbe0b3c6d0e6d90555" name="ab792ae6598aafddbe0b3c6d0e6d90555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab792ae6598aafddbe0b3c6d0e6d90555">&#9670;&nbsp;</a></span>set_bf_vs_op_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_write </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_write. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to write to </td></tr>
    <tr><td class="paramname">reg</td><td>A bf_reg_t defining which register to write to </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the requested field </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee24eac8700266625f022720d42023de" name="aee24eac8700266625f022720d42023de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee24eac8700266625f022720d42023de">&#9670;&nbsp;</a></span>bf_vs_op_write_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_write_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_write has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_write has been called </dd></dl>

</div>
</div>
<a id="aa31edaef67e15222b8192fd07a079a66" name="aa31edaef67e15222b8192fd07a079a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31edaef67e15222b8192fd07a079a66">&#9670;&nbsp;</a></span>bf_vs_op_run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_run </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a5700047425a90449af8c087c745aaf72" name="a5700047425a90449af8c087c745aaf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5700047425a90449af8c087c745aaf72">&#9670;&nbsp;</a></span>set_bf_vs_op_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_run </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_run. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30fbe374773e35550ff0b4c21b183c5e" name="a30fbe374773e35550ff0b4c21b183c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fbe374773e35550ff0b4c21b183c5e">&#9670;&nbsp;</a></span>bf_vs_op_run_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_run_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_run has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_run has been called </dd></dl>

</div>
</div>
<a id="a5e2a36f6f20561a82c61cc3b1252db25" name="a5e2a36f6f20561a82c61cc3b1252db25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2a36f6f20561a82c61cc3b1252db25">&#9670;&nbsp;</a></span>bf_vs_op_run_current() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_run_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_vs_op_run_current tells the microkernel to execute the currently active VS, VP and VM. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a5be296adfc8fc6e74faacb70164ca2f1" name="a5be296adfc8fc6e74faacb70164ca2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be296adfc8fc6e74faacb70164ca2f1">&#9670;&nbsp;</a></span>set_bf_vs_op_run_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_run_current </td>
          <td>(</td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_run_current. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_run_current </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d78f650e63d7c43752934bd704138bf" name="a3d78f650e63d7c43752934bd704138bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d78f650e63d7c43752934bd704138bf">&#9670;&nbsp;</a></span>bf_vs_op_run_current_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_run_current_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_run_current has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_run_current has been called </dd></dl>

</div>
</div>
<a id="a315ebee647ee24661c9b93b65f933d64" name="a315ebee647ee24661c9b93b65f933d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315ebee647ee24661c9b93b65f933d64">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_run </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to advance the IP for </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to advance the IP for </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to advance the IP for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="acd11cfb9f5a9745ee414f58889e3bd69" name="acd11cfb9f5a9745ee414f58889e3bd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd11cfb9f5a9745ee414f58889e3bd69">&#9670;&nbsp;</a></span>set_bf_vs_op_advance_ip_and_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_advance_ip_and_run </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_advance_ip_and_run. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to advance the IP for </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to advance the IP for </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to advance the IP for </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_advance_ip_and_run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a445bfd2336c6ebd5bc75e7629463ed1d" name="a445bfd2336c6ebd5bc75e7629463ed1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445bfd2336c6ebd5bc75e7629463ed1d">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_run_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_advance_ip_and_run has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_advance_ip_and_run has been called </dd></dl>

</div>
</div>
<a id="af7bf62e706e5ce6bc770c6374ec89ec5" name="af7bf62e706e5ce6bc770c6374ec89ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bf62e706e5ce6bc770c6374ec89ec5">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run_current() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_run_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aa42201183d277c95c728fc976da6d037" name="aa42201183d277c95c728fc976da6d037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42201183d277c95c728fc976da6d037">&#9670;&nbsp;</a></span>set_bf_vs_op_advance_ip_and_run_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_advance_ip_and_run_current </td>
          <td>(</td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_advance_ip_and_run_current. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_advance_ip_and_run_current </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe063eba2f730be5bfa9f72374571469" name="afe063eba2f730be5bfa9f72374571469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe063eba2f730be5bfa9f72374571469">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run_current_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_run_current_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_advance_ip_and_run_current has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_advance_ip_and_run_current has been called </dd></dl>

</div>
</div>
<a id="a571436e51276a3e613246df1a45d5a1b" name="a571436e51276a3e613246df1a45d5a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571436e51276a3e613246df1a45d5a1b">&#9670;&nbsp;</a></span>bf_vs_op_promote() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_promote </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to promote the requested VS. This will stop the hypervisor complete on the physical processor that this syscall is executed on and replace it's state with the state in the VS. Note that this syscall only returns on error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to promote </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ae580f8f0e2624f130fb0a7a0f429a028" name="ae580f8f0e2624f130fb0a7a0f429a028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae580f8f0e2624f130fb0a7a0f429a028">&#9670;&nbsp;</a></span>set_bf_vs_op_promote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_promote </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_promote. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to promote </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_promote </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac5d98a2ce315b200225c9f6fb2778ea" name="aac5d98a2ce315b200225c9f6fb2778ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5d98a2ce315b200225c9f6fb2778ea">&#9670;&nbsp;</a></span>bf_vs_op_promote_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_promote_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_promote has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_promote has been called </dd></dl>

</div>
</div>
<a id="ad92bed718a8641bf68bd5af9078b6fc0" name="ad92bed718a8641bf68bd5af9078b6fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92bed718a8641bf68bd5af9078b6fc0">&#9670;&nbsp;</a></span>bf_vs_op_clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_clear </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_vs_op_clear tells the microkernel to clear the VS's hardware cache, if one exists. How this is used depends entirely on the hardware and is associated with AMD's VMCB Clean Bits, and Intel's VMClear instruction. See the associated documentation for more details. On AMD, this ABI clears the entire VMCB. For more fine grained control, use the write ABIs to manually modify the VMCB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ac8ce4bd639f19b29fdef4b8d866ac68d" name="ac8ce4bd639f19b29fdef4b8d866ac68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ce4bd639f19b29fdef4b8d866ac68d">&#9670;&nbsp;</a></span>set_bf_vs_op_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_clear </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_clear. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to clear </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa55acfe49e16ee0ceebaad4f9b55819a" name="aa55acfe49e16ee0ceebaad4f9b55819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55acfe49e16ee0ceebaad4f9b55819a">&#9670;&nbsp;</a></span>bf_vs_op_clear_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_clear_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_clear has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_clear has been called </dd></dl>

</div>
</div>
<a id="abec08e8cd3cd1b5649d61e7077e1a151" name="abec08e8cd3cd1b5649d61e7077e1a151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec08e8cd3cd1b5649d61e7077e1a151">&#9670;&nbsp;</a></span>bf_vs_op_migrate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_migrate </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to migrate </td></tr>
    <tr><td class="paramname">ppid</td><td>The ID of the PP to migrate the VS to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ad0cf390cc8749c1e50dfa9b60bf8909b" name="ad0cf390cc8749c1e50dfa9b60bf8909b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cf390cc8749c1e50dfa9b60bf8909b">&#9670;&nbsp;</a></span>set_bf_vs_op_migrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_migrate </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_migrate. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to migrate </td></tr>
    <tr><td class="paramname">ppid</td><td>The ID of the PP to migrate the VS to </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_migrate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa315f911f7b1b4cc49df8de0baef9df7" name="aa315f911f7b1b4cc49df8de0baef9df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa315f911f7b1b4cc49df8de0baef9df7">&#9670;&nbsp;</a></span>bf_vs_op_migrate_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_migrate_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_migrate has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_migrate has been called </dd></dl>

</div>
</div>
<a id="a3e33ac1f5b3e2947355d38cf76363bdf" name="a3e33ac1f5b3e2947355d38cf76363bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e33ac1f5b3e2947355d38cf76363bdf">&#9670;&nbsp;</a></span>bf_vs_op_set_active() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_set_active </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a2f42864d9def5c50ac1856078b88458f" name="a2f42864d9def5c50ac1856078b88458f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f42864d9def5c50ac1856078b88458f">&#9670;&nbsp;</a></span>set_bf_vs_op_set_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_set_active </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_set_active. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_set_active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac27ce6b2323a772ae232d085b0e853de" name="ac27ce6b2323a772ae232d085b0e853de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27ce6b2323a772ae232d085b0e853de">&#9670;&nbsp;</a></span>bf_vs_op_set_active_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_set_active_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_set_active has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_set_active has been called </dd></dl>

</div>
</div>
<a id="a48188bdfdaa4e525e0910a0f89f5f409" name="a48188bdfdaa4e525e0910a0f89f5f409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48188bdfdaa4e525e0910a0f89f5f409">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_set_active() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_set_active </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a0726bb1b7718dee39843424c79a6080c" name="a0726bb1b7718dee39843424c79a6080c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0726bb1b7718dee39843424c79a6080c">&#9670;&nbsp;</a></span>set_bf_vs_op_advance_ip_and_set_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_advance_ip_and_set_active </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_advance_ip_and_set_active. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_advance_ip_and_set_active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad59d64e9e93df0541d7dbc5cdf6dd60d" name="ad59d64e9e93df0541d7dbc5cdf6dd60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59d64e9e93df0541d7dbc5cdf6dd60d">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_set_active_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_set_active_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_advance_ip_and_set_active has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_advance_ip_and_set_active has been called </dd></dl>

</div>
</div>
<a id="a4fa7fcb699cf09b3fc280c0ec1ea7fa1" name="a4fa7fcb699cf09b3fc280c0ec1ea7fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">&#9670;&nbsp;</a></span>bf_vs_op_tlb_flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>gla</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the ID of a VS, invalidates a TLB entry for a given GLA on the PP that this is executed on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to invalidate </td></tr>
    <tr><td class="paramname">gla</td><td>The GLA to invalidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a1cfce59ab025927fae2a7afe9416c105" name="a1cfce59ab025927fae2a7afe9416c105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfce59ab025927fae2a7afe9416c105">&#9670;&nbsp;</a></span>set_bf_vs_op_tlb_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_vs_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>gla</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_vs_op_tlb_flush. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to invalidate </td></tr>
    <tr><td class="paramname">gla</td><td>The GLA to invalidate </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_vs_op_tlb_flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19a60fafd1fd1909185fe8c251ae32fe" name="a19a60fafd1fd1909185fe8c251ae32fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a60fafd1fd1909185fe8c251ae32fe">&#9670;&nbsp;</a></span>bf_vs_op_tlb_flush_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_tlb_flush_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_vs_op_tlb_flush has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_vs_op_tlb_flush has been called </dd></dl>

</div>
</div>
<a id="aed00f6cfb54e47de19b8e30c48dc399f" name="aed00f6cfb54e47de19b8e30c48dc399f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed00f6cfb54e47de19b8e30c48dc399f">&#9670;&nbsp;</a></span>bf_intrinsic_op_rdmsr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_intrinsic_op_rdmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>msr</em></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an MSR directly from the CPU given the address of the MSR to read. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be read, and which MSRs that can be read is up to the microkernel's internal policy as well as which architecture the hypervisor is running on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The address of the MSR to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value read, or bsl::safe_u64::failure() on failure. </dd></dl>

</div>
</div>
<a id="a391c23e27c18d7f00731040592fdc6b6" name="a391c23e27c18d7f00731040592fdc6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c23e27c18d7f00731040592fdc6b6">&#9670;&nbsp;</a></span>set_bf_intrinsic_op_rdmsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_intrinsic_op_rdmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>msr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_intrinsic_op_rdmsr. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The address of the MSR to read </td></tr>
    <tr><td class="paramname">val</td><td>the value to return when executing bf_intrinsic_op_rdmsr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad06c04c9e4ec995aff660b55c08c1a69" name="ad06c04c9e4ec995aff660b55c08c1a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c04c9e4ec995aff660b55c08c1a69">&#9670;&nbsp;</a></span>bf_intrinsic_op_wrmsr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_intrinsic_op_wrmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>msr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to an MSR directly from the CPU given the address of the MSR to write as well as the value to write. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be written to, and which MSRs that can be written to is up to the microkernel's internal policy as well as which architecture the hypervisor is running on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The address of the MSR to write to </td></tr>
    <tr><td class="paramname">val</td><td>The value to write to the requested MSR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a759d155d1dd633b50b4e2e80bc08d0d8" name="a759d155d1dd633b50b4e2e80bc08d0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759d155d1dd633b50b4e2e80bc08d0d8">&#9670;&nbsp;</a></span>set_bf_intrinsic_op_wrmsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_intrinsic_op_wrmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>msr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_intrinsic_op_wrmsr. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The address of the MSR to write to </td></tr>
    <tr><td class="paramname">val</td><td>The value to write to the requested MSR </td></tr>
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_intrinsic_op_wrmsr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a260e1694d4d8bb0029e04b6a79c01e5b" name="a260e1694d4d8bb0029e04b6a79c01e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260e1694d4d8bb0029e04b6a79c01e5b">&#9670;&nbsp;</a></span>bf_intrinsic_op_wrmsr_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_intrinsic_op_wrmsr_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_intrinsic_op_wrmsr has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_intrinsic_op_wrmsr has been called </dd></dl>

</div>
</div>
<a id="a2787d14fcb93d6c3f423a9f55d691149" name="a2787d14fcb93d6c3f423a9f55d691149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2787d14fcb93d6c3f423a9f55d691149">&#9670;&nbsp;</a></span>bf_mem_op_alloc_page() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_page </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 &amp;&#160;</td>
          <td class="paramname"><em>mut_phys</em></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_phys</td><td>The mut_physical address of the resulting page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="af410bb63b75855bafb20c0a1ba21bf97" name="af410bb63b75855bafb20c0a1ba21bf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af410bb63b75855bafb20c0a1ba21bf97">&#9670;&nbsp;</a></span>bf_mem_op_alloc_page() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="af2c8b96b2846acc247c9e775eb6f61ed" name="af2c8b96b2846acc247c9e775eb6f61ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c8b96b2846acc247c9e775eb6f61ed">&#9670;&nbsp;</a></span>set_bf_mem_op_alloc_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_mem_op_alloc_page </td>
          <td>(</td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_mem_op_alloc_page. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_mem_op_alloc_page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af67e410f59fda175f526220ca6eac966" name="af67e410f59fda175f526220ca6eac966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67e410f59fda175f526220ca6eac966">&#9670;&nbsp;</a></span>bf_mem_op_alloc_page_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_page_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_mem_op_alloc_page has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_mem_op_alloc_page has been called </dd></dl>

</div>
</div>
<a id="a7c5125fd5cdcd5a02a3aeb73904c8a04" name="a7c5125fd5cdcd5a02a3aeb73904c8a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5125fd5cdcd5a02a3aeb73904c8a04">&#9670;&nbsp;</a></span>bf_mem_op_alloc_huge() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_huge </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 &amp;&#160;</td>
          <td class="paramname"><em>mut_phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following: </p>
<ul>
<li>The total memory available to allocate from this pool is extremely limited. This should only be used when absolutely needed, and extensions should not expect more than 1 MB (might be less) of total memory available.</li>
<li>Memory allocated from the huge pool might be allocated using different schemes. For example, the microkernel might allocate in increments of a page, or it might use a buddy allocator that would allocate in multiples of 2. If the allocation size doesn't match the algorithm, internal fragmentation could occur, further limiting the total number of allocations this pool can support.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to allocate </td></tr>
    <tr><td class="paramname">mut_phys</td><td>The physical address of the resulting memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>
<p >BUG:</p><ul>
<li>Clang 10 has a bug that does not allow us to allocate memory of any size. If we attempt to do this, it will segfault the the compiler. This is not an issue with Clang 11+, so the bug has already been addressed. The problem is, we need to be able to support Clang 10 as that is what comes default with Ubuntu 20.04.</li>
<li>To fix this, we hardcode the allocation in this mock to 16k. Most of the huge page allocations that will be needed are limited to 4k (or at least should be as the huge page pool is very limited in size and should not be used for much more than that. Anything larger, and a different, extension specific allocator should be used instead.</li>
<li>If this proves to be an issue, a CMake constant could be added to configure this.</li>
</ul>

</div>
</div>
<a id="adeca2bbb88777ffb85913e26d8e42ee7" name="adeca2bbb88777ffb85913e26d8e42ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeca2bbb88777ffb85913e26d8e42ee7">&#9670;&nbsp;</a></span>bf_mem_op_alloc_huge() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_huge </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following: </p>
<ul>
<li>The total memory available to allocate from this pool is extremely limited. This should only be used when absolutely needed, and extensions should not expect more than 1 MB (might be less) of total memory available.</li>
<li>Memory allocated from the huge pool might be allocated using different schemes. For example, the microkernel might allocate in increments of a page, or it might use a buddy allocator that would allocate in multiples of 2. If the allocation size doesn't match the algorithm, internal fragmentation could occur, further limiting the total number of allocations this pool can support.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="a772497d77514bc12dd4c470edecbba2c" name="a772497d77514bc12dd4c470edecbba2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772497d77514bc12dd4c470edecbba2c">&#9670;&nbsp;</a></span>set_bf_mem_op_alloc_huge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_syscall_t::set_bf_mem_op_alloc_huge </td>
          <td>(</td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>errc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the return value of bf_mem_op_alloc_huge. (unit testing only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errc</td><td>the bsl::errc_type to return when executing bf_mem_op_alloc_huge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa20961a2f66ce12b6266e5bb1f95273a" name="aa20961a2f66ce12b6266e5bb1f95273a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20961a2f66ce12b6266e5bb1f95273a">&#9670;&nbsp;</a></span>bf_mem_op_alloc_huge_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_huge_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of times bf_mem_op_alloc_huge has been called (unit testing only) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of times bf_mem_op_alloc_huge has been called </dd></dl>

</div>
</div>
<a id="a581d962f74017a660a78e9ebc4522011" name="a581d962f74017a660a78e9ebc4522011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581d962f74017a660a78e9ebc4522011">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::initialize </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a9cd54917e15d0b4f28199ec88380b8f0">bf_callback_handler_bootstrap_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_bootstrap_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a6e2b46c2a0bee5dacb4906558723b00c">bf_callback_handler_vmexit_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_vmexit_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a0b901eaa1c2f3424d67879f2d5a593c8">bf_callback_handler_fail_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_fail_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by verifying version compatibility, opening a handle and registering the provided callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>the version provided to the extension by the microkernel. If this API does not support the ABI versions that the microkernel supports, this function will fail. </td></tr>
    <tr><td class="paramname">pmut_bootstrap_handler</td><td>the bootstrap handler to register </td></tr>
    <tr><td class="paramname">pmut_vmexit_handler</td><td>the vmexit handler to register </td></tr>
    <tr><td class="paramname">pmut_fail_handler</td><td>the fail handler to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a2ced8951c280ceb9cf26ad5a477aa2cf" name="a2ced8951c280ceb9cf26ad5a477aa2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ced8951c280ceb9cf26ad5a477aa2cf">&#9670;&nbsp;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the handle that is used for syscalls. If this class has not been initialized, a default (likely 0) handle is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the handle that is used for syscalls. If this class has not been initialized, a default (likely 0) handle is returned. </dd></dl>

</div>
</div>
<a id="ad32644c527c752a63686c5710ebe7bae" name="ad32644c527c752a63686c5710ebe7bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32644c527c752a63686c5710ebe7bae">&#9670;&nbsp;</a></span>bf_tls_rax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rax. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rax </dd></dl>

</div>
</div>
<a id="a2e9acd4d82aee2bc405b11306f889f58" name="a2e9acd4d82aee2bc405b11306f889f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9acd4d82aee2bc405b11306f889f58">&#9670;&nbsp;</a></span>bf_tls_set_rax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rax </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rax to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad33f1320f9301da364b3080b6710e8d6" name="ad33f1320f9301da364b3080b6710e8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33f1320f9301da364b3080b6710e8d6">&#9670;&nbsp;</a></span>bf_tls_rbx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rbx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rbx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rbx </dd></dl>

</div>
</div>
<a id="a9790de8d7d91a94793e09bd53f03377b" name="a9790de8d7d91a94793e09bd53f03377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9790de8d7d91a94793e09bd53f03377b">&#9670;&nbsp;</a></span>bf_tls_set_rbx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rbx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rbx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rbx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b0b8367bfa55a5566b2edb20db154b" name="a70b0b8367bfa55a5566b2edb20db154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b0b8367bfa55a5566b2edb20db154b">&#9670;&nbsp;</a></span>bf_tls_rcx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rcx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rcx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rcx </dd></dl>

</div>
</div>
<a id="a585e5599e55b11896e5e283b14cebfa5" name="a585e5599e55b11896e5e283b14cebfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585e5599e55b11896e5e283b14cebfa5">&#9670;&nbsp;</a></span>bf_tls_set_rcx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rcx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rcx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rcx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2e407d78c0442751cc69c0fe659225a" name="ad2e407d78c0442751cc69c0fe659225a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e407d78c0442751cc69c0fe659225a">&#9670;&nbsp;</a></span>bf_tls_rdx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rdx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rdx </dd></dl>

</div>
</div>
<a id="a3050ded79cc7955b48db01bfa29cc91b" name="a3050ded79cc7955b48db01bfa29cc91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3050ded79cc7955b48db01bfa29cc91b">&#9670;&nbsp;</a></span>bf_tls_set_rdx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rdx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rdx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rdx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a060d2eed4081b99da45faa59307b0ad7" name="a060d2eed4081b99da45faa59307b0ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060d2eed4081b99da45faa59307b0ad7">&#9670;&nbsp;</a></span>bf_tls_rbp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rbp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rbp. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rbp </dd></dl>

</div>
</div>
<a id="aa3b496c5edf092ad96dd9d80d8682d63" name="aa3b496c5edf092ad96dd9d80d8682d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b496c5edf092ad96dd9d80d8682d63">&#9670;&nbsp;</a></span>bf_tls_set_rbp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rbp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rbp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rbp to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3212ae58f5235454b0ff855c57a3ad9" name="ac3212ae58f5235454b0ff855c57a3ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3212ae58f5235454b0ff855c57a3ad9">&#9670;&nbsp;</a></span>bf_tls_rsi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rsi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rsi. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rsi </dd></dl>

</div>
</div>
<a id="ac9e019e91c72a6af1092b25b27c6a876" name="ac9e019e91c72a6af1092b25b27c6a876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e019e91c72a6af1092b25b27c6a876">&#9670;&nbsp;</a></span>bf_tls_set_rsi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rsi </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rsi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rsi to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64d0134ccc7f52edc6ad09935a0cd9e6" name="a64d0134ccc7f52edc6ad09935a0cd9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d0134ccc7f52edc6ad09935a0cd9e6">&#9670;&nbsp;</a></span>bf_tls_rdi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rdi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rdi. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rdi </dd></dl>

</div>
</div>
<a id="ab094cde9f7e44801007856e7dcda6afc" name="ab094cde9f7e44801007856e7dcda6afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab094cde9f7e44801007856e7dcda6afc">&#9670;&nbsp;</a></span>bf_tls_set_rdi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rdi </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rdi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rdi to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53ba6aebd69627e0500a16c1b4616504" name="a53ba6aebd69627e0500a16c1b4616504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ba6aebd69627e0500a16c1b4616504">&#9670;&nbsp;</a></span>bf_tls_r8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r8. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r8 </dd></dl>

</div>
</div>
<a id="a7864bf76ef53e59efd62dc11996736f0" name="a7864bf76ef53e59efd62dc11996736f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7864bf76ef53e59efd62dc11996736f0">&#9670;&nbsp;</a></span>bf_tls_set_r8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r8 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r8 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9355fe923871138ee084c8b112c37dfa" name="a9355fe923871138ee084c8b112c37dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9355fe923871138ee084c8b112c37dfa">&#9670;&nbsp;</a></span>bf_tls_r9() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r9 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r9. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r9 </dd></dl>

</div>
</div>
<a id="aa8db39b8709a07100619fd76845f3a9d" name="aa8db39b8709a07100619fd76845f3a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8db39b8709a07100619fd76845f3a9d">&#9670;&nbsp;</a></span>bf_tls_set_r9() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r9 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r9. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r9 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a41e07266ecdffb89f87f7d7af52b33" name="a5a41e07266ecdffb89f87f7d7af52b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a41e07266ecdffb89f87f7d7af52b33">&#9670;&nbsp;</a></span>bf_tls_r10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r10. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r10 </dd></dl>

</div>
</div>
<a id="a32cb3d5ba6eac1b7f615e9ce3247d860" name="a32cb3d5ba6eac1b7f615e9ce3247d860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cb3d5ba6eac1b7f615e9ce3247d860">&#9670;&nbsp;</a></span>bf_tls_set_r10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r10 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r10 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62d93a8c9b4eddac11aa052d545dafbe" name="a62d93a8c9b4eddac11aa052d545dafbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d93a8c9b4eddac11aa052d545dafbe">&#9670;&nbsp;</a></span>bf_tls_r11() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r11 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r11. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r11 </dd></dl>

</div>
</div>
<a id="ad7e6b33270f41f4a5cd4afb64c84d01a" name="ad7e6b33270f41f4a5cd4afb64c84d01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e6b33270f41f4a5cd4afb64c84d01a">&#9670;&nbsp;</a></span>bf_tls_set_r11() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r11 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r11. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r11 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a441e9aaeb8ccaf9cb4ad24308ac2fff9" name="a441e9aaeb8ccaf9cb4ad24308ac2fff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441e9aaeb8ccaf9cb4ad24308ac2fff9">&#9670;&nbsp;</a></span>bf_tls_r12() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r12 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r12. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r12 </dd></dl>

</div>
</div>
<a id="af1a44a7a827210f302593813cebf1f64" name="af1a44a7a827210f302593813cebf1f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a44a7a827210f302593813cebf1f64">&#9670;&nbsp;</a></span>bf_tls_set_r12() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r12 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r12. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r12 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26e18adc4f4b1ee9213cd6699d32abd2" name="a26e18adc4f4b1ee9213cd6699d32abd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e18adc4f4b1ee9213cd6699d32abd2">&#9670;&nbsp;</a></span>bf_tls_r13() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r13 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r13. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r13 </dd></dl>

</div>
</div>
<a id="a3a2f5508b5b544c8973b4e5433a7ab19" name="a3a2f5508b5b544c8973b4e5433a7ab19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2f5508b5b544c8973b4e5433a7ab19">&#9670;&nbsp;</a></span>bf_tls_set_r13() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r13 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r13. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r13 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b4f056e1a81f0e8319bd8383772e9e4" name="a9b4f056e1a81f0e8319bd8383772e9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4f056e1a81f0e8319bd8383772e9e4">&#9670;&nbsp;</a></span>bf_tls_r14() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r14 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r14. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r14 </dd></dl>

</div>
</div>
<a id="a7164a1d32fee2996b92994acd7859732" name="a7164a1d32fee2996b92994acd7859732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7164a1d32fee2996b92994acd7859732">&#9670;&nbsp;</a></span>bf_tls_set_r14() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r14 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r14. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r14 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed597cc058c0897756a63a097976a9d3" name="aed597cc058c0897756a63a097976a9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed597cc058c0897756a63a097976a9d3">&#9670;&nbsp;</a></span>bf_tls_r15() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r15 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r15. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r15 </dd></dl>

</div>
</div>
<a id="a8f3123659a43b876378c07d97877b735" name="a8f3123659a43b876378c07d97877b735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3123659a43b876378c07d97877b735">&#9670;&nbsp;</a></span>bf_tls_set_r15() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r15 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r15. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r15 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92ad760118cbd1ae66a60c335253468c" name="a92ad760118cbd1ae66a60c335253468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ad760118cbd1ae66a60c335253468c">&#9670;&nbsp;</a></span>bf_tls_extid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_extid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.extid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.extid </dd></dl>

</div>
</div>
<a id="afb0540fcde200282cd1296de26707a70" name="afb0540fcde200282cd1296de26707a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0540fcde200282cd1296de26707a70">&#9670;&nbsp;</a></span>bf_tls_vmid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_vmid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vmid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vmid </dd></dl>

</div>
</div>
<a id="a7a9a58dde8c3a45c99acfd674230e072" name="a7a9a58dde8c3a45c99acfd674230e072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9a58dde8c3a45c99acfd674230e072">&#9670;&nbsp;</a></span>bf_tls_vpid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_vpid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vpid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vpid </dd></dl>

</div>
</div>
<a id="aa35e5b74544f6bd3d312cac596843ce8" name="aa35e5b74544f6bd3d312cac596843ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35e5b74544f6bd3d312cac596843ce8">&#9670;&nbsp;</a></span>bf_tls_vsid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_vsid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vsid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vsid </dd></dl>

</div>
</div>
<a id="a7fceb107132749c977a8c651077ad3f8" name="a7fceb107132749c977a8c651077ad3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fceb107132749c977a8c651077ad3f8">&#9670;&nbsp;</a></span>bf_tls_ppid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_ppid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.ppid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.ppid </dd></dl>

</div>
</div>
<a id="ade5737ec6b2265cddddd9ed602af1ab6" name="ade5737ec6b2265cddddd9ed602af1ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5737ec6b2265cddddd9ed602af1ab6">&#9670;&nbsp;</a></span>bf_tls_online_pps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_online_pps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.online_pps. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.online_pps </dd></dl>

</div>
</div>
<a id="a40c64d0f72191a89ce45489d25a222ac" name="a40c64d0f72191a89ce45489d25a222ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c64d0f72191a89ce45489d25a222ac">&#9670;&nbsp;</a></span>is_the_active_vm_the_root_vm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_the_active_vm_the_root_vm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the active VM is the root VM. Returns false otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the active VM is the root VM. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a70af417fbf6a855ca587d82d018f457d" name="a70af417fbf6a855ca587d82d018f457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70af417fbf6a855ca587d82d018f457d">&#9670;&nbsp;</a></span>is_vm_the_root_vm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_vm_the_root_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VMID is the ID of the root VM. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>the ID of the VM to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VMID is the ID of the root VM. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a38f765958a06805a1ea5fabfa3333d23" name="a38f765958a06805a1ea5fabfa3333d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f765958a06805a1ea5fabfa3333d23">&#9670;&nbsp;</a></span>is_vp_a_root_vp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_vp_a_root_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>the ID of the VP to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid(). </dd></dl>

</div>
</div>
<a id="a9d062e733c278938437d85e8f879eef7" name="a9d062e733c278938437d85e8f879eef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d062e733c278938437d85e8f879eef7">&#9670;&nbsp;</a></span>is_vs_a_root_vs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_vs_a_root_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>the ID of the VS to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid(). </dd></dl>

</div>
</div>
<a id="a88f4c6acc6dcae301b4bd0cca721752d" name="a88f4c6acc6dcae301b4bd0cca721752d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f4c6acc6dcae301b4bd0cca721752d">&#9670;&nbsp;</a></span>bf_vm_op_create_vm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_create_vm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VM and return it's ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the resulting ID, or bsl::safe_u16::failure() on failure. </dd></dl>

</div>
</div>
<a id="aa2fbcaf0f75e1bb38d6b2419c2a0f728" name="aa2fbcaf0f75e1bb38d6b2419c2a0f728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fbcaf0f75e1bb38d6b2419c2a0f728">&#9670;&nbsp;</a></span>bf_vm_op_destroy_vm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_destroy_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VM given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a8dbe512644173318a7542718922e6675" name="a8dbe512644173318a7542718922e6675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbe512644173318a7542718922e6675">&#9670;&nbsp;</a></span>bf_vm_op_map_direct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_map_direct </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to map a physical address into the VM's direct map. This is the same as directly accessing the direct map with the difference being that software can provide a physical address and receive the precalculated virtual address. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to map the physical address to </td></tr>
    <tr><td class="paramname">phys</td><td>The physical address to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the map on success, returns a nullptr on failure. </dd></dl>

</div>
</div>
<a id="a139ae56700242c7faa45cf0dc06ff615" name="a139ae56700242c7faa45cf0dc06ff615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139ae56700242c7faa45cf0dc06ff615">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_unmap_direct </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct_broadcast, this syscall does not flush the TLB on any other PP, meaning this unmap is local to the PP the call is made on. Attempting to unmap a virtual address from the direct map that has been accessed on any other PP other than the PP this syscall is executed on will result in undefined behavior. This syscall is designed to support mapping and then immediately unmapping a physical address on a single PP during a single VMExit. It can also be used to map on a PP and then use unmap on the same PP during multiple VMExits, but special care must be taken to ensure no other PP can access the map, otherwise UB will occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to unmap the virtual address from </td></tr>
    <tr><td class="paramname">ptr</td><td>The virtual address to unmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aaf9e55acd5c6abc88969e4fec072b9bb" name="aaf9e55acd5c6abc88969e4fec072b9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9e55acd5c6abc88969e4fec072b9bb">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct_broadcast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_unmap_direct_broadcast </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct, this syscall performs a broadcast TLB flush which means it can be safely used on all direct mapped addresses. The downside of using this function is that it can be a lot slower than bf_vm_op_unmap_direct, especially on systems with a lot of PPs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to unmap the virtual address from </td></tr>
    <tr><td class="paramname">ptr</td><td>The virtual address to unmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a22bdf9512b2bac2103cd9712f10e0100" name="a22bdf9512b2bac2103cd9712f10e0100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bdf9512b2bac2103cd9712f10e0100">&#9670;&nbsp;</a></span>bf_vm_op_tlb_flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the ID of a VM, invalidates a TLB entry for a given GLA on the PP that this is executed on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to invalidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a3775e0ff37788114cb5f25d2688a5df8" name="a3775e0ff37788114cb5f25d2688a5df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3775e0ff37788114cb5f25d2688a5df8">&#9670;&nbsp;</a></span>bf_vp_op_create_vp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vp_op_create_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VP given the IDs of the VM and PP the VP will be assigned to. Upon success, this syscall returns the ID of the newly created VP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to assign the newly created VP to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the resulting ID, or bsl::safe_u16::failure() on failure. </dd></dl>

</div>
</div>
<a id="a21ebebe1d613b466425d54f29ef8f69a" name="a21ebebe1d613b466425d54f29ef8f69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ebebe1d613b466425d54f29ef8f69a">&#9670;&nbsp;</a></span>bf_vp_op_destroy_vp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vp_op_destroy_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VP given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a00703a6f47968414c287ab76cc7e97c6" name="a00703a6f47968414c287ab76cc7e97c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00703a6f47968414c287ab76cc7e97c6">&#9670;&nbsp;</a></span>bf_vs_op_create_vs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_create_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VS and return it's ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP to assign the newly created VS to </td></tr>
    <tr><td class="paramname">ppid</td><td>The resulting VSID of the newly created VS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the resulting ID, or bsl::safe_u16::failure() on failure. </dd></dl>

</div>
</div>
<a id="a724a2594d24a643e29e10f2022f4cd76" name="a724a2594d24a643e29e10f2022f4cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724a2594d24a643e29e10f2022f4cd76">&#9670;&nbsp;</a></span>bf_vs_op_destroy_vs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_destroy_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VS given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a7f94f5da4b7fd47aef467ff09324c8a2" name="a7f94f5da4b7fd47aef467ff09324c8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f94f5da4b7fd47aef467ff09324c8a2">&#9670;&nbsp;</a></span>bf_vs_op_init_as_root() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_init_as_root </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to initialize a VS using the root VP state provided by the loader using the current PPID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to initialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a77282b8dd8dd3d06830811cfdde4b8e6" name="a77282b8dd8dd3d06830811cfdde4b8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77282b8dd8dd3d06830811cfdde4b8e6">&#9670;&nbsp;</a></span>bf_vs_op_read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_read </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a CPU register from the VS given a bf_reg_t. Note that the bf_reg_t is architecture specific. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to read from </td></tr>
    <tr><td class="paramname">reg</td><td>A bf_reg_t defining which register to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value read, or bsl::safe_u64::failure() on failure. </dd></dl>

</div>
</div>
<a id="a908cbed8d315f98cf49252b8e3446fcd" name="a908cbed8d315f98cf49252b8e3446fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908cbed8d315f98cf49252b8e3446fcd">&#9670;&nbsp;</a></span>bf_vs_op_write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_write </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to a CPU register in the VS given a bf_reg_t and the value to write. Note that the bf_reg_t is architecture specific. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to write to </td></tr>
    <tr><td class="paramname">reg</td><td>A bf_reg_t defining which register to write to </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the requested register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aa31edaef67e15222b8192fd07a079a66" name="aa31edaef67e15222b8192fd07a079a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31edaef67e15222b8192fd07a079a66">&#9670;&nbsp;</a></span>bf_vs_op_run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_run </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a VS given the ID of the VM, VP and VS to execute. The VS must be assigned to the provided VP and the provided VP must be assigned to the provided VM. The VP and VS must not be executing on any other PP, and the VS must be assigned to the PP this syscall is executed on. Upon success, this syscall will not return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a5e2a36f6f20561a82c61cc3b1252db25" name="a5e2a36f6f20561a82c61cc3b1252db25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2a36f6f20561a82c61cc3b1252db25">&#9670;&nbsp;</a></span>bf_vs_op_run_current() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_run_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_vs_op_run_current tells the microkernel to execute the currently active VS, VP and VM. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a315ebee647ee24661c9b93b65f933d64" name="a315ebee647ee24661c9b93b65f933d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315ebee647ee24661c9b93b65f933d64">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_run </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the IP and executes a VS given the ID of the VM, VP and VS to execute. The VS must be assigned to the provided VP and the provided VP must be assigned to the provided VM. The VP and VS must not be executing on any other PP, and the VS must be assigned to the PP this syscall is executed on. Upon success, this syscall will not return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to advance the IP for </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to advance the IP for </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to advance the IP for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="af7bf62e706e5ce6bc770c6374ec89ec5" name="af7bf62e706e5ce6bc770c6374ec89ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bf62e706e5ce6bc770c6374ec89ec5">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run_current() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_run_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_vs_op_advance_ip_and_run_current tells the microkernel to advance the IP of and execute the currently active VS, VP and VM. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a571436e51276a3e613246df1a45d5a1b" name="a571436e51276a3e613246df1a45d5a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571436e51276a3e613246df1a45d5a1b">&#9670;&nbsp;</a></span>bf_vs_op_promote() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_promote </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to promote the requested VS. This will stop the hypervisor complete on the physical processor that this syscall is executed on and replace it's state with the state in the VS. Note that this syscall only returns on error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to promote </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ad92bed718a8641bf68bd5af9078b6fc0" name="ad92bed718a8641bf68bd5af9078b6fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92bed718a8641bf68bd5af9078b6fc0">&#9670;&nbsp;</a></span>bf_vs_op_clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_clear </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_vs_op_clear tells the microkernel to clear the VS's hardware cache, if one exists. How this is used depends entirely on the hardware and is associated with AMD's VMCB Clean Bits, and Intel's VMClear instruction. See the associated documentation for more details. On AMD, this ABI clears the entire VMCB. For more fine grained control, use the write ABIs to manually modify the VMCB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="abec08e8cd3cd1b5649d61e7077e1a151" name="abec08e8cd3cd1b5649d61e7077e1a151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec08e8cd3cd1b5649d61e7077e1a151">&#9670;&nbsp;</a></span>bf_vs_op_migrate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_migrate </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Migrates a VS to the provided PP. The VS must not be active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to migrate </td></tr>
    <tr><td class="paramname">ppid</td><td>The ID of the PP to migrate the VS to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a3e33ac1f5b3e2947355d38cf76363bdf" name="a3e33ac1f5b3e2947355d38cf76363bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e33ac1f5b3e2947355d38cf76363bdf">&#9670;&nbsp;</a></span>bf_vs_op_set_active() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_set_active </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a48188bdfdaa4e525e0910a0f89f5f409" name="a48188bdfdaa4e525e0910a0f89f5f409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48188bdfdaa4e525e0910a0f89f5f409">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_set_active() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_set_active </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a4fa7fcb699cf09b3fc280c0ec1ea7fa1" name="a4fa7fcb699cf09b3fc280c0ec1ea7fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">&#9670;&nbsp;</a></span>bf_vs_op_tlb_flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>gla</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the ID of a VS, invalidates a TLB entry for a given GLA on the PP that this is executed on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to invalidate </td></tr>
    <tr><td class="paramname">gla</td><td>The GLA to invalidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aed00f6cfb54e47de19b8e30c48dc399f" name="aed00f6cfb54e47de19b8e30c48dc399f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed00f6cfb54e47de19b8e30c48dc399f">&#9670;&nbsp;</a></span>bf_intrinsic_op_rdmsr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_intrinsic_op_rdmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>msr</em></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an MSR directly from the CPU given the address of the MSR to read. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be read, and which MSRs that can be read is up to the microkernel's internal policy as well as which architecture the hypervisor is running on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The address of the MSR to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value read, or bsl::safe_u64::failure() on failure. </dd></dl>

</div>
</div>
<a id="ad06c04c9e4ec995aff660b55c08c1a69" name="ad06c04c9e4ec995aff660b55c08c1a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c04c9e4ec995aff660b55c08c1a69">&#9670;&nbsp;</a></span>bf_intrinsic_op_wrmsr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_intrinsic_op_wrmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>msr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to an MSR directly from the CPU given the address of the MSR to write as well as the value to write. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be written to, and which MSRs that can be written to is up to the microkernel's internal policy as well as which architecture the hypervisor is running on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The address of the MSR to write to </td></tr>
    <tr><td class="paramname">val</td><td>The value to write to the requested MSR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a2787d14fcb93d6c3f423a9f55d691149" name="a2787d14fcb93d6c3f423a9f55d691149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2787d14fcb93d6c3f423a9f55d691149">&#9670;&nbsp;</a></span>bf_mem_op_alloc_page() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_page </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 &amp;&#160;</td>
          <td class="paramname"><em>mut_phys</em></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_phys</td><td>The physical address of the resulting page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="af410bb63b75855bafb20c0a1ba21bf97" name="af410bb63b75855bafb20c0a1ba21bf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af410bb63b75855bafb20c0a1ba21bf97">&#9670;&nbsp;</a></span>bf_mem_op_alloc_page() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="a7c5125fd5cdcd5a02a3aeb73904c8a04" name="a7c5125fd5cdcd5a02a3aeb73904c8a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5125fd5cdcd5a02a3aeb73904c8a04">&#9670;&nbsp;</a></span>bf_mem_op_alloc_huge() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_huge </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 &amp;&#160;</td>
          <td class="paramname"><em>mut_phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following: </p>
<ul>
<li>The total memory available to allocate from this pool is extremely limited. This should only be used when absolutely needed, and extensions should not expect more than 1 MB (might be less) of total memory available.</li>
<li>Memory allocated from the huge pool might be allocated using different schemes. For example, the microkernel might allocate in increments of a page, or it might use a buddy allocator that would allocate in multiples of 2. If the allocation size doesn't match the algorithm, internal fragmentation could occur, further limiting the total number of allocations this pool can support.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to allocate </td></tr>
    <tr><td class="paramname">mut_phys</td><td>The physical address of the resulting memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="adeca2bbb88777ffb85913e26d8e42ee7" name="adeca2bbb88777ffb85913e26d8e42ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeca2bbb88777ffb85913e26d8e42ee7">&#9670;&nbsp;</a></span>bf_mem_op_alloc_huge() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_huge </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following: </p>
<ul>
<li>The total memory available to allocate from this pool is extremely limited. This should only be used when absolutely needed, and extensions should not expect more than 1 MB (might be less) of total memory available.</li>
<li>Memory allocated from the huge pool might be allocated using different schemes. For example, the microkernel might allocate in increments of a page, or it might use a buddy allocator that would allocate in multiples of 2. If the allocation size doesn't match the algorithm, internal fragmentation could occur, further limiting the total number of allocations this pool can support.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>syscall/mocks/<a class="el" href="mocks_2bf__syscall__t_8hpp_source.html">bf_syscall_t.hpp</a></li>
<li>syscall/src/<a class="el" href="src_2bf__syscall__t_8hpp_source.html">bf_syscall_t.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesyscall.html">syscall</a></li><li class="navelem"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
