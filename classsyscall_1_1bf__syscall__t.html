<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank Hypervisor: syscall::bf_syscall_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bareflank Hypervisor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsyscall_1_1bf__syscall__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classsyscall_1_1bf__syscall__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">syscall::bf_syscall_t Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs, please see the Microkernel ABI Specification.  
 <a href="classsyscall_1_1bf__syscall__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bf__syscall__t_8hpp_source.html">bf_syscall_t.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a581d962f74017a660a78e9ebc4522011"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a581d962f74017a660a78e9ebc4522011">initialize</a> (bsl::safe_u32 const &amp;version, <a class="el" href="namespacesyscall.html#ade5384db1d6d8a0b23754219e5ab09af">bf_callback_handler_bootstrap_t</a> const pmut_bootstrap_handler, <a class="el" href="namespacesyscall.html#a6e24a9c2a154fcf5ac59d3f0164b567b">bf_callback_handler_vmexit_t</a> const pmut_vmexit_handler, <a class="el" href="namespacesyscall.html#a8d84fbe0f1de9ccdb58661d7850fac82">bf_callback_handler_fail_t</a> const pmut_fail_handler) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a581d962f74017a660a78e9ebc4522011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by verifying version compatibility, opening a handle and registering the provided callbacks.  <a href="classsyscall_1_1bf__syscall__t.html#a581d962f74017a660a78e9ebc4522011">More...</a><br /></td></tr>
<tr class="separator:a581d962f74017a660a78e9ebc4522011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec9bf8e06592161b3803cd8da2d8cd6"><td class="memItemLeft" align="right" valign="top"><a id="abec9bf8e06592161b3803cd8da2d8cd6" name="abec9bf8e06592161b3803cd8da2d8cd6"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> () noexcept</td></tr>
<tr class="memdesc:abec9bf8e06592161b3803cd8da2d8cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by closing the handle. <br /></td></tr>
<tr class="separator:abec9bf8e06592161b3803cd8da2d8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ced8951c280ceb9cf26ad5a477aa2cf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2ced8951c280ceb9cf26ad5a477aa2cf">handle</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a2ced8951c280ceb9cf26ad5a477aa2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the handle that is used for syscalls. If this class has not been initialized, a default (likely 0) handle is returned.  <a href="classsyscall_1_1bf__syscall__t.html#a2ced8951c280ceb9cf26ad5a477aa2cf">More...</a><br /></td></tr>
<tr class="separator:a2ced8951c280ceb9cf26ad5a477aa2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f4c6acc6dcae301b4bd0cca721752d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a88f4c6acc6dcae301b4bd0cca721752d">bf_vm_op_create_vm</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a88f4c6acc6dcae301b4bd0cca721752d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VM and return it's ID.  <a href="classsyscall_1_1bf__syscall__t.html#a88f4c6acc6dcae301b4bd0cca721752d">More...</a><br /></td></tr>
<tr class="separator:a88f4c6acc6dcae301b4bd0cca721752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa2fbcaf0f75e1bb38d6b2419c2a0f728">bf_vm_op_destroy_vm</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VM given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#aa2fbcaf0f75e1bb38d6b2419c2a0f728">More...</a><br /></td></tr>
<tr class="separator:aa2fbcaf0f75e1bb38d6b2419c2a0f728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbe512644173318a7542718922e6675"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dbe512644173318a7542718922e6675"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a8dbe512644173318a7542718922e6675">bf_vm_op_map_direct</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u64 const &amp;phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a8dbe512644173318a7542718922e6675"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to map a physical address into the VM's direct map. This is the same as directly accessing the direct map with the difference being that software can provide a physical address and receive the precalculated virtual address.  <a href="classsyscall_1_1bf__syscall__t.html#a8dbe512644173318a7542718922e6675">More...</a><br /></td></tr>
<tr class="separator:a8dbe512644173318a7542718922e6675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139ae56700242c7faa45cf0dc06ff615"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a139ae56700242c7faa45cf0dc06ff615"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a139ae56700242c7faa45cf0dc06ff615">bf_vm_op_unmap_direct</a> (bsl::safe_u16 const &amp;vmid, T const *const ptr) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a139ae56700242c7faa45cf0dc06ff615"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct_broadcast, this syscall does not flush the TLB on any other PP, meaning this unmap is local to the PP the call is made on. Attempting to unmap a virtual address from the direct map that has been accessed on any other PP other than the PP this syscall is executed on will result in undefined behavior. This syscall is designed to support mapping and then immediately unmapping a physical address on a single PP during a single VMExit. It can also be used to map on a PP and then use unmap on the same PP during multiple VMExits, but special care must be taken to ensure no other PP can access the map, otherwise UB will occur.  <a href="classsyscall_1_1bf__syscall__t.html#a139ae56700242c7faa45cf0dc06ff615">More...</a><br /></td></tr>
<tr class="separator:a139ae56700242c7faa45cf0dc06ff615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9e55acd5c6abc88969e4fec072b9bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf9e55acd5c6abc88969e4fec072b9bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aaf9e55acd5c6abc88969e4fec072b9bb">bf_vm_op_unmap_direct_broadcast</a> (bsl::safe_u16 const &amp;vmid, T const *const ptr) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aaf9e55acd5c6abc88969e4fec072b9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct, this syscall performs a broadcast TLB flush which means it can be safely used on all direct mapped addresses. The downside of using this function is that it can be a lot slower than bf_vm_op_unmap_direct, especially on systems with a lot of PPs.  <a href="classsyscall_1_1bf__syscall__t.html#aaf9e55acd5c6abc88969e4fec072b9bb">More...</a><br /></td></tr>
<tr class="separator:aaf9e55acd5c6abc88969e4fec072b9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bdf9512b2bac2103cd9712f10e0100"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a22bdf9512b2bac2103cd9712f10e0100">bf_vm_op_tlb_flush</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a22bdf9512b2bac2103cd9712f10e0100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the ID of a VM, invalidates a TLB entry for a given GLA on the PP that this is executed on.  <a href="classsyscall_1_1bf__syscall__t.html#a22bdf9512b2bac2103cd9712f10e0100">More...</a><br /></td></tr>
<tr class="separator:a22bdf9512b2bac2103cd9712f10e0100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3775e0ff37788114cb5f25d2688a5df8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3775e0ff37788114cb5f25d2688a5df8">bf_vp_op_create_vp</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a3775e0ff37788114cb5f25d2688a5df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VP given the IDs of the VM and PP the VP will be assigned to. Upon success, this syscall returns the ID of the newly created VP.  <a href="classsyscall_1_1bf__syscall__t.html#a3775e0ff37788114cb5f25d2688a5df8">More...</a><br /></td></tr>
<tr class="separator:a3775e0ff37788114cb5f25d2688a5df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ebebe1d613b466425d54f29ef8f69a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a21ebebe1d613b466425d54f29ef8f69a">bf_vp_op_destroy_vp</a> (bsl::safe_u16 const &amp;vpid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a21ebebe1d613b466425d54f29ef8f69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VP given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#a21ebebe1d613b466425d54f29ef8f69a">More...</a><br /></td></tr>
<tr class="separator:a21ebebe1d613b466425d54f29ef8f69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00703a6f47968414c287ab76cc7e97c6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a00703a6f47968414c287ab76cc7e97c6">bf_vs_op_create_vs</a> (bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;ppid) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a00703a6f47968414c287ab76cc7e97c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to create a VS and return it's ID.  <a href="classsyscall_1_1bf__syscall__t.html#a00703a6f47968414c287ab76cc7e97c6">More...</a><br /></td></tr>
<tr class="separator:a00703a6f47968414c287ab76cc7e97c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724a2594d24a643e29e10f2022f4cd76"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a724a2594d24a643e29e10f2022f4cd76">bf_vs_op_destroy_vs</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a724a2594d24a643e29e10f2022f4cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to destroy a VS given an ID.  <a href="classsyscall_1_1bf__syscall__t.html#a724a2594d24a643e29e10f2022f4cd76">More...</a><br /></td></tr>
<tr class="separator:a724a2594d24a643e29e10f2022f4cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7f94f5da4b7fd47aef467ff09324c8a2">bf_vs_op_init_as_root</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to initialize a VS using the root VP state provided by the loader using the current PPID.  <a href="classsyscall_1_1bf__syscall__t.html#a7f94f5da4b7fd47aef467ff09324c8a2">More...</a><br /></td></tr>
<tr class="separator:a7f94f5da4b7fd47aef467ff09324c8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a77282b8dd8dd3d06830811cfdde4b8e6">bf_vs_op_read</a> (bsl::safe_u16 const &amp;vsid, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg) const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a CPU register from the VS given a bf_reg_t. Note that the bf_reg_t is architecture specific.  <a href="classsyscall_1_1bf__syscall__t.html#a77282b8dd8dd3d06830811cfdde4b8e6">More...</a><br /></td></tr>
<tr class="separator:a77282b8dd8dd3d06830811cfdde4b8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908cbed8d315f98cf49252b8e3446fcd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a908cbed8d315f98cf49252b8e3446fcd">bf_vs_op_write</a> (bsl::safe_u16 const &amp;vsid, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg, bsl::safe_u64 const &amp;value) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a908cbed8d315f98cf49252b8e3446fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to a CPU register in the VS given a bf_reg_t and the value to write. Note that the bf_reg_t is architecture specific.  <a href="classsyscall_1_1bf__syscall__t.html#a908cbed8d315f98cf49252b8e3446fcd">More...</a><br /></td></tr>
<tr class="separator:a908cbed8d315f98cf49252b8e3446fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31edaef67e15222b8192fd07a079a66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa31edaef67e15222b8192fd07a079a66">bf_vs_op_run</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa31edaef67e15222b8192fd07a079a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a VS given the ID of the VM, VP and VS to execute. The VS must be assigned to the provided VP and the provided VP must be assigned to the provided VM. The VP and VS must not be executing on any other PP, and the VS must be assigned to the PP this syscall is executed on. Upon success, this syscall will not return.  <a href="classsyscall_1_1bf__syscall__t.html#aa31edaef67e15222b8192fd07a079a66">More...</a><br /></td></tr>
<tr class="separator:aa31edaef67e15222b8192fd07a079a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2a36f6f20561a82c61cc3b1252db25"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5e2a36f6f20561a82c61cc3b1252db25">bf_vs_op_run_current</a> () noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a5e2a36f6f20561a82c61cc3b1252db25"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_vs_op_run_current tells the microkernel to execute the currently active VS, VP and VM.  <a href="classsyscall_1_1bf__syscall__t.html#a5e2a36f6f20561a82c61cc3b1252db25">More...</a><br /></td></tr>
<tr class="separator:a5e2a36f6f20561a82c61cc3b1252db25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315ebee647ee24661c9b93b65f933d64"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a315ebee647ee24661c9b93b65f933d64">bf_vs_op_advance_ip_and_run</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a315ebee647ee24661c9b93b65f933d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the IP and executes a VS given the ID of the VM, VP and VS to execute. The VS must be assigned to the provided VP and the provided VP must be assigned to the provided VM. The VP and VS must not be executing on any other PP, and the VS must be assigned to the PP this syscall is executed on. Upon success, this syscall will not return.  <a href="classsyscall_1_1bf__syscall__t.html#a315ebee647ee24661c9b93b65f933d64">More...</a><br /></td></tr>
<tr class="separator:a315ebee647ee24661c9b93b65f933d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af7bf62e706e5ce6bc770c6374ec89ec5">bf_vs_op_advance_ip_and_run_current</a> () noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_vs_op_advance_ip_and_run_current tells the microkernel to advance the IP of and execute the currently active VS, VP and VM.  <a href="classsyscall_1_1bf__syscall__t.html#af7bf62e706e5ce6bc770c6374ec89ec5">More...</a><br /></td></tr>
<tr class="separator:af7bf62e706e5ce6bc770c6374ec89ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571436e51276a3e613246df1a45d5a1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a571436e51276a3e613246df1a45d5a1b">bf_vs_op_promote</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a571436e51276a3e613246df1a45d5a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to promote the requested VS. This will stop the hypervisor complete on the physical processor that this syscall is executed on and replace it's state with the state in the VS. Note that this syscall only returns on error.  <a href="classsyscall_1_1bf__syscall__t.html#a571436e51276a3e613246df1a45d5a1b">More...</a><br /></td></tr>
<tr class="separator:a571436e51276a3e613246df1a45d5a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92bed718a8641bf68bd5af9078b6fc0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad92bed718a8641bf68bd5af9078b6fc0">bf_vs_op_clear</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ad92bed718a8641bf68bd5af9078b6fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_vs_op_clear tells the microkernel to clear the VS's hardware cache, if one exists. How this is used depends entirely on the hardware and is associated with AMD's VMCB Clean Bits, and Intel's VMClear instruction. See the associated documentation for more details. On AMD, this ABI clears the entire VMCB. For more fine grained control, use the write ABIs to manually modify the VMCB.  <a href="classsyscall_1_1bf__syscall__t.html#ad92bed718a8641bf68bd5af9078b6fc0">More...</a><br /></td></tr>
<tr class="separator:ad92bed718a8641bf68bd5af9078b6fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec08e8cd3cd1b5649d61e7077e1a151"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#abec08e8cd3cd1b5649d61e7077e1a151">bf_vs_op_migrate</a> (bsl::safe_u16 const &amp;vsid, bsl::safe_u16 const &amp;ppid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:abec08e8cd3cd1b5649d61e7077e1a151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrates a VS to the provided PP. The VS must not be active.  <a href="classsyscall_1_1bf__syscall__t.html#abec08e8cd3cd1b5649d61e7077e1a151">More...</a><br /></td></tr>
<tr class="separator:abec08e8cd3cd1b5649d61e7077e1a151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3e33ac1f5b3e2947355d38cf76363bdf">bf_vs_op_set_active</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#a3e33ac1f5b3e2947355d38cf76363bdf">More...</a><br /></td></tr>
<tr class="separator:a3e33ac1f5b3e2947355d38cf76363bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48188bdfdaa4e525e0910a0f89f5f409"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a48188bdfdaa4e525e0910a0f89f5f409">bf_vs_op_advance_ip_and_set_active</a> (bsl::safe_u16 const &amp;vmid, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a48188bdfdaa4e525e0910a0f89f5f409"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <a href="classsyscall_1_1bf__syscall__t.html#a48188bdfdaa4e525e0910a0f89f5f409">More...</a><br /></td></tr>
<tr class="separator:a48188bdfdaa4e525e0910a0f89f5f409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">bf_vs_op_tlb_flush</a> (bsl::safe_u16 const &amp;vsid, bsl::safe_u64 const &amp;gla) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the ID of a VS, invalidates a TLB entry for a given GLA on the PP that this is executed on.  <a href="classsyscall_1_1bf__syscall__t.html#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">More...</a><br /></td></tr>
<tr class="separator:a4fa7fcb699cf09b3fc280c0ec1ea7fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed00f6cfb54e47de19b8e30c48dc399f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aed00f6cfb54e47de19b8e30c48dc399f">bf_intrinsic_op_rdmsr</a> (bsl::safe_u32 const &amp;msr) const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aed00f6cfb54e47de19b8e30c48dc399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an MSR directly from the CPU given the address of the MSR to read. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be read, and which MSRs that can be read is up to the microkernel's internal policy as well as which architecture the hypervisor is running on.  <a href="classsyscall_1_1bf__syscall__t.html#aed00f6cfb54e47de19b8e30c48dc399f">More...</a><br /></td></tr>
<tr class="separator:aed00f6cfb54e47de19b8e30c48dc399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c04c9e4ec995aff660b55c08c1a69"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad06c04c9e4ec995aff660b55c08c1a69">bf_intrinsic_op_wrmsr</a> (bsl::safe_u32 const &amp;msr, bsl::safe_u64 const &amp;val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ad06c04c9e4ec995aff660b55c08c1a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to an MSR directly from the CPU given the address of the MSR to write as well as the value to write. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be written to, and which MSRs that can be written to is up to the microkernel's internal policy as well as which architecture the hypervisor is running on.  <a href="classsyscall_1_1bf__syscall__t.html#ad06c04c9e4ec995aff660b55c08c1a69">More...</a><br /></td></tr>
<tr class="separator:ad06c04c9e4ec995aff660b55c08c1a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2787d14fcb93d6c3f423a9f55d691149"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2787d14fcb93d6c3f423a9f55d691149"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2787d14fcb93d6c3f423a9f55d691149">bf_mem_op_alloc_page</a> (bsl::safe_u64 &amp;mut_phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a2787d14fcb93d6c3f423a9f55d691149"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM.  <a href="classsyscall_1_1bf__syscall__t.html#a2787d14fcb93d6c3f423a9f55d691149">More...</a><br /></td></tr>
<tr class="separator:a2787d14fcb93d6c3f423a9f55d691149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af410bb63b75855bafb20c0a1ba21bf97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af410bb63b75855bafb20c0a1ba21bf97"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af410bb63b75855bafb20c0a1ba21bf97">bf_mem_op_alloc_page</a> () noexcept -&gt; T *</td></tr>
<tr class="memdesc:af410bb63b75855bafb20c0a1ba21bf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM.  <a href="classsyscall_1_1bf__syscall__t.html#af410bb63b75855bafb20c0a1ba21bf97">More...</a><br /></td></tr>
<tr class="separator:af410bb63b75855bafb20c0a1ba21bf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7c5125fd5cdcd5a02a3aeb73904c8a04">bf_mem_op_alloc_huge</a> (bsl::safe_u64 const &amp;size, bsl::safe_u64 &amp;mut_phys) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following:  <a href="classsyscall_1_1bf__syscall__t.html#a7c5125fd5cdcd5a02a3aeb73904c8a04">More...</a><br /></td></tr>
<tr class="separator:a7c5125fd5cdcd5a02a3aeb73904c8a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#adeca2bbb88777ffb85913e26d8e42ee7">bf_mem_op_alloc_huge</a> (bsl::safe_u64 const &amp;size) noexcept -&gt; T *</td></tr>
<tr class="memdesc:adeca2bbb88777ffb85913e26d8e42ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following:  <a href="classsyscall_1_1bf__syscall__t.html#adeca2bbb88777ffb85913e26d8e42ee7">More...</a><br /></td></tr>
<tr class="separator:adeca2bbb88777ffb85913e26d8e42ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad32644c527c752a63686c5710ebe7bae"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad32644c527c752a63686c5710ebe7bae">bf_tls_rax</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ad32644c527c752a63686c5710ebe7bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rax.  <a href="classsyscall_1_1bf__syscall__t.html#ad32644c527c752a63686c5710ebe7bae">More...</a><br /></td></tr>
<tr class="separator:ad32644c527c752a63686c5710ebe7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9acd4d82aee2bc405b11306f889f58"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a2e9acd4d82aee2bc405b11306f889f58">bf_tls_set_rax</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a2e9acd4d82aee2bc405b11306f889f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rax.  <a href="classsyscall_1_1bf__syscall__t.html#a2e9acd4d82aee2bc405b11306f889f58">More...</a><br /></td></tr>
<tr class="separator:a2e9acd4d82aee2bc405b11306f889f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33f1320f9301da364b3080b6710e8d6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad33f1320f9301da364b3080b6710e8d6">bf_tls_rbx</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ad33f1320f9301da364b3080b6710e8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rbx.  <a href="classsyscall_1_1bf__syscall__t.html#ad33f1320f9301da364b3080b6710e8d6">More...</a><br /></td></tr>
<tr class="separator:ad33f1320f9301da364b3080b6710e8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9790de8d7d91a94793e09bd53f03377b"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9790de8d7d91a94793e09bd53f03377b">bf_tls_set_rbx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a9790de8d7d91a94793e09bd53f03377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rbx.  <a href="classsyscall_1_1bf__syscall__t.html#a9790de8d7d91a94793e09bd53f03377b">More...</a><br /></td></tr>
<tr class="separator:a9790de8d7d91a94793e09bd53f03377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b0b8367bfa55a5566b2edb20db154b"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a70b0b8367bfa55a5566b2edb20db154b">bf_tls_rcx</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a70b0b8367bfa55a5566b2edb20db154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rcx.  <a href="classsyscall_1_1bf__syscall__t.html#a70b0b8367bfa55a5566b2edb20db154b">More...</a><br /></td></tr>
<tr class="separator:a70b0b8367bfa55a5566b2edb20db154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e5599e55b11896e5e283b14cebfa5"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a585e5599e55b11896e5e283b14cebfa5">bf_tls_set_rcx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a585e5599e55b11896e5e283b14cebfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rcx.  <a href="classsyscall_1_1bf__syscall__t.html#a585e5599e55b11896e5e283b14cebfa5">More...</a><br /></td></tr>
<tr class="separator:a585e5599e55b11896e5e283b14cebfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e407d78c0442751cc69c0fe659225a"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad2e407d78c0442751cc69c0fe659225a">bf_tls_rdx</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ad2e407d78c0442751cc69c0fe659225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rdx.  <a href="classsyscall_1_1bf__syscall__t.html#ad2e407d78c0442751cc69c0fe659225a">More...</a><br /></td></tr>
<tr class="separator:ad2e407d78c0442751cc69c0fe659225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3050ded79cc7955b48db01bfa29cc91b"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3050ded79cc7955b48db01bfa29cc91b">bf_tls_set_rdx</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a3050ded79cc7955b48db01bfa29cc91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rdx.  <a href="classsyscall_1_1bf__syscall__t.html#a3050ded79cc7955b48db01bfa29cc91b">More...</a><br /></td></tr>
<tr class="separator:a3050ded79cc7955b48db01bfa29cc91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060d2eed4081b99da45faa59307b0ad7"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a060d2eed4081b99da45faa59307b0ad7">bf_tls_rbp</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a060d2eed4081b99da45faa59307b0ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rbp.  <a href="classsyscall_1_1bf__syscall__t.html#a060d2eed4081b99da45faa59307b0ad7">More...</a><br /></td></tr>
<tr class="separator:a060d2eed4081b99da45faa59307b0ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b496c5edf092ad96dd9d80d8682d63"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa3b496c5edf092ad96dd9d80d8682d63">bf_tls_set_rbp</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aa3b496c5edf092ad96dd9d80d8682d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rbp.  <a href="classsyscall_1_1bf__syscall__t.html#aa3b496c5edf092ad96dd9d80d8682d63">More...</a><br /></td></tr>
<tr class="separator:aa3b496c5edf092ad96dd9d80d8682d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3212ae58f5235454b0ff855c57a3ad9"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac3212ae58f5235454b0ff855c57a3ad9">bf_tls_rsi</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:ac3212ae58f5235454b0ff855c57a3ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rsi.  <a href="classsyscall_1_1bf__syscall__t.html#ac3212ae58f5235454b0ff855c57a3ad9">More...</a><br /></td></tr>
<tr class="separator:ac3212ae58f5235454b0ff855c57a3ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e019e91c72a6af1092b25b27c6a876"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ac9e019e91c72a6af1092b25b27c6a876">bf_tls_set_rsi</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:ac9e019e91c72a6af1092b25b27c6a876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rsi.  <a href="classsyscall_1_1bf__syscall__t.html#ac9e019e91c72a6af1092b25b27c6a876">More...</a><br /></td></tr>
<tr class="separator:ac9e019e91c72a6af1092b25b27c6a876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d0134ccc7f52edc6ad09935a0cd9e6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a64d0134ccc7f52edc6ad09935a0cd9e6">bf_tls_rdi</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a64d0134ccc7f52edc6ad09935a0cd9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.rdi.  <a href="classsyscall_1_1bf__syscall__t.html#a64d0134ccc7f52edc6ad09935a0cd9e6">More...</a><br /></td></tr>
<tr class="separator:a64d0134ccc7f52edc6ad09935a0cd9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab094cde9f7e44801007856e7dcda6afc"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ab094cde9f7e44801007856e7dcda6afc">bf_tls_set_rdi</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:ab094cde9f7e44801007856e7dcda6afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.rdi.  <a href="classsyscall_1_1bf__syscall__t.html#ab094cde9f7e44801007856e7dcda6afc">More...</a><br /></td></tr>
<tr class="separator:ab094cde9f7e44801007856e7dcda6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba6aebd69627e0500a16c1b4616504"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a53ba6aebd69627e0500a16c1b4616504">bf_tls_r8</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a53ba6aebd69627e0500a16c1b4616504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r8.  <a href="classsyscall_1_1bf__syscall__t.html#a53ba6aebd69627e0500a16c1b4616504">More...</a><br /></td></tr>
<tr class="separator:a53ba6aebd69627e0500a16c1b4616504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7864bf76ef53e59efd62dc11996736f0"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7864bf76ef53e59efd62dc11996736f0">bf_tls_set_r8</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a7864bf76ef53e59efd62dc11996736f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r8.  <a href="classsyscall_1_1bf__syscall__t.html#a7864bf76ef53e59efd62dc11996736f0">More...</a><br /></td></tr>
<tr class="separator:a7864bf76ef53e59efd62dc11996736f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9355fe923871138ee084c8b112c37dfa"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9355fe923871138ee084c8b112c37dfa">bf_tls_r9</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a9355fe923871138ee084c8b112c37dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r9.  <a href="classsyscall_1_1bf__syscall__t.html#a9355fe923871138ee084c8b112c37dfa">More...</a><br /></td></tr>
<tr class="separator:a9355fe923871138ee084c8b112c37dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8db39b8709a07100619fd76845f3a9d"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa8db39b8709a07100619fd76845f3a9d">bf_tls_set_r9</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aa8db39b8709a07100619fd76845f3a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r9.  <a href="classsyscall_1_1bf__syscall__t.html#aa8db39b8709a07100619fd76845f3a9d">More...</a><br /></td></tr>
<tr class="separator:aa8db39b8709a07100619fd76845f3a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a41e07266ecdffb89f87f7d7af52b33"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a5a41e07266ecdffb89f87f7d7af52b33">bf_tls_r10</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a5a41e07266ecdffb89f87f7d7af52b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r10.  <a href="classsyscall_1_1bf__syscall__t.html#a5a41e07266ecdffb89f87f7d7af52b33">More...</a><br /></td></tr>
<tr class="separator:a5a41e07266ecdffb89f87f7d7af52b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb3d5ba6eac1b7f615e9ce3247d860"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a32cb3d5ba6eac1b7f615e9ce3247d860">bf_tls_set_r10</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a32cb3d5ba6eac1b7f615e9ce3247d860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r10.  <a href="classsyscall_1_1bf__syscall__t.html#a32cb3d5ba6eac1b7f615e9ce3247d860">More...</a><br /></td></tr>
<tr class="separator:a32cb3d5ba6eac1b7f615e9ce3247d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d93a8c9b4eddac11aa052d545dafbe"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a62d93a8c9b4eddac11aa052d545dafbe">bf_tls_r11</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a62d93a8c9b4eddac11aa052d545dafbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r11.  <a href="classsyscall_1_1bf__syscall__t.html#a62d93a8c9b4eddac11aa052d545dafbe">More...</a><br /></td></tr>
<tr class="separator:a62d93a8c9b4eddac11aa052d545dafbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e6b33270f41f4a5cd4afb64c84d01a"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ad7e6b33270f41f4a5cd4afb64c84d01a">bf_tls_set_r11</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:ad7e6b33270f41f4a5cd4afb64c84d01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r11.  <a href="classsyscall_1_1bf__syscall__t.html#ad7e6b33270f41f4a5cd4afb64c84d01a">More...</a><br /></td></tr>
<tr class="separator:ad7e6b33270f41f4a5cd4afb64c84d01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441e9aaeb8ccaf9cb4ad24308ac2fff9"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a441e9aaeb8ccaf9cb4ad24308ac2fff9">bf_tls_r12</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a441e9aaeb8ccaf9cb4ad24308ac2fff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r12.  <a href="classsyscall_1_1bf__syscall__t.html#a441e9aaeb8ccaf9cb4ad24308ac2fff9">More...</a><br /></td></tr>
<tr class="separator:a441e9aaeb8ccaf9cb4ad24308ac2fff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a44a7a827210f302593813cebf1f64"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#af1a44a7a827210f302593813cebf1f64">bf_tls_set_r12</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:af1a44a7a827210f302593813cebf1f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r12.  <a href="classsyscall_1_1bf__syscall__t.html#af1a44a7a827210f302593813cebf1f64">More...</a><br /></td></tr>
<tr class="separator:af1a44a7a827210f302593813cebf1f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e18adc4f4b1ee9213cd6699d32abd2"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a26e18adc4f4b1ee9213cd6699d32abd2">bf_tls_r13</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a26e18adc4f4b1ee9213cd6699d32abd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r13.  <a href="classsyscall_1_1bf__syscall__t.html#a26e18adc4f4b1ee9213cd6699d32abd2">More...</a><br /></td></tr>
<tr class="separator:a26e18adc4f4b1ee9213cd6699d32abd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2f5508b5b544c8973b4e5433a7ab19"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a3a2f5508b5b544c8973b4e5433a7ab19">bf_tls_set_r13</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a3a2f5508b5b544c8973b4e5433a7ab19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r13.  <a href="classsyscall_1_1bf__syscall__t.html#a3a2f5508b5b544c8973b4e5433a7ab19">More...</a><br /></td></tr>
<tr class="separator:a3a2f5508b5b544c8973b4e5433a7ab19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4f056e1a81f0e8319bd8383772e9e4"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9b4f056e1a81f0e8319bd8383772e9e4">bf_tls_r14</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a9b4f056e1a81f0e8319bd8383772e9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r14.  <a href="classsyscall_1_1bf__syscall__t.html#a9b4f056e1a81f0e8319bd8383772e9e4">More...</a><br /></td></tr>
<tr class="separator:a9b4f056e1a81f0e8319bd8383772e9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7164a1d32fee2996b92994acd7859732"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7164a1d32fee2996b92994acd7859732">bf_tls_set_r14</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a7164a1d32fee2996b92994acd7859732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r14.  <a href="classsyscall_1_1bf__syscall__t.html#a7164a1d32fee2996b92994acd7859732">More...</a><br /></td></tr>
<tr class="separator:a7164a1d32fee2996b92994acd7859732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed597cc058c0897756a63a097976a9d3"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aed597cc058c0897756a63a097976a9d3">bf_tls_r15</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aed597cc058c0897756a63a097976a9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.r15.  <a href="classsyscall_1_1bf__syscall__t.html#aed597cc058c0897756a63a097976a9d3">More...</a><br /></td></tr>
<tr class="separator:aed597cc058c0897756a63a097976a9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3123659a43b876378c07d97877b735"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a8f3123659a43b876378c07d97877b735">bf_tls_set_r15</a> (bsl::safe_u64 const &amp;val) noexcept</td></tr>
<tr class="memdesc:a8f3123659a43b876378c07d97877b735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of tls.r15.  <a href="classsyscall_1_1bf__syscall__t.html#a8f3123659a43b876378c07d97877b735">More...</a><br /></td></tr>
<tr class="separator:a8f3123659a43b876378c07d97877b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad760118cbd1ae66a60c335253468c"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a92ad760118cbd1ae66a60c335253468c">bf_tls_extid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a92ad760118cbd1ae66a60c335253468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.extid.  <a href="classsyscall_1_1bf__syscall__t.html#a92ad760118cbd1ae66a60c335253468c">More...</a><br /></td></tr>
<tr class="separator:a92ad760118cbd1ae66a60c335253468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0540fcde200282cd1296de26707a70"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#afb0540fcde200282cd1296de26707a70">bf_tls_vmid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:afb0540fcde200282cd1296de26707a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vmid.  <a href="classsyscall_1_1bf__syscall__t.html#afb0540fcde200282cd1296de26707a70">More...</a><br /></td></tr>
<tr class="separator:afb0540fcde200282cd1296de26707a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9a58dde8c3a45c99acfd674230e072"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7a9a58dde8c3a45c99acfd674230e072">bf_tls_vpid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a7a9a58dde8c3a45c99acfd674230e072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vpid.  <a href="classsyscall_1_1bf__syscall__t.html#a7a9a58dde8c3a45c99acfd674230e072">More...</a><br /></td></tr>
<tr class="separator:a7a9a58dde8c3a45c99acfd674230e072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35e5b74544f6bd3d312cac596843ce8"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#aa35e5b74544f6bd3d312cac596843ce8">bf_tls_vsid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:aa35e5b74544f6bd3d312cac596843ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.vsid.  <a href="classsyscall_1_1bf__syscall__t.html#aa35e5b74544f6bd3d312cac596843ce8">More...</a><br /></td></tr>
<tr class="separator:aa35e5b74544f6bd3d312cac596843ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fceb107132749c977a8c651077ad3f8"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a7fceb107132749c977a8c651077ad3f8">bf_tls_ppid</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a7fceb107132749c977a8c651077ad3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.ppid.  <a href="classsyscall_1_1bf__syscall__t.html#a7fceb107132749c977a8c651077ad3f8">More...</a><br /></td></tr>
<tr class="separator:a7fceb107132749c977a8c651077ad3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5737ec6b2265cddddd9ed602af1ab6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#ade5737ec6b2265cddddd9ed602af1ab6">bf_tls_online_pps</a> () noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:ade5737ec6b2265cddddd9ed602af1ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of tls.online_pps.  <a href="classsyscall_1_1bf__syscall__t.html#ade5737ec6b2265cddddd9ed602af1ab6">More...</a><br /></td></tr>
<tr class="separator:ade5737ec6b2265cddddd9ed602af1ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c64d0f72191a89ce45489d25a222ac"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a40c64d0f72191a89ce45489d25a222ac">is_the_active_vm_the_root_vm</a> () noexcept -&gt; bool</td></tr>
<tr class="memdesc:a40c64d0f72191a89ce45489d25a222ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the active VM is the root VM. Returns false otherwise.  <a href="classsyscall_1_1bf__syscall__t.html#a40c64d0f72191a89ce45489d25a222ac">More...</a><br /></td></tr>
<tr class="separator:a40c64d0f72191a89ce45489d25a222ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70af417fbf6a855ca587d82d018f457d"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a70af417fbf6a855ca587d82d018f457d">is_vm_the_root_vm</a> (bsl::safe_u16 const &amp;vmid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a70af417fbf6a855ca587d82d018f457d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VMID is the ID of the root VM. Returns false otherwise.  <a href="classsyscall_1_1bf__syscall__t.html#a70af417fbf6a855ca587d82d018f457d">More...</a><br /></td></tr>
<tr class="separator:a70af417fbf6a855ca587d82d018f457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f765958a06805a1ea5fabfa3333d23"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a38f765958a06805a1ea5fabfa3333d23">is_vp_a_root_vp</a> (bsl::safe_u16 const &amp;vpid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a38f765958a06805a1ea5fabfa3333d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid().  <a href="classsyscall_1_1bf__syscall__t.html#a38f765958a06805a1ea5fabfa3333d23">More...</a><br /></td></tr>
<tr class="separator:a38f765958a06805a1ea5fabfa3333d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d062e733c278938437d85e8f879eef7"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html#a9d062e733c278938437d85e8f879eef7">is_vs_a_root_vs</a> (bsl::safe_u16 const &amp;vsid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a9d062e733c278938437d85e8f879eef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid().  <a href="classsyscall_1_1bf__syscall__t.html#a9d062e733c278938437d85e8f879eef7">More...</a><br /></td></tr>
<tr class="separator:a9d062e733c278938437d85e8f879eef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs, please see the Microkernel ABI Specification. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a581d962f74017a660a78e9ebc4522011" name="a581d962f74017a660a78e9ebc4522011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581d962f74017a660a78e9ebc4522011">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::initialize </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#ade5384db1d6d8a0b23754219e5ab09af">bf_callback_handler_bootstrap_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_bootstrap_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a6e24a9c2a154fcf5ac59d3f0164b567b">bf_callback_handler_vmexit_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_vmexit_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a8d84fbe0f1de9ccdb58661d7850fac82">bf_callback_handler_fail_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_fail_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> by verifying version compatibility, opening a handle and registering the provided callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>the version provided to the extension by the microkernel. If this API does not support the ABI versions that the microkernel supports, this function will fail. </td></tr>
    <tr><td class="paramname">pmut_bootstrap_handler</td><td>the bootstrap handler to register </td></tr>
    <tr><td class="paramname">pmut_vmexit_handler</td><td>the vmexit handler to register </td></tr>
    <tr><td class="paramname">pmut_fail_handler</td><td>the fail handler to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a2ced8951c280ceb9cf26ad5a477aa2cf" name="a2ced8951c280ceb9cf26ad5a477aa2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ced8951c280ceb9cf26ad5a477aa2cf">&#9670;&nbsp;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the handle that is used for syscalls. If this class has not been initialized, a default (likely 0) handle is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the handle that is used for syscalls. If this class has not been initialized, a default (likely 0) handle is returned. </dd></dl>

</div>
</div>
<a id="ad32644c527c752a63686c5710ebe7bae" name="ad32644c527c752a63686c5710ebe7bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32644c527c752a63686c5710ebe7bae">&#9670;&nbsp;</a></span>bf_tls_rax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rax. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rax </dd></dl>

</div>
</div>
<a id="a2e9acd4d82aee2bc405b11306f889f58" name="a2e9acd4d82aee2bc405b11306f889f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9acd4d82aee2bc405b11306f889f58">&#9670;&nbsp;</a></span>bf_tls_set_rax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rax </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rax to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad33f1320f9301da364b3080b6710e8d6" name="ad33f1320f9301da364b3080b6710e8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33f1320f9301da364b3080b6710e8d6">&#9670;&nbsp;</a></span>bf_tls_rbx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rbx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rbx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rbx </dd></dl>

</div>
</div>
<a id="a9790de8d7d91a94793e09bd53f03377b" name="a9790de8d7d91a94793e09bd53f03377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9790de8d7d91a94793e09bd53f03377b">&#9670;&nbsp;</a></span>bf_tls_set_rbx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rbx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rbx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rbx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b0b8367bfa55a5566b2edb20db154b" name="a70b0b8367bfa55a5566b2edb20db154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b0b8367bfa55a5566b2edb20db154b">&#9670;&nbsp;</a></span>bf_tls_rcx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rcx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rcx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rcx </dd></dl>

</div>
</div>
<a id="a585e5599e55b11896e5e283b14cebfa5" name="a585e5599e55b11896e5e283b14cebfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585e5599e55b11896e5e283b14cebfa5">&#9670;&nbsp;</a></span>bf_tls_set_rcx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rcx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rcx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rcx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2e407d78c0442751cc69c0fe659225a" name="ad2e407d78c0442751cc69c0fe659225a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e407d78c0442751cc69c0fe659225a">&#9670;&nbsp;</a></span>bf_tls_rdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rdx. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rdx </dd></dl>

</div>
</div>
<a id="a3050ded79cc7955b48db01bfa29cc91b" name="a3050ded79cc7955b48db01bfa29cc91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3050ded79cc7955b48db01bfa29cc91b">&#9670;&nbsp;</a></span>bf_tls_set_rdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rdx </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rdx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rdx to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a060d2eed4081b99da45faa59307b0ad7" name="a060d2eed4081b99da45faa59307b0ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060d2eed4081b99da45faa59307b0ad7">&#9670;&nbsp;</a></span>bf_tls_rbp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rbp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rbp. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rbp </dd></dl>

</div>
</div>
<a id="aa3b496c5edf092ad96dd9d80d8682d63" name="aa3b496c5edf092ad96dd9d80d8682d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b496c5edf092ad96dd9d80d8682d63">&#9670;&nbsp;</a></span>bf_tls_set_rbp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rbp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rbp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rbp to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3212ae58f5235454b0ff855c57a3ad9" name="ac3212ae58f5235454b0ff855c57a3ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3212ae58f5235454b0ff855c57a3ad9">&#9670;&nbsp;</a></span>bf_tls_rsi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rsi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rsi. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rsi </dd></dl>

</div>
</div>
<a id="ac9e019e91c72a6af1092b25b27c6a876" name="ac9e019e91c72a6af1092b25b27c6a876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e019e91c72a6af1092b25b27c6a876">&#9670;&nbsp;</a></span>bf_tls_set_rsi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rsi </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rsi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rsi to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64d0134ccc7f52edc6ad09935a0cd9e6" name="a64d0134ccc7f52edc6ad09935a0cd9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d0134ccc7f52edc6ad09935a0cd9e6">&#9670;&nbsp;</a></span>bf_tls_rdi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_rdi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.rdi. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.rdi </dd></dl>

</div>
</div>
<a id="ab094cde9f7e44801007856e7dcda6afc" name="ab094cde9f7e44801007856e7dcda6afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab094cde9f7e44801007856e7dcda6afc">&#9670;&nbsp;</a></span>bf_tls_set_rdi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_rdi </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.rdi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.rdi to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53ba6aebd69627e0500a16c1b4616504" name="a53ba6aebd69627e0500a16c1b4616504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ba6aebd69627e0500a16c1b4616504">&#9670;&nbsp;</a></span>bf_tls_r8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r8. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r8 </dd></dl>

</div>
</div>
<a id="a7864bf76ef53e59efd62dc11996736f0" name="a7864bf76ef53e59efd62dc11996736f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7864bf76ef53e59efd62dc11996736f0">&#9670;&nbsp;</a></span>bf_tls_set_r8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r8 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r8 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9355fe923871138ee084c8b112c37dfa" name="a9355fe923871138ee084c8b112c37dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9355fe923871138ee084c8b112c37dfa">&#9670;&nbsp;</a></span>bf_tls_r9()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r9 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r9. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r9 </dd></dl>

</div>
</div>
<a id="aa8db39b8709a07100619fd76845f3a9d" name="aa8db39b8709a07100619fd76845f3a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8db39b8709a07100619fd76845f3a9d">&#9670;&nbsp;</a></span>bf_tls_set_r9()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r9 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r9. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r9 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a41e07266ecdffb89f87f7d7af52b33" name="a5a41e07266ecdffb89f87f7d7af52b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a41e07266ecdffb89f87f7d7af52b33">&#9670;&nbsp;</a></span>bf_tls_r10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r10. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r10 </dd></dl>

</div>
</div>
<a id="a32cb3d5ba6eac1b7f615e9ce3247d860" name="a32cb3d5ba6eac1b7f615e9ce3247d860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cb3d5ba6eac1b7f615e9ce3247d860">&#9670;&nbsp;</a></span>bf_tls_set_r10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r10 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r10 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62d93a8c9b4eddac11aa052d545dafbe" name="a62d93a8c9b4eddac11aa052d545dafbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d93a8c9b4eddac11aa052d545dafbe">&#9670;&nbsp;</a></span>bf_tls_r11()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r11 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r11. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r11 </dd></dl>

</div>
</div>
<a id="ad7e6b33270f41f4a5cd4afb64c84d01a" name="ad7e6b33270f41f4a5cd4afb64c84d01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e6b33270f41f4a5cd4afb64c84d01a">&#9670;&nbsp;</a></span>bf_tls_set_r11()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r11 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r11. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r11 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a441e9aaeb8ccaf9cb4ad24308ac2fff9" name="a441e9aaeb8ccaf9cb4ad24308ac2fff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441e9aaeb8ccaf9cb4ad24308ac2fff9">&#9670;&nbsp;</a></span>bf_tls_r12()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r12 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r12. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r12 </dd></dl>

</div>
</div>
<a id="af1a44a7a827210f302593813cebf1f64" name="af1a44a7a827210f302593813cebf1f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a44a7a827210f302593813cebf1f64">&#9670;&nbsp;</a></span>bf_tls_set_r12()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r12 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r12. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r12 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26e18adc4f4b1ee9213cd6699d32abd2" name="a26e18adc4f4b1ee9213cd6699d32abd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e18adc4f4b1ee9213cd6699d32abd2">&#9670;&nbsp;</a></span>bf_tls_r13()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r13 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r13. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r13 </dd></dl>

</div>
</div>
<a id="a3a2f5508b5b544c8973b4e5433a7ab19" name="a3a2f5508b5b544c8973b4e5433a7ab19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2f5508b5b544c8973b4e5433a7ab19">&#9670;&nbsp;</a></span>bf_tls_set_r13()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r13 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r13. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r13 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b4f056e1a81f0e8319bd8383772e9e4" name="a9b4f056e1a81f0e8319bd8383772e9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4f056e1a81f0e8319bd8383772e9e4">&#9670;&nbsp;</a></span>bf_tls_r14()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r14 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r14. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r14 </dd></dl>

</div>
</div>
<a id="a7164a1d32fee2996b92994acd7859732" name="a7164a1d32fee2996b92994acd7859732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7164a1d32fee2996b92994acd7859732">&#9670;&nbsp;</a></span>bf_tls_set_r14()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r14 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r14. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r14 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed597cc058c0897756a63a097976a9d3" name="aed597cc058c0897756a63a097976a9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed597cc058c0897756a63a097976a9d3">&#9670;&nbsp;</a></span>bf_tls_r15()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_r15 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.r15. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.r15 </dd></dl>

</div>
</div>
<a id="a8f3123659a43b876378c07d97877b735" name="a8f3123659a43b876378c07d97877b735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3123659a43b876378c07d97877b735">&#9670;&nbsp;</a></span>bf_tls_set_r15()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void syscall::bf_syscall_t::bf_tls_set_r15 </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of tls.r15. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set tls.r15 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92ad760118cbd1ae66a60c335253468c" name="a92ad760118cbd1ae66a60c335253468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ad760118cbd1ae66a60c335253468c">&#9670;&nbsp;</a></span>bf_tls_extid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_extid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.extid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.extid </dd></dl>

</div>
</div>
<a id="afb0540fcde200282cd1296de26707a70" name="afb0540fcde200282cd1296de26707a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0540fcde200282cd1296de26707a70">&#9670;&nbsp;</a></span>bf_tls_vmid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_vmid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vmid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vmid </dd></dl>

</div>
</div>
<a id="a7a9a58dde8c3a45c99acfd674230e072" name="a7a9a58dde8c3a45c99acfd674230e072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9a58dde8c3a45c99acfd674230e072">&#9670;&nbsp;</a></span>bf_tls_vpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_vpid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vpid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vpid </dd></dl>

</div>
</div>
<a id="aa35e5b74544f6bd3d312cac596843ce8" name="aa35e5b74544f6bd3d312cac596843ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35e5b74544f6bd3d312cac596843ce8">&#9670;&nbsp;</a></span>bf_tls_vsid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_vsid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.vsid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.vsid </dd></dl>

</div>
</div>
<a id="a7fceb107132749c977a8c651077ad3f8" name="a7fceb107132749c977a8c651077ad3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fceb107132749c977a8c651077ad3f8">&#9670;&nbsp;</a></span>bf_tls_ppid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_ppid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.ppid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.ppid </dd></dl>

</div>
</div>
<a id="ade5737ec6b2265cddddd9ed602af1ab6" name="ade5737ec6b2265cddddd9ed602af1ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5737ec6b2265cddddd9ed602af1ab6">&#9670;&nbsp;</a></span>bf_tls_online_pps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::bf_tls_online_pps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of tls.online_pps. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of tls.online_pps </dd></dl>

</div>
</div>
<a id="a40c64d0f72191a89ce45489d25a222ac" name="a40c64d0f72191a89ce45489d25a222ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c64d0f72191a89ce45489d25a222ac">&#9670;&nbsp;</a></span>is_the_active_vm_the_root_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_the_active_vm_the_root_vm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the active VM is the root VM. Returns false otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the active VM is the root VM. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a70af417fbf6a855ca587d82d018f457d" name="a70af417fbf6a855ca587d82d018f457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70af417fbf6a855ca587d82d018f457d">&#9670;&nbsp;</a></span>is_vm_the_root_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_vm_the_root_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VMID is the ID of the root VM. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>the ID of the VM to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VMID is the ID of the root VM. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a38f765958a06805a1ea5fabfa3333d23" name="a38f765958a06805a1ea5fabfa3333d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f765958a06805a1ea5fabfa3333d23">&#9670;&nbsp;</a></span>is_vp_a_root_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_vp_a_root_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>the ID of the VP to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VPID is the ID of a root VP. Returns false otherwise. This is the same as vpid == sys.bf_tls_ppid(). </dd></dl>

</div>
</div>
<a id="a9d062e733c278938437d85e8f879eef7" name="a9d062e733c278938437d85e8f879eef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d062e733c278938437d85e8f879eef7">&#9670;&nbsp;</a></span>is_vs_a_root_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_syscall_t::is_vs_a_root_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>the ID of the VS to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided VSID is the ID of a root VS. Returns false otherwise. This is the same as vsid == sys.bf_tls_ppid(). </dd></dl>

</div>
</div>
<a id="a88f4c6acc6dcae301b4bd0cca721752d" name="a88f4c6acc6dcae301b4bd0cca721752d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f4c6acc6dcae301b4bd0cca721752d">&#9670;&nbsp;</a></span>bf_vm_op_create_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_create_vm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VM and return it's ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the resulting ID, or bsl::safe_u16::failure() on failure. </dd></dl>

</div>
</div>
<a id="aa2fbcaf0f75e1bb38d6b2419c2a0f728" name="aa2fbcaf0f75e1bb38d6b2419c2a0f728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fbcaf0f75e1bb38d6b2419c2a0f728">&#9670;&nbsp;</a></span>bf_vm_op_destroy_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_destroy_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VM given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a8dbe512644173318a7542718922e6675" name="a8dbe512644173318a7542718922e6675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbe512644173318a7542718922e6675">&#9670;&nbsp;</a></span>bf_vm_op_map_direct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_map_direct </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to map a physical address into the VM's direct map. This is the same as directly accessing the direct map with the difference being that software can provide a physical address and receive the precalculated virtual address. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to map the physical address to </td></tr>
    <tr><td class="paramname">phys</td><td>The physical address to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the map on success, returns a nullptr on failure. </dd></dl>

</div>
</div>
<a id="a139ae56700242c7faa45cf0dc06ff615" name="a139ae56700242c7faa45cf0dc06ff615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139ae56700242c7faa45cf0dc06ff615">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_unmap_direct </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct_broadcast, this syscall does not flush the TLB on any other PP, meaning this unmap is local to the PP the call is made on. Attempting to unmap a virtual address from the direct map that has been accessed on any other PP other than the PP this syscall is executed on will result in undefined behavior. This syscall is designed to support mapping and then immediately unmapping a physical address on a single PP during a single VMExit. It can also be used to map on a PP and then use unmap on the same PP during multiple VMExits, but special care must be taken to ensure no other PP can access the map, otherwise UB will occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to unmap the virtual address from </td></tr>
    <tr><td class="paramname">ptr</td><td>The virtual address to unmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aaf9e55acd5c6abc88969e4fec072b9bb" name="aaf9e55acd5c6abc88969e4fec072b9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9e55acd5c6abc88969e4fec072b9bb">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_unmap_direct_broadcast </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to unmap a previously mapped virtual address in the direct map. Unlike bf_vm_op_unmap_direct, this syscall performs a broadcast TLB flush which means it can be safely used on all direct mapped addresses. The downside of using this function is that it can be a lot slower than bf_vm_op_unmap_direct, especially on systems with a lot of PPs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to unmap the virtual address from </td></tr>
    <tr><td class="paramname">ptr</td><td>The virtual address to unmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a22bdf9512b2bac2103cd9712f10e0100" name="a22bdf9512b2bac2103cd9712f10e0100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bdf9512b2bac2103cd9712f10e0100">&#9670;&nbsp;</a></span>bf_vm_op_tlb_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vm_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the ID of a VM, invalidates a TLB entry for a given GLA on the PP that this is executed on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to invalidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a3775e0ff37788114cb5f25d2688a5df8" name="a3775e0ff37788114cb5f25d2688a5df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3775e0ff37788114cb5f25d2688a5df8">&#9670;&nbsp;</a></span>bf_vp_op_create_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vp_op_create_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VP given the IDs of the VM and PP the VP will be assigned to. Upon success, this syscall returns the ID of the newly created VP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to assign the newly created VP to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the resulting ID, or bsl::safe_u16::failure() on failure. </dd></dl>

</div>
</div>
<a id="a21ebebe1d613b466425d54f29ef8f69a" name="a21ebebe1d613b466425d54f29ef8f69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ebebe1d613b466425d54f29ef8f69a">&#9670;&nbsp;</a></span>bf_vp_op_destroy_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vp_op_destroy_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VP given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a00703a6f47968414c287ab76cc7e97c6" name="a00703a6f47968414c287ab76cc7e97c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00703a6f47968414c287ab76cc7e97c6">&#9670;&nbsp;</a></span>bf_vs_op_create_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_create_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to create a VS and return it's ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP to assign the newly created VS to </td></tr>
    <tr><td class="paramname">ppid</td><td>The resulting VSID of the newly created VS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the resulting ID, or bsl::safe_u16::failure() on failure. </dd></dl>

</div>
</div>
<a id="a724a2594d24a643e29e10f2022f4cd76" name="a724a2594d24a643e29e10f2022f4cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724a2594d24a643e29e10f2022f4cd76">&#9670;&nbsp;</a></span>bf_vs_op_destroy_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_destroy_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to destroy a VS given an ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a7f94f5da4b7fd47aef467ff09324c8a2" name="a7f94f5da4b7fd47aef467ff09324c8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f94f5da4b7fd47aef467ff09324c8a2">&#9670;&nbsp;</a></span>bf_vs_op_init_as_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_init_as_root </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to initialize a VS using the root VP state provided by the loader using the current PPID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to initialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a77282b8dd8dd3d06830811cfdde4b8e6" name="a77282b8dd8dd3d06830811cfdde4b8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77282b8dd8dd3d06830811cfdde4b8e6">&#9670;&nbsp;</a></span>bf_vs_op_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_read </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a CPU register from the VS given a bf_reg_t. Note that the bf_reg_t is architecture specific. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to read from </td></tr>
    <tr><td class="paramname">reg</td><td>A bf_reg_t defining which register to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value read, or bsl::safe_u64::failure() on failure. </dd></dl>

</div>
</div>
<a id="a908cbed8d315f98cf49252b8e3446fcd" name="a908cbed8d315f98cf49252b8e3446fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908cbed8d315f98cf49252b8e3446fcd">&#9670;&nbsp;</a></span>bf_vs_op_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_write </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to a CPU register in the VS given a bf_reg_t and the value to write. Note that the bf_reg_t is architecture specific. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to write to </td></tr>
    <tr><td class="paramname">reg</td><td>A bf_reg_t defining which register to write to </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the requested register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aa31edaef67e15222b8192fd07a079a66" name="aa31edaef67e15222b8192fd07a079a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31edaef67e15222b8192fd07a079a66">&#9670;&nbsp;</a></span>bf_vs_op_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_run </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a VS given the ID of the VM, VP and VS to execute. The VS must be assigned to the provided VP and the provided VP must be assigned to the provided VM. The VP and VS must not be executing on any other PP, and the VS must be assigned to the PP this syscall is executed on. Upon success, this syscall will not return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a5e2a36f6f20561a82c61cc3b1252db25" name="a5e2a36f6f20561a82c61cc3b1252db25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2a36f6f20561a82c61cc3b1252db25">&#9670;&nbsp;</a></span>bf_vs_op_run_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_run_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_vs_op_run_current tells the microkernel to execute the currently active VS, VP and VM. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a315ebee647ee24661c9b93b65f933d64" name="a315ebee647ee24661c9b93b65f933d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315ebee647ee24661c9b93b65f933d64">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_run </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the IP and executes a VS given the ID of the VM, VP and VS to execute. The VS must be assigned to the provided VP and the provided VP must be assigned to the provided VM. The VP and VS must not be executing on any other PP, and the VS must be assigned to the PP this syscall is executed on. Upon success, this syscall will not return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to advance the IP for </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to advance the IP for </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to advance the IP for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="af7bf62e706e5ce6bc770c6374ec89ec5" name="af7bf62e706e5ce6bc770c6374ec89ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bf62e706e5ce6bc770c6374ec89ec5">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_run_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_vs_op_advance_ip_and_run_current tells the microkernel to advance the IP of and execute the currently active VS, VP and VM. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a571436e51276a3e613246df1a45d5a1b" name="a571436e51276a3e613246df1a45d5a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571436e51276a3e613246df1a45d5a1b">&#9670;&nbsp;</a></span>bf_vs_op_promote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_promote </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to promote the requested VS. This will stop the hypervisor complete on the physical processor that this syscall is executed on and replace it's state with the state in the VS. Note that this syscall only returns on error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to promote </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ad92bed718a8641bf68bd5af9078b6fc0" name="ad92bed718a8641bf68bd5af9078b6fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92bed718a8641bf68bd5af9078b6fc0">&#9670;&nbsp;</a></span>bf_vs_op_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_clear </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_vs_op_clear tells the microkernel to clear the VS's hardware cache, if one exists. How this is used depends entirely on the hardware and is associated with AMD's VMCB Clean Bits, and Intel's VMClear instruction. See the associated documentation for more details. On AMD, this ABI clears the entire VMCB. For more fine grained control, use the write ABIs to manually modify the VMCB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="abec08e8cd3cd1b5649d61e7077e1a151" name="abec08e8cd3cd1b5649d61e7077e1a151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec08e8cd3cd1b5649d61e7077e1a151">&#9670;&nbsp;</a></span>bf_vs_op_migrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_migrate </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Migrates a VS to the provided PP. The VS must not be active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to migrate </td></tr>
    <tr><td class="paramname">ppid</td><td>The ID of the PP to migrate the VS to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a3e33ac1f5b3e2947355d38cf76363bdf" name="a3e33ac1f5b3e2947355d38cf76363bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e33ac1f5b3e2947355d38cf76363bdf">&#9670;&nbsp;</a></span>bf_vs_op_set_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_set_active </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a48188bdfdaa4e525e0910a0f89f5f409" name="a48188bdfdaa4e525e0910a0f89f5f409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48188bdfdaa4e525e0910a0f89f5f409">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_set_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_advance_ip_and_set_active </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM to run </td></tr>
    <tr><td class="paramname">vpid</td><td>The ID of the VP to run </td></tr>
    <tr><td class="paramname">vsid</td><td>The ID of the VS to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a4fa7fcb699cf09b3fc280c0ec1ea7fa1" name="a4fa7fcb699cf09b3fc280c0ec1ea7fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa7fcb699cf09b3fc280c0ec1ea7fa1">&#9670;&nbsp;</a></span>bf_vs_op_tlb_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_vs_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>gla</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the ID of a VS, invalidates a TLB entry for a given GLA on the PP that this is executed on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS to invalidate </td></tr>
    <tr><td class="paramname">gla</td><td>The GLA to invalidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aed00f6cfb54e47de19b8e30c48dc399f" name="aed00f6cfb54e47de19b8e30c48dc399f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed00f6cfb54e47de19b8e30c48dc399f">&#9670;&nbsp;</a></span>bf_intrinsic_op_rdmsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_intrinsic_op_rdmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>msr</em></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an MSR directly from the CPU given the address of the MSR to read. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be read, and which MSRs that can be read is up to the microkernel's internal policy as well as which architecture the hypervisor is running on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The address of the MSR to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value read, or bsl::safe_u64::failure() on failure. </dd></dl>

</div>
</div>
<a id="ad06c04c9e4ec995aff660b55c08c1a69" name="ad06c04c9e4ec995aff660b55c08c1a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c04c9e4ec995aff660b55c08c1a69">&#9670;&nbsp;</a></span>bf_intrinsic_op_wrmsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_intrinsic_op_wrmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>msr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to an MSR directly from the CPU given the address of the MSR to write as well as the value to write. Note that this is specific to Intel/AMD only. Also note that not all MSRs can be written to, and which MSRs that can be written to is up to the microkernel's internal policy as well as which architecture the hypervisor is running on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The address of the MSR to write to </td></tr>
    <tr><td class="paramname">val</td><td>The value to write to the requested MSR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a2787d14fcb93d6c3f423a9f55d691149" name="a2787d14fcb93d6c3f423a9f55d691149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2787d14fcb93d6c3f423a9f55d691149">&#9670;&nbsp;</a></span>bf_mem_op_alloc_page() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_page </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 &amp;&#160;</td>
          <td class="paramname"><em>mut_phys</em></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_phys</td><td>The physical address of the resulting page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="af410bb63b75855bafb20c0a1ba21bf97" name="af410bb63b75855bafb20c0a1ba21bf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af410bb63b75855bafb20c0a1ba21bf97">&#9670;&nbsp;</a></span>bf_mem_op_alloc_page() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_page allocates a page, and maps this page into the direct map of the VM. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="a7c5125fd5cdcd5a02a3aeb73904c8a04" name="a7c5125fd5cdcd5a02a3aeb73904c8a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5125fd5cdcd5a02a3aeb73904c8a04">&#9670;&nbsp;</a></span>bf_mem_op_alloc_huge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_huge </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 &amp;&#160;</td>
          <td class="paramname"><em>mut_phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following: </p>
<ul>
<li>The total memory available to allocate from this pool is extremely limited. This should only be used when absolutely needed, and extensions should not expect more than 1 MB (might be less) of total memory available.</li>
<li>Memory allocated from the huge pool might be allocated using different schemes. For example, the microkernel might allocate in increments of a page, or it might use a buddy allocator that would allocate in multiples of 2. If the allocation size doesn't match the algorithm, internal fragmentation could occur, further limiting the total number of allocations this pool can support.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to allocate </td></tr>
    <tr><td class="paramname">mut_phys</td><td>The physical address of the resulting memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<a id="adeca2bbb88777ffb85913e26d8e42ee7" name="adeca2bbb88777ffb85913e26d8e42ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeca2bbb88777ffb85913e26d8e42ee7">&#9670;&nbsp;</a></span>bf_mem_op_alloc_huge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_t::bf_mem_op_alloc_huge </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bf_mem_op_alloc_huge allocates a physically contiguous block of memory. When allocating a page, the extension should keep in mind the following: </p>
<ul>
<li>The total memory available to allocate from this pool is extremely limited. This should only be used when absolutely needed, and extensions should not expect more than 1 MB (might be less) of total memory available.</li>
<li>Memory allocated from the huge pool might be allocated using different schemes. For example, the microkernel might allocate in increments of a page, or it might use a buddy allocator that would allocate in multiples of 2. If the allocation size doesn't match the algorithm, internal fragmentation could occur, further limiting the total number of allocations this pool can support.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of pointer to return. Must be a POD type and the size of a page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated memory on success, or a nullptr on failure. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>syscall/src/<a class="el" href="bf__syscall__t_8hpp_source.html">bf_syscall_t.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesyscall.html">syscall</a></li><li class="navelem"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
