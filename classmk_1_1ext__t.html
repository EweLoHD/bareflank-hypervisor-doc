<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank Hypervisor: mk::ext_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bareflank Hypervisor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmk_1_1ext__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmk_1_1ext__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mk::ext_t Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to do so. This class also maintains all of the resources given to an extension, as well as the extension's memory map, ELF file, stack, TLS blocks, and all of it's memory map functions.  
 <a href="classmk_1_1ext__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mocks_2ext__t_8hpp_source.html">ext_t.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a258a800a5eca55cdd7a2317c6ccb12f6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a258a800a5eca55cdd7a2317c6ccb12f6">initialize</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool, bsl::safe_u16 const &amp;i, <a class="el" href="namespaceloader.html#afd2bbbd3305d4d499c41035aee9f464e">loader::ext_elf_file_t</a> const *const file, <a class="el" href="namespacemk.html#a6eb130b521649a4ca56bb0f9902a2ce9">root_page_table_t</a> const &amp;system_rpt) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a258a800a5eca55cdd7a2317c6ccb12f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>.  <a href="classmk_1_1ext__t.html#a258a800a5eca55cdd7a2317c6ccb12f6">More...</a><br /></td></tr>
<tr class="separator:a258a800a5eca55cdd7a2317c6ccb12f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481fef4d3a96bfe4f69bd3588e9fc238"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a481fef4d3a96bfe4f69bd3588e9fc238">release</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool, <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> const &amp;huge_pool) noexcept</td></tr>
<tr class="memdesc:a481fef4d3a96bfe4f69bd3588e9fc238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>.  <a href="classmk_1_1ext__t.html#a481fef4d3a96bfe4f69bd3588e9fc238">More...</a><br /></td></tr>
<tr class="separator:a481fef4d3a96bfe4f69bd3588e9fc238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71febf3b0b5482748ea2888290e38ba5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a71febf3b0b5482748ea2888290e38ba5">id</a> () const noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a71febf3b0b5482748ea2888290e38ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>.  <a href="classmk_1_1ext__t.html#a71febf3b0b5482748ea2888290e38ba5">More...</a><br /></td></tr>
<tr class="separator:a71febf3b0b5482748ea2888290e38ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fef348b1f48ed14c4a876b826d27b3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a41fef348b1f48ed14c4a876b826d27b3">bootstrap_ip</a> () const noexcept -&gt; bsl::safe_u64 const &amp;</td></tr>
<tr class="memdesc:a41fef348b1f48ed14c4a876b826d27b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bootstrap IP for this extension.  <a href="classmk_1_1ext__t.html#a41fef348b1f48ed14c4a876b826d27b3">More...</a><br /></td></tr>
<tr class="separator:a41fef348b1f48ed14c4a876b826d27b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada061ad9d0daa28ff0671f8ff476dfe4"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ada061ad9d0daa28ff0671f8ff476dfe4">set_bootstrap_ip</a> (bsl::safe_u64 const &amp;ip) noexcept</td></tr>
<tr class="memdesc:ada061ad9d0daa28ff0671f8ff476dfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bootstrap IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for bootstrapping.  <a href="classmk_1_1ext__t.html#ada061ad9d0daa28ff0671f8ff476dfe4">More...</a><br /></td></tr>
<tr class="separator:ada061ad9d0daa28ff0671f8ff476dfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f786394bb3a0f67a8a16d2129dc48d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a3f786394bb3a0f67a8a16d2129dc48d4">vmexit_ip</a> () const noexcept -&gt; bsl::safe_u64 const &amp;</td></tr>
<tr class="memdesc:a3f786394bb3a0f67a8a16d2129dc48d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the VMExit IP for this extension.  <a href="classmk_1_1ext__t.html#a3f786394bb3a0f67a8a16d2129dc48d4">More...</a><br /></td></tr>
<tr class="separator:a3f786394bb3a0f67a8a16d2129dc48d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b464832a9c4965fdfc28c8f9bbea1e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a42b464832a9c4965fdfc28c8f9bbea1e">set_vmexit_ip</a> (bsl::safe_u64 const &amp;ip) noexcept</td></tr>
<tr class="memdesc:a42b464832a9c4965fdfc28c8f9bbea1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the VMExit IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for VMExits.  <a href="classmk_1_1ext__t.html#a42b464832a9c4965fdfc28c8f9bbea1e">More...</a><br /></td></tr>
<tr class="separator:a42b464832a9c4965fdfc28c8f9bbea1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2582d4a3fe12cadce3803037742ba6f2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a2582d4a3fe12cadce3803037742ba6f2">fail_ip</a> () const noexcept -&gt; bsl::safe_u64 const &amp;</td></tr>
<tr class="memdesc:a2582d4a3fe12cadce3803037742ba6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fast fail IP for this extension.  <a href="classmk_1_1ext__t.html#a2582d4a3fe12cadce3803037742ba6f2">More...</a><br /></td></tr>
<tr class="separator:a2582d4a3fe12cadce3803037742ba6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a622306709740b624e6ad9904adf854"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a5a622306709740b624e6ad9904adf854">set_fail_ip</a> (bsl::safe_u64 const &amp;ip) noexcept</td></tr>
<tr class="memdesc:a5a622306709740b624e6ad9904adf854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fast fail IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for fail callbacks.  <a href="classmk_1_1ext__t.html#a5a622306709740b624e6ad9904adf854">More...</a><br /></td></tr>
<tr class="separator:a5a622306709740b624e6ad9904adf854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44de1469cd56addd3c5552809124298"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#aa44de1469cd56addd3c5552809124298">open_handle</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aa44de1469cd56addd3c5552809124298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a handle and returns the resulting handle.  <a href="classmk_1_1ext__t.html#aa44de1469cd56addd3c5552809124298">More...</a><br /></td></tr>
<tr class="separator:aa44de1469cd56addd3c5552809124298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f94a2264b704165a9fbed4f2df65295"><td class="memItemLeft" align="right" valign="top"><a id="a2f94a2264b704165a9fbed4f2df65295" name="a2f94a2264b704165a9fbed4f2df65295"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>close_handle</b> () noexcept</td></tr>
<tr class="memdesc:a2f94a2264b704165a9fbed4f2df65295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a previously opened handle. <br /></td></tr>
<tr class="separator:a2f94a2264b704165a9fbed4f2df65295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8602b26b1f23e0df761f32f8a0dd93"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a0d8602b26b1f23e0df761f32f8a0dd93">is_handle_valid</a> (bsl::safe_u64 const &amp;hndl) const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a0d8602b26b1f23e0df761f32f8a0dd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if provided handle is valid.  <a href="classmk_1_1ext__t.html#a0d8602b26b1f23e0df761f32f8a0dd93">More...</a><br /></td></tr>
<tr class="separator:a0d8602b26b1f23e0df761f32f8a0dd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00feac861b88d79d128ba456209d6ea0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a00feac861b88d79d128ba456209d6ea0">handle</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a00feac861b88d79d128ba456209d6ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>.  <a href="classmk_1_1ext__t.html#a00feac861b88d79d128ba456209d6ea0">More...</a><br /></td></tr>
<tr class="separator:a00feac861b88d79d128ba456209d6ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7a4db33108b5229941621a765bab9d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#afc7a4db33108b5229941621a765bab9d">is_started</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:afc7a4db33108b5229941621a765bab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the extension's main function has completed it's execution.  <a href="classmk_1_1ext__t.html#afc7a4db33108b5229941621a765bab9d">More...</a><br /></td></tr>
<tr class="separator:afc7a4db33108b5229941621a765bab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5926f34fe31fce7a2156e433704b421e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a5926f34fe31fce7a2156e433704b421e">is_executing_fail</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a5926f34fe31fce7a2156e433704b421e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the extension's main function is executing the fail_entry().  <a href="classmk_1_1ext__t.html#a5926f34fe31fce7a2156e433704b421e">More...</a><br /></td></tr>
<tr class="separator:a5926f34fe31fce7a2156e433704b421e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b648e247d3cda068dce52cd6255bec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a64b648e247d3cda068dce52cd6255bec">start</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a64b648e247d3cda068dce52cd6255bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the extension by executing it's _start entry point. If the extension has not been initialized, this function will return bsl::errc_success.  <a href="classmk_1_1ext__t.html#a64b648e247d3cda068dce52cd6255bec">More...</a><br /></td></tr>
<tr class="separator:a64b648e247d3cda068dce52cd6255bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fba92305f8839b38d73674e198cc36b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a7fba92305f8839b38d73674e198cc36b">fail</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, bsl::safe_u64 const &amp;errc, bsl::safe_u64 const &amp;addr) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a7fba92305f8839b38d73674e198cc36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success.  <a href="classmk_1_1ext__t.html#a7fba92305f8839b38d73674e198cc36b">More...</a><br /></td></tr>
<tr class="separator:a7fba92305f8839b38d73674e198cc36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3bcf5211228b7dbfa611ac95b2691e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a2c3bcf5211228b7dbfa611ac95b2691e">initialize</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, bsl::safe_u16 const &amp;i, <a class="el" href="namespaceloader.html#afd2bbbd3305d4d499c41035aee9f464e">loader::ext_elf_file_t</a> const *const file, <a class="el" href="namespacemk.html#a6eb130b521649a4ca56bb0f9902a2ce9">root_page_table_t</a> const &amp;system_rpt) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a2c3bcf5211228b7dbfa611ac95b2691e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>.  <a href="classmk_1_1ext__t.html#a2c3bcf5211228b7dbfa611ac95b2691e">More...</a><br /></td></tr>
<tr class="separator:a2c3bcf5211228b7dbfa611ac95b2691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0a8afc12cd71e8e01cc90a8da24510"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a8b0a8afc12cd71e8e01cc90a8da24510">release</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;mut_huge_pool) noexcept</td></tr>
<tr class="memdesc:a8b0a8afc12cd71e8e01cc90a8da24510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>.  <a href="classmk_1_1ext__t.html#a8b0a8afc12cd71e8e01cc90a8da24510">More...</a><br /></td></tr>
<tr class="separator:a8b0a8afc12cd71e8e01cc90a8da24510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71febf3b0b5482748ea2888290e38ba5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a71febf3b0b5482748ea2888290e38ba5">id</a> () const noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a71febf3b0b5482748ea2888290e38ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>.  <a href="classmk_1_1ext__t.html#a71febf3b0b5482748ea2888290e38ba5">More...</a><br /></td></tr>
<tr class="separator:a71febf3b0b5482748ea2888290e38ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fef348b1f48ed14c4a876b826d27b3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a41fef348b1f48ed14c4a876b826d27b3">bootstrap_ip</a> () const noexcept -&gt; bsl::safe_u64 const &amp;</td></tr>
<tr class="memdesc:a41fef348b1f48ed14c4a876b826d27b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bootstrap IP for this extension.  <a href="classmk_1_1ext__t.html#a41fef348b1f48ed14c4a876b826d27b3">More...</a><br /></td></tr>
<tr class="separator:a41fef348b1f48ed14c4a876b826d27b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada061ad9d0daa28ff0671f8ff476dfe4"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ada061ad9d0daa28ff0671f8ff476dfe4">set_bootstrap_ip</a> (bsl::safe_u64 const &amp;ip) noexcept</td></tr>
<tr class="memdesc:ada061ad9d0daa28ff0671f8ff476dfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bootstrap IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for bootstrapping.  <a href="classmk_1_1ext__t.html#ada061ad9d0daa28ff0671f8ff476dfe4">More...</a><br /></td></tr>
<tr class="separator:ada061ad9d0daa28ff0671f8ff476dfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f786394bb3a0f67a8a16d2129dc48d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a3f786394bb3a0f67a8a16d2129dc48d4">vmexit_ip</a> () const noexcept -&gt; bsl::safe_u64 const &amp;</td></tr>
<tr class="memdesc:a3f786394bb3a0f67a8a16d2129dc48d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the VMExit IP for this extension.  <a href="classmk_1_1ext__t.html#a3f786394bb3a0f67a8a16d2129dc48d4">More...</a><br /></td></tr>
<tr class="separator:a3f786394bb3a0f67a8a16d2129dc48d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b464832a9c4965fdfc28c8f9bbea1e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a42b464832a9c4965fdfc28c8f9bbea1e">set_vmexit_ip</a> (bsl::safe_u64 const &amp;ip) noexcept</td></tr>
<tr class="memdesc:a42b464832a9c4965fdfc28c8f9bbea1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the VMExit IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for VMExits.  <a href="classmk_1_1ext__t.html#a42b464832a9c4965fdfc28c8f9bbea1e">More...</a><br /></td></tr>
<tr class="separator:a42b464832a9c4965fdfc28c8f9bbea1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2582d4a3fe12cadce3803037742ba6f2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a2582d4a3fe12cadce3803037742ba6f2">fail_ip</a> () const noexcept -&gt; bsl::safe_u64 const &amp;</td></tr>
<tr class="memdesc:a2582d4a3fe12cadce3803037742ba6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fast fail IP for this extension.  <a href="classmk_1_1ext__t.html#a2582d4a3fe12cadce3803037742ba6f2">More...</a><br /></td></tr>
<tr class="separator:a2582d4a3fe12cadce3803037742ba6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a622306709740b624e6ad9904adf854"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a5a622306709740b624e6ad9904adf854">set_fail_ip</a> (bsl::safe_u64 const &amp;ip) noexcept</td></tr>
<tr class="memdesc:a5a622306709740b624e6ad9904adf854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fast fail IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for fail callbacks.  <a href="classmk_1_1ext__t.html#a5a622306709740b624e6ad9904adf854">More...</a><br /></td></tr>
<tr class="separator:a5a622306709740b624e6ad9904adf854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44de1469cd56addd3c5552809124298"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#aa44de1469cd56addd3c5552809124298">open_handle</a> () noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aa44de1469cd56addd3c5552809124298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a handle and returns the resulting handle.  <a href="classmk_1_1ext__t.html#aa44de1469cd56addd3c5552809124298">More...</a><br /></td></tr>
<tr class="separator:aa44de1469cd56addd3c5552809124298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f94a2264b704165a9fbed4f2df65295"><td class="memItemLeft" align="right" valign="top"><a id="a2f94a2264b704165a9fbed4f2df65295" name="a2f94a2264b704165a9fbed4f2df65295"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>close_handle</b> () noexcept</td></tr>
<tr class="memdesc:a2f94a2264b704165a9fbed4f2df65295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a previously opened handle. <br /></td></tr>
<tr class="separator:a2f94a2264b704165a9fbed4f2df65295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8602b26b1f23e0df761f32f8a0dd93"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a0d8602b26b1f23e0df761f32f8a0dd93">is_handle_valid</a> (bsl::safe_u64 const &amp;hndl) const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a0d8602b26b1f23e0df761f32f8a0dd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if provided handle is valid.  <a href="classmk_1_1ext__t.html#a0d8602b26b1f23e0df761f32f8a0dd93">More...</a><br /></td></tr>
<tr class="separator:a0d8602b26b1f23e0df761f32f8a0dd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00feac861b88d79d128ba456209d6ea0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a00feac861b88d79d128ba456209d6ea0">handle</a> () const noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a00feac861b88d79d128ba456209d6ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>.  <a href="classmk_1_1ext__t.html#a00feac861b88d79d128ba456209d6ea0">More...</a><br /></td></tr>
<tr class="separator:a00feac861b88d79d128ba456209d6ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7a4db33108b5229941621a765bab9d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#afc7a4db33108b5229941621a765bab9d">is_started</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:afc7a4db33108b5229941621a765bab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the extension's main function has completed it's execution.  <a href="classmk_1_1ext__t.html#afc7a4db33108b5229941621a765bab9d">More...</a><br /></td></tr>
<tr class="separator:afc7a4db33108b5229941621a765bab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5926f34fe31fce7a2156e433704b421e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a5926f34fe31fce7a2156e433704b421e">is_executing_fail</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a5926f34fe31fce7a2156e433704b421e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the extension's main function is executing the fail_entry().  <a href="classmk_1_1ext__t.html#a5926f34fe31fce7a2156e433704b421e">More...</a><br /></td></tr>
<tr class="separator:a5926f34fe31fce7a2156e433704b421e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba74760f7fc9d17743d41bbb6a52c96d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#aba74760f7fc9d17743d41bbb6a52c96d">alloc_page</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool) noexcept -&gt; <a class="el" href="namespacemk.html#a8fc2043a0267976ad3e3c5e1a56fd7ea">alloc_page_t</a></td></tr>
<tr class="memdesc:aba74760f7fc9d17743d41bbb6a52c96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a page and maps it into the extension's address space.  <a href="classmk_1_1ext__t.html#aba74760f7fc9d17743d41bbb6a52c96d">More...</a><br /></td></tr>
<tr class="separator:aba74760f7fc9d17743d41bbb6a52c96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767720272dea0d59990aa46045a52b57"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a767720272dea0d59990aa46045a52b57">alloc_huge</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;mut_huge_pool, bsl::safe_umx const &amp;size) noexcept -&gt; <a class="el" href="namespacemk.html#a2f376bdcbeef8c221143eb4b09529328">alloc_huge_t</a></td></tr>
<tr class="memdesc:a767720272dea0d59990aa46045a52b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a physically contiguous block of memory and maps it into the extension's address space.  <a href="classmk_1_1ext__t.html#a767720272dea0d59990aa46045a52b57">More...</a><br /></td></tr>
<tr class="separator:a767720272dea0d59990aa46045a52b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a37314e1ecbd347a8f64071468bbe7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a43a37314e1ecbd347a8f64071468bbe7">map_page_direct</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, bsl::safe_u16 const &amp;vmid, bsl::safe_u64 const &amp;page_phys) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a43a37314e1ecbd347a8f64071468bbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a page into the direct map portion of the requested VM's direct map RPT given a physical address to map.  <a href="classmk_1_1ext__t.html#a43a37314e1ecbd347a8f64071468bbe7">More...</a><br /></td></tr>
<tr class="separator:a43a37314e1ecbd347a8f64071468bbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5304a3614f5487faf3e1df346e64ad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a0b5304a3614f5487faf3e1df346e64ad">unmap_page_direct</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, bsl::safe_u16 const &amp;vmid, bsl::safe_u64 const &amp;page_virt) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a0b5304a3614f5487faf3e1df346e64ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps a page from the direct map portion of the requested VM's direct map RPT given a virtual address to unmap.  <a href="classmk_1_1ext__t.html#a0b5304a3614f5487faf3e1df346e64ad">More...</a><br /></td></tr>
<tr class="separator:a0b5304a3614f5487faf3e1df346e64ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dce674acd1d202af2bb6c3a94be5d9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a24dce674acd1d202af2bb6c3a94be5d9">signal_vm_created</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a24dce674acd1d202af2bb6c3a94be5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the extension that a VM was created so that it can initialize it's VM specific resources.  <a href="classmk_1_1ext__t.html#a24dce674acd1d202af2bb6c3a94be5d9">More...</a><br /></td></tr>
<tr class="separator:a24dce674acd1d202af2bb6c3a94be5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b546cb83d50158a4c9384ba34ed1c6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ae6b546cb83d50158a4c9384ba34ed1c6">signal_vm_destroyed</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, bsl::safe_u16 const &amp;vmid) noexcept</td></tr>
<tr class="memdesc:ae6b546cb83d50158a4c9384ba34ed1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the extension that a VM was destroyed so that it can release it's VM specific resources.  <a href="classmk_1_1ext__t.html#ae6b546cb83d50158a4c9384ba34ed1c6">More...</a><br /></td></tr>
<tr class="separator:ae6b546cb83d50158a4c9384ba34ed1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a30067b8d25af7175f4ade35675c648"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a4a30067b8d25af7175f4ade35675c648">signal_vm_active</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, bsl::safe_u16 const &amp;vmid) noexcept</td></tr>
<tr class="memdesc:a4a30067b8d25af7175f4ade35675c648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the extension that the requested VM was set to active and therefore it's memory map should change on this PP.  <a href="classmk_1_1ext__t.html#a4a30067b8d25af7175f4ade35675c648">More...</a><br /></td></tr>
<tr class="separator:a4a30067b8d25af7175f4ade35675c648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32c3c96fd768fa7a056ca58417a51ee"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ac32c3c96fd768fa7a056ca58417a51ee">start</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ac32c3c96fd768fa7a056ca58417a51ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the extension by executing it's _start entry point. If the extension has not been initialized, this function will return bsl::errc_success.  <a href="classmk_1_1ext__t.html#ac32c3c96fd768fa7a056ca58417a51ee">More...</a><br /></td></tr>
<tr class="separator:ac32c3c96fd768fa7a056ca58417a51ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10b7e991b38b0c4fd0188012e6f1614"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#aa10b7e991b38b0c4fd0188012e6f1614">bootstrap</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa10b7e991b38b0c4fd0188012e6f1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success.  <a href="classmk_1_1ext__t.html#aa10b7e991b38b0c4fd0188012e6f1614">More...</a><br /></td></tr>
<tr class="separator:aa10b7e991b38b0c4fd0188012e6f1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e7d0bce384caefbfca04e04be34787"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a60e7d0bce384caefbfca04e04be34787">vmexit</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, bsl::safe_u64 const &amp;exit_reason) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a60e7d0bce384caefbfca04e04be34787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success.  <a href="classmk_1_1ext__t.html#a60e7d0bce384caefbfca04e04be34787">More...</a><br /></td></tr>
<tr class="separator:a60e7d0bce384caefbfca04e04be34787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315e6a1b71aeff4b0467f60606b2fdbc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a315e6a1b71aeff4b0467f60606b2fdbc">fail</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, bsl::safe_u64 const &amp;errc, bsl::safe_u64 const &amp;addr) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a315e6a1b71aeff4b0467f60606b2fdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success.  <a href="classmk_1_1ext__t.html#a315e6a1b71aeff4b0467f60606b2fdbc">More...</a><br /></td></tr>
<tr class="separator:a315e6a1b71aeff4b0467f60606b2fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b6830dd71ec52c24ea5e63b88f3138"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ad0b6830dd71ec52c24ea5e63b88f3138">dump</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) const noexcept</td></tr>
<tr class="memdesc:ad0b6830dd71ec52c24ea5e63b88f3138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the <a class="el" href="classmk_1_1vm__t.html" title="Defines the microkernel&#39;s notion of a VM.">vm_t</a>.  <a href="classmk_1_1ext__t.html#ad0b6830dd71ec52c24ea5e63b88f3138">More...</a><br /></td></tr>
<tr class="separator:ad0b6830dd71ec52c24ea5e63b88f3138"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad16eb531a37b65c4b9bca28e458f8f79"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ad16eb531a37b65c4b9bca28e458f8f79">alloc_page</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool) noexcept -&gt; <a class="el" href="namespacemk.html#a8fc2043a0267976ad3e3c5e1a56fd7ea">alloc_page_t</a></td></tr>
<tr class="memdesc:ad16eb531a37b65c4b9bca28e458f8f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a page and maps it into the extension's address space.  <a href="classmk_1_1ext__t.html#ad16eb531a37b65c4b9bca28e458f8f79">More...</a><br /></td></tr>
<tr class="separator:ad16eb531a37b65c4b9bca28e458f8f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2330c2143dc1e26c24c317154db0f25"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ac2330c2143dc1e26c24c317154db0f25">alloc_huge</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool, <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> const &amp;huge_pool, bsl::safe_umx const &amp;size) noexcept -&gt; <a class="el" href="namespacemk.html#a2f376bdcbeef8c221143eb4b09529328">alloc_huge_t</a></td></tr>
<tr class="memdesc:ac2330c2143dc1e26c24c317154db0f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a physically contiguous block of memory and maps it into the extension's address space.  <a href="classmk_1_1ext__t.html#ac2330c2143dc1e26c24c317154db0f25">More...</a><br /></td></tr>
<tr class="separator:ac2330c2143dc1e26c24c317154db0f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30195335e479458a28ea2f37e3483659"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a30195335e479458a28ea2f37e3483659">map_page_direct</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool, bsl::safe_u16 const &amp;vmid, bsl::safe_u64 const &amp;page_phys) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a30195335e479458a28ea2f37e3483659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a page into the direct map portion of the requested VM's direct map RPT given a physical address to map.  <a href="classmk_1_1ext__t.html#a30195335e479458a28ea2f37e3483659">More...</a><br /></td></tr>
<tr class="separator:a30195335e479458a28ea2f37e3483659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad663d3cc8de8bd1b5a2d89769c22b2b2"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ad663d3cc8de8bd1b5a2d89769c22b2b2">unmap_page_direct</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, bsl::safe_u16 const &amp;vmid, bsl::safe_u64 const &amp;page_virt) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ad663d3cc8de8bd1b5a2d89769c22b2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps a page from the direct map portion of the requested VM's direct map RPT given a virtual address to unmap.  <a href="classmk_1_1ext__t.html#ad663d3cc8de8bd1b5a2d89769c22b2b2">More...</a><br /></td></tr>
<tr class="separator:ad663d3cc8de8bd1b5a2d89769c22b2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00135441f0ce0b3e0a6ae2178074aeb1"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a00135441f0ce0b3e0a6ae2178074aeb1">signal_vm_created</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool, bsl::safe_u16 const &amp;vmid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a00135441f0ce0b3e0a6ae2178074aeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the extension that a VM was created so that it can initialize it's VM specific resources.  <a href="classmk_1_1ext__t.html#a00135441f0ce0b3e0a6ae2178074aeb1">More...</a><br /></td></tr>
<tr class="separator:a00135441f0ce0b3e0a6ae2178074aeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf52274b52ddbdd95cb95aff84ec6883"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#adf52274b52ddbdd95cb95aff84ec6883">signal_vm_destroyed</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool, bsl::safe_u16 const &amp;vmid) noexcept</td></tr>
<tr class="memdesc:adf52274b52ddbdd95cb95aff84ec6883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the extension that a VM was destroyed so that it can release it's VM specific resources.  <a href="classmk_1_1ext__t.html#adf52274b52ddbdd95cb95aff84ec6883">More...</a><br /></td></tr>
<tr class="separator:adf52274b52ddbdd95cb95aff84ec6883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91aa7de437711944048df49d78060c9"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ab91aa7de437711944048df49d78060c9">signal_vm_active</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, bsl::safe_u16 const &amp;vmid) noexcept</td></tr>
<tr class="memdesc:ab91aa7de437711944048df49d78060c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the extension that the requested VM was set to active and therefore it's memory map should change on this PP.  <a href="classmk_1_1ext__t.html#ab91aa7de437711944048df49d78060c9">More...</a><br /></td></tr>
<tr class="separator:ab91aa7de437711944048df49d78060c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a6743cfe19ea3bc2db13fdabad0cc6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a24a6743cfe19ea3bc2db13fdabad0cc6">bootstrap</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a24a6743cfe19ea3bc2db13fdabad0cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success.  <a href="classmk_1_1ext__t.html#a24a6743cfe19ea3bc2db13fdabad0cc6">More...</a><br /></td></tr>
<tr class="separator:a24a6743cfe19ea3bc2db13fdabad0cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83504912febe70622e5eb7489f1c35f5"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#a83504912febe70622e5eb7489f1c35f5">vmexit</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, bsl::safe_u64 const &amp;exit_reason) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a83504912febe70622e5eb7489f1c35f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success.  <a href="classmk_1_1ext__t.html#a83504912febe70622e5eb7489f1c35f5">More...</a><br /></td></tr>
<tr class="separator:a83504912febe70622e5eb7489f1c35f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6c538419d4b706225fb3a615f9e119"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html#ace6c538419d4b706225fb3a615f9e119">dump</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) noexcept</td></tr>
<tr class="memdesc:ace6c538419d4b706225fb3a615f9e119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the <a class="el" href="classmk_1_1vm__t.html" title="Defines the microkernel&#39;s notion of a VM.">vm_t</a>.  <a href="classmk_1_1ext__t.html#ace6c538419d4b706225fb3a615f9e119">More...</a><br /></td></tr>
<tr class="separator:ace6c538419d4b706225fb3a615f9e119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to do so. This class also maintains all of the resources given to an extension, as well as the extension's memory map, ELF file, stack, TLS blocks, and all of it's memory map functions. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a258a800a5eca55cdd7a2317c6ccb12f6" name="a258a800a5eca55cdd7a2317c6ccb12f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258a800a5eca55cdd7a2317c6ccb12f6">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceloader.html#afd2bbbd3305d4d499c41035aee9f464e">loader::ext_elf_file_t</a> const *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#a6eb130b521649a4ca56bb0f9902a2ce9">root_page_table_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>system_rpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">i</td><td>the ID for this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a> </td></tr>
    <tr><td class="paramname">file</td><td>the ELF file for this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a> </td></tr>
    <tr><td class="paramname">system_rpt</td><td>the system RPT provided by the loader </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a481fef4d3a96bfe4f69bd3588e9fc238" name="a481fef4d3a96bfe4f69bd3588e9fc238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481fef4d3a96bfe4f69bd3588e9fc238">&#9670;&nbsp;</a></span>release() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>huge_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">huge_pool</td><td>the <a class="el" href="classmk_1_1huge__pool__t.html" title="The huge pool provides access to physically contiguous memory. The amount of memory that is available...">huge_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71febf3b0b5482748ea2888290e38ba5" name="a71febf3b0b5482748ea2888290e38ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71febf3b0b5482748ea2888290e38ba5">&#9670;&nbsp;</a></span>id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a> </dd></dl>

</div>
</div>
<a id="a41fef348b1f48ed14c4a876b826d27b3" name="a41fef348b1f48ed14c4a876b826d27b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fef348b1f48ed14c4a876b826d27b3">&#9670;&nbsp;</a></span>bootstrap_ip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::bootstrap_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64 const &amp;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bootstrap IP for this extension. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the bootstrap IP for this extension. </dd></dl>

</div>
</div>
<a id="ada061ad9d0daa28ff0671f8ff476dfe4" name="ada061ad9d0daa28ff0671f8ff476dfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada061ad9d0daa28ff0671f8ff476dfe4">&#9670;&nbsp;</a></span>set_bootstrap_ip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::set_bootstrap_ip </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bootstrap IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for bootstrapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>the bootstrap IP to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f786394bb3a0f67a8a16d2129dc48d4" name="a3f786394bb3a0f67a8a16d2129dc48d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f786394bb3a0f67a8a16d2129dc48d4">&#9670;&nbsp;</a></span>vmexit_ip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::vmexit_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64 const &amp;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the VMExit IP for this extension. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the VMExit IP for this extension. </dd></dl>

</div>
</div>
<a id="a42b464832a9c4965fdfc28c8f9bbea1e" name="a42b464832a9c4965fdfc28c8f9bbea1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b464832a9c4965fdfc28c8f9bbea1e">&#9670;&nbsp;</a></span>set_vmexit_ip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::set_vmexit_ip </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the VMExit IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for VMExits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>the VMExit IP to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2582d4a3fe12cadce3803037742ba6f2" name="a2582d4a3fe12cadce3803037742ba6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2582d4a3fe12cadce3803037742ba6f2">&#9670;&nbsp;</a></span>fail_ip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::fail_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64 const &amp;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fast fail IP for this extension. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the fast fail IP for this extension. </dd></dl>

</div>
</div>
<a id="a5a622306709740b624e6ad9904adf854" name="a5a622306709740b624e6ad9904adf854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a622306709740b624e6ad9904adf854">&#9670;&nbsp;</a></span>set_fail_ip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::set_fail_ip </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the fast fail IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for fail callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>the fail IP to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa44de1469cd56addd3c5552809124298" name="aa44de1469cd56addd3c5552809124298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44de1469cd56addd3c5552809124298">&#9670;&nbsp;</a></span>open_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::open_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a handle and returns the resulting handle. </p>
<dl class="section return"><dt>Returns</dt><dd>Opens a handle and returns the resulting handle </dd></dl>

</div>
</div>
<a id="a0d8602b26b1f23e0df761f32f8a0dd93" name="a0d8602b26b1f23e0df761f32f8a0dd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8602b26b1f23e0df761f32f8a0dd93">&#9670;&nbsp;</a></span>is_handle_valid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::is_handle_valid </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>hndl</em></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if provided handle is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl</td><td>the handle to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if provided handle is valid </dd></dl>

</div>
</div>
<a id="a00feac861b88d79d128ba456209d6ea0" name="a00feac861b88d79d128ba456209d6ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00feac861b88d79d128ba456209d6ea0">&#9670;&nbsp;</a></span>handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a> </dd></dl>

</div>
</div>
<a id="afc7a4db33108b5229941621a765bab9d" name="afc7a4db33108b5229941621a765bab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7a4db33108b5229941621a765bab9d">&#9670;&nbsp;</a></span>is_started() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::is_started </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the extension's main function has completed it's execution. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the extension's main function has completed it's execution. </dd></dl>

</div>
</div>
<a id="a5926f34fe31fce7a2156e433704b421e" name="a5926f34fe31fce7a2156e433704b421e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5926f34fe31fce7a2156e433704b421e">&#9670;&nbsp;</a></span>is_executing_fail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::is_executing_fail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the extension's main function is executing the fail_entry(). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the extension's main function is executing the fail_entry(). </dd></dl>

</div>
</div>
<a id="ad16eb531a37b65c4b9bca28e458f8f79" name="ad16eb531a37b65c4b9bca28e458f8f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16eb531a37b65c4b9bca28e458f8f79">&#9670;&nbsp;</a></span>alloc_page() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto mk::ext_t::alloc_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacemk.html#a8fc2043a0267976ad3e3c5e1a56fd7ea">alloc_page_t</a>
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a page and maps it into the extension's address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a alloc_page_t containing the virtual address and physical address of the page. If an error occurs, this function will return an invalid virtual and physical address. </dd></dl>

</div>
</div>
<a id="ac2330c2143dc1e26c24c317154db0f25" name="ac2330c2143dc1e26c24c317154db0f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2330c2143dc1e26c24c317154db0f25">&#9670;&nbsp;</a></span>alloc_huge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto mk::ext_t::alloc_huge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>huge_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacemk.html#a2f376bdcbeef8c221143eb4b09529328">alloc_huge_t</a>
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a physically contiguous block of memory and maps it into the extension's address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">huge_pool</td><td>the <a class="el" href="classmk_1_1huge__pool__t.html" title="The huge pool provides access to physically contiguous memory. The amount of memory that is available...">huge_pool_t</a> to use </td></tr>
    <tr><td class="paramname">size</td><td>the total number of bytes to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a huge_t containing the virtual address and physical address of the memory block. If an error occurs, this function will return an invalid virtual and physical address. </dd></dl>

</div>
</div>
<a id="a30195335e479458a28ea2f37e3483659" name="a30195335e479458a28ea2f37e3483659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30195335e479458a28ea2f37e3483659">&#9670;&nbsp;</a></span>map_page_direct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto mk::ext_t::map_page_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>page_phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a page into the direct map portion of the requested VM's direct map RPT given a physical address to map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM to map page_phys to </td></tr>
    <tr><td class="paramname">page_phys</td><td>the physical address to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the virtual address the physical address was mapped to in the direct map. On failure returns bsl::safe_u64::failure(). </dd></dl>

</div>
</div>
<a id="ad663d3cc8de8bd1b5a2d89769c22b2b2" name="ad663d3cc8de8bd1b5a2d89769c22b2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad663d3cc8de8bd1b5a2d89769c22b2b2">&#9670;&nbsp;</a></span>unmap_page_direct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto mk::ext_t::unmap_page_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>page_virt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps a page from the direct map portion of the requested VM's direct map RPT given a virtual address to unmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM to unmap page_virt to </td></tr>
    <tr><td class="paramname">page_virt</td><td>the virtual address to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a00135441f0ce0b3e0a6ae2178074aeb1" name="a00135441f0ce0b3e0a6ae2178074aeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00135441f0ce0b3e0a6ae2178074aeb1">&#9670;&nbsp;</a></span>signal_vm_created() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto mk::ext_t::signal_vm_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the extension that a VM was created so that it can initialize it's VM specific resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM that was created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="adf52274b52ddbdd95cb95aff84ec6883" name="adf52274b52ddbdd95cb95aff84ec6883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf52274b52ddbdd95cb95aff84ec6883">&#9670;&nbsp;</a></span>signal_vm_destroyed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void mk::ext_t::signal_vm_destroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the extension that a VM was destroyed so that it can release it's VM specific resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM that was destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab91aa7de437711944048df49d78060c9" name="ab91aa7de437711944048df49d78060c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91aa7de437711944048df49d78060c9">&#9670;&nbsp;</a></span>signal_vm_active() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void mk::ext_t::signal_vm_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the extension that the requested VM was set to active and therefore it's memory map should change on this PP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM that was created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b648e247d3cda068dce52cd6255bec" name="a64b648e247d3cda068dce52cd6255bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b648e247d3cda068dce52cd6255bec">&#9670;&nbsp;</a></span>start() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the extension by executing it's _start entry point. If the extension has not been initialized, this function will return bsl::errc_success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a24a6743cfe19ea3bc2db13fdabad0cc6" name="a24a6743cfe19ea3bc2db13fdabad0cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a6743cfe19ea3bc2db13fdabad0cc6">&#9670;&nbsp;</a></span>bootstrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto mk::ext_t::bootstrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a83504912febe70622e5eb7489f1c35f5" name="a83504912febe70622e5eb7489f1c35f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83504912febe70622e5eb7489f1c35f5">&#9670;&nbsp;</a></span>vmexit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto mk::ext_t::vmexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>exit_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">exit_reason</td><td>the reason for the VMExit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a7fba92305f8839b38d73674e198cc36b" name="a7fba92305f8839b38d73674e198cc36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fba92305f8839b38d73674e198cc36b">&#9670;&nbsp;</a></span>fail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::fail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>errc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">errc</td><td>the reason for the failure, which is CPU specific. On x86, this is a combination of the exception vector and error code. </td></tr>
    <tr><td class="paramname">addr</td><td>contains a faulting address if the fail reason is associated with an error that involves a faulting address ( for example like a page fault). Otherwise, the value of this input is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="ace6c538419d4b706225fb3a615f9e119" name="ace6c538419d4b706225fb3a615f9e119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6c538419d4b706225fb3a615f9e119">&#9670;&nbsp;</a></span>dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void mk::ext_t::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps the <a class="el" href="classmk_1_1vm__t.html" title="Defines the microkernel&#39;s notion of a VM.">vm_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3bcf5211228b7dbfa611ac95b2691e" name="a2c3bcf5211228b7dbfa611ac95b2691e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3bcf5211228b7dbfa611ac95b2691e">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceloader.html#afd2bbbd3305d4d499c41035aee9f464e">loader::ext_elf_file_t</a> const *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#a6eb130b521649a4ca56bb0f9902a2ce9">root_page_table_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>system_rpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">i</td><td>the ID for this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a> </td></tr>
    <tr><td class="paramname">file</td><td>the ELF file for this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a> </td></tr>
    <tr><td class="paramname">system_rpt</td><td>the system RPT provided by the loader </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a8b0a8afc12cd71e8e01cc90a8da24510" name="a8b0a8afc12cd71e8e01cc90a8da24510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0a8afc12cd71e8e01cc90a8da24510">&#9670;&nbsp;</a></span>release() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_huge_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_huge_pool</td><td>the <a class="el" href="classmk_1_1huge__pool__t.html" title="The huge pool provides access to physically contiguous memory. The amount of memory that is available...">huge_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71febf3b0b5482748ea2888290e38ba5" name="a71febf3b0b5482748ea2888290e38ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71febf3b0b5482748ea2888290e38ba5">&#9670;&nbsp;</a></span>id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u16
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a> </dd></dl>

</div>
</div>
<a id="a41fef348b1f48ed14c4a876b826d27b3" name="a41fef348b1f48ed14c4a876b826d27b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fef348b1f48ed14c4a876b826d27b3">&#9670;&nbsp;</a></span>bootstrap_ip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::bootstrap_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64 const &amp;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bootstrap IP for this extension. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the bootstrap IP for this extension. </dd></dl>

</div>
</div>
<a id="ada061ad9d0daa28ff0671f8ff476dfe4" name="ada061ad9d0daa28ff0671f8ff476dfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada061ad9d0daa28ff0671f8ff476dfe4">&#9670;&nbsp;</a></span>set_bootstrap_ip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::set_bootstrap_ip </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bootstrap IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for bootstrapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>the bootstrap IP to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f786394bb3a0f67a8a16d2129dc48d4" name="a3f786394bb3a0f67a8a16d2129dc48d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f786394bb3a0f67a8a16d2129dc48d4">&#9670;&nbsp;</a></span>vmexit_ip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::vmexit_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64 const &amp;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the VMExit IP for this extension. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the VMExit IP for this extension. </dd></dl>

</div>
</div>
<a id="a42b464832a9c4965fdfc28c8f9bbea1e" name="a42b464832a9c4965fdfc28c8f9bbea1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b464832a9c4965fdfc28c8f9bbea1e">&#9670;&nbsp;</a></span>set_vmexit_ip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::set_vmexit_ip </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the VMExit IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for VMExits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>the VMExit IP to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2582d4a3fe12cadce3803037742ba6f2" name="a2582d4a3fe12cadce3803037742ba6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2582d4a3fe12cadce3803037742ba6f2">&#9670;&nbsp;</a></span>fail_ip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::fail_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64 const &amp;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fast fail IP for this extension. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the fast fail IP for this extension. </dd></dl>

</div>
</div>
<a id="a5a622306709740b624e6ad9904adf854" name="a5a622306709740b624e6ad9904adf854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a622306709740b624e6ad9904adf854">&#9670;&nbsp;</a></span>set_fail_ip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::set_fail_ip </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the fast fail IP for this extension. This should be called by the syscall dispatcher as the result of a syscall from the extension defining what IP the extension would like to use for fail callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>the fail IP to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa44de1469cd56addd3c5552809124298" name="aa44de1469cd56addd3c5552809124298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44de1469cd56addd3c5552809124298">&#9670;&nbsp;</a></span>open_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::open_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a handle and returns the resulting handle. </p>
<dl class="section return"><dt>Returns</dt><dd>Opens a handle and returns the resulting handle </dd></dl>

</div>
</div>
<a id="a0d8602b26b1f23e0df761f32f8a0dd93" name="a0d8602b26b1f23e0df761f32f8a0dd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8602b26b1f23e0df761f32f8a0dd93">&#9670;&nbsp;</a></span>is_handle_valid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::is_handle_valid </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>hndl</em></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if provided handle is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl</td><td>the handle to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if provided handle is valid </dd></dl>

</div>
</div>
<a id="a00feac861b88d79d128ba456209d6ea0" name="a00feac861b88d79d128ba456209d6ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00feac861b88d79d128ba456209d6ea0">&#9670;&nbsp;</a></span>handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the ID of this <a class="el" href="classmk_1_1ext__t.html" title="Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to d...">ext_t</a> </dd></dl>

</div>
</div>
<a id="afc7a4db33108b5229941621a765bab9d" name="afc7a4db33108b5229941621a765bab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7a4db33108b5229941621a765bab9d">&#9670;&nbsp;</a></span>is_started() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::is_started </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the extension's main function has completed it's execution. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the extension's main function has completed it's execution. </dd></dl>

</div>
</div>
<a id="a5926f34fe31fce7a2156e433704b421e" name="a5926f34fe31fce7a2156e433704b421e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5926f34fe31fce7a2156e433704b421e">&#9670;&nbsp;</a></span>is_executing_fail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::is_executing_fail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the extension's main function is executing the fail_entry(). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the extension's main function is executing the fail_entry(). </dd></dl>

</div>
</div>
<a id="aba74760f7fc9d17743d41bbb6a52c96d" name="aba74760f7fc9d17743d41bbb6a52c96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba74760f7fc9d17743d41bbb6a52c96d">&#9670;&nbsp;</a></span>alloc_page() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::alloc_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacemk.html#a8fc2043a0267976ad3e3c5e1a56fd7ea">alloc_page_t</a>
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a page and maps it into the extension's address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a alloc_page_t containing the virtual address and physical address of the page. If an error occurs, this function will return an invalid virtual and physical address. </dd></dl>

</div>
</div>
<a id="a767720272dea0d59990aa46045a52b57" name="a767720272dea0d59990aa46045a52b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767720272dea0d59990aa46045a52b57">&#9670;&nbsp;</a></span>alloc_huge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::alloc_huge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_huge_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacemk.html#a2f376bdcbeef8c221143eb4b09529328">alloc_huge_t</a>
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a physically contiguous block of memory and maps it into the extension's address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_huge_pool</td><td>the <a class="el" href="classmk_1_1huge__pool__t.html" title="The huge pool provides access to physically contiguous memory. The amount of memory that is available...">huge_pool_t</a> to use </td></tr>
    <tr><td class="paramname">size</td><td>the total number of bytes to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a huge_t containing the virtual address and physical address of the memory block. If an error occurs, this function will return an invalid virtual and physical address. </dd></dl>
<p >TODO:</p><ul>
<li>We really should register the allocation at the end of this function, and on failure, we would just call free_huge() so that all of the memory can be unmapped and deallocated there. By registering here, if the map() below fails, we are not leaking memory, but the allocation is lost and can never be used again.</li>
<li>For now this works because if the allocation fails, there likely is no way to recover anyways as this is such a limited resource, but if free_huge() is ever implemented, this should be changed to "undo" what was done here so that the huge allocation can be used in the future.</li>
</ul>
<p >NOTE:</p><ul>
<li>Huge allocations come from the kernel's direct map, which is the same size as the extension's direct map, something that is validated by CMake. As a result, the virtual and physical addresses below can never overflow which is why they are marked as checked().</li>
</ul>

</div>
</div>
<a id="a43a37314e1ecbd347a8f64071468bbe7" name="a43a37314e1ecbd347a8f64071468bbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a37314e1ecbd347a8f64071468bbe7">&#9670;&nbsp;</a></span>map_page_direct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::map_page_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>page_phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u64
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a page into the direct map portion of the requested VM's direct map RPT given a physical address to map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM to map page_phys to </td></tr>
    <tr><td class="paramname">page_phys</td><td>the physical address to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the virtual address the physical address was mapped to in the direct map. On failure returns bsl::safe_u64::failure(). </dd></dl>
<p >NOTE:</p><ul>
<li>CMake ensures that the addr and size make sense which is why the following is marked as checked.</li>
</ul>

</div>
</div>
<a id="a0b5304a3614f5487faf3e1df346e64ad" name="a0b5304a3614f5487faf3e1df346e64ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5304a3614f5487faf3e1df346e64ad">&#9670;&nbsp;</a></span>unmap_page_direct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::unmap_page_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>page_virt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps a page from the direct map portion of the requested VM's direct map RPT given a virtual address to unmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM to unmap page_virt to </td></tr>
    <tr><td class="paramname">page_virt</td><td>the virtual address to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a24dce674acd1d202af2bb6c3a94be5d9" name="a24dce674acd1d202af2bb6c3a94be5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dce674acd1d202af2bb6c3a94be5d9">&#9670;&nbsp;</a></span>signal_vm_created() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::signal_vm_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the extension that a VM was created so that it can initialize it's VM specific resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM that was created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="ae6b546cb83d50158a4c9384ba34ed1c6" name="ae6b546cb83d50158a4c9384ba34ed1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b546cb83d50158a4c9384ba34ed1c6">&#9670;&nbsp;</a></span>signal_vm_destroyed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::signal_vm_destroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the extension that a VM was destroyed so that it can release it's VM specific resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM that was destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a30067b8d25af7175f4ade35675c648" name="a4a30067b8d25af7175f4ade35675c648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a30067b8d25af7175f4ade35675c648">&#9670;&nbsp;</a></span>signal_vm_active() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::signal_vm_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the extension that the requested VM was set to active and therefore it's memory map should change on this PP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM that was created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac32c3c96fd768fa7a056ca58417a51ee" name="ac32c3c96fd768fa7a056ca58417a51ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32c3c96fd768fa7a056ca58417a51ee">&#9670;&nbsp;</a></span>start() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the extension by executing it's _start entry point. If the extension has not been initialized, this function will return bsl::errc_success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="aa10b7e991b38b0c4fd0188012e6f1614" name="aa10b7e991b38b0c4fd0188012e6f1614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10b7e991b38b0c4fd0188012e6f1614">&#9670;&nbsp;</a></span>bootstrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::bootstrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a60e7d0bce384caefbfca04e04be34787" name="a60e7d0bce384caefbfca04e04be34787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e7d0bce384caefbfca04e04be34787">&#9670;&nbsp;</a></span>vmexit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::vmexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>exit_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">exit_reason</td><td>the reason for the VMExit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a315e6a1b71aeff4b0467f60606b2fdbc" name="a315e6a1b71aeff4b0467f60606b2fdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315e6a1b71aeff4b0467f60606b2fdbc">&#9670;&nbsp;</a></span>fail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::ext_t::fail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>errc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bootstraps the extension by executing it's bootstrap entry point. If the extension has not been initialized, this function will return bsl::errc_success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">errc</td><td>the reason for the failure, which is CPU specific. On x86, this is a combination of the exception vector and error code. </td></tr>
    <tr><td class="paramname">addr</td><td>contains a faulting address if the fail reason is associated with an error that involves a faulting address ( for example like a page fault). Otherwise, the value of this input is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="ad0b6830dd71ec52c24ea5e63b88f3138" name="ad0b6830dd71ec52c24ea5e63b88f3138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b6830dd71ec52c24ea5e63b88f3138">&#9670;&nbsp;</a></span>dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::ext_t::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps the <a class="el" href="classmk_1_1vm__t.html" title="Defines the microkernel&#39;s notion of a VM.">vm_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<p >Header</p>
<p >Started</p>
<p >Active</p>
<p >Entry IP</p>
<p >Bootstrap IP</p>
<p >VMExit IP</p>
<p >Fail IP</p>
<p >Handle</p>
<p >Footer</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>kernel/mocks/<a class="el" href="mocks_2ext__t_8hpp_source.html">ext_t.hpp</a></li>
<li>kernel/src/<a class="el" href="src_2ext__t_8hpp_source.html">ext_t.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemk.html">mk</a></li><li class="navelem"><a class="el" href="classmk_1_1ext__t.html">ext_t</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
