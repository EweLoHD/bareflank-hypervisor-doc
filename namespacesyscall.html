<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank Hypervisor: syscall Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bareflank Hypervisor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacesyscall.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">syscall Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs, please see the Microkernel ABI Specification.  <a href="classsyscall_1_1bf__syscall__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the extension's Global Storage (GS). Extensions can use this to store global variables as needed. The <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> can also be used during unit testing to store testing specific logic and data to ensure tests can support constexpr style unit testing. Also note that this is stored in the arch specific folders as it usually needs to store arch specific resources.  <a href="structsyscall_1_1gs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a means for the rest of the extension to mock the intrinsics when needed during testing.  <a href="classsyscall_1_1intrinsic__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the extension's Thread Local Storage (TLS). Extensions can use this to store data specific to a PP as needed. The <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> can also be used during unit testing to store testing specific logic and data to ensure tests can support constexpr style unit testing. Also note that this is stored in the arch specific folders as it usually needs to store arch specific resources. In this simple example, we leave this empty.  <a href="structsyscall_1_1tls__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the extension's VP pool.  <a href="classsyscall_1_1vp__pool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1vp__t.html">vp_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the extension's notion of a VP.  <a href="classsyscall_1_1vp__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the extension's VS pool.  <a href="classsyscall_1_1vs__pool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyscall_1_1vs__t.html">vs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the extension's notion of a VS.  <a href="classsyscall_1_1vs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a45caef8d358f490607e0a1cdfad47301"><td class="memItemLeft" align="right" valign="top"><a id="a45caef8d358f490607e0a1cdfad47301" name="a45caef8d358f490607e0a1cdfad47301"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocated_status_t</b> = lib::basic_allocated_status_t</td></tr>
<tr class="memdesc:a45caef8d358f490607e0a1cdfad47301"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the allocated_status_t used by the example <br /></td></tr>
<tr class="separator:a45caef8d358f490607e0a1cdfad47301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff656f855682219bc041987b2818817c"><td class="memItemLeft" align="right" valign="top"><a id="aff656f855682219bc041987b2818817c" name="aff656f855682219bc041987b2818817c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>page_4k_t</b> = lib::basic_page_4k_t</td></tr>
<tr class="memdesc:aff656f855682219bc041987b2818817c"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the page_4k_t used by the microkernel <br /></td></tr>
<tr class="separator:aff656f855682219bc041987b2818817c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daf39a20babe9761034a4d005632ff0"><td class="memItemLeft" align="right" valign="top"><a id="a5daf39a20babe9761034a4d005632ff0" name="a5daf39a20babe9761034a4d005632ff0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bf_status_t</b> = bsl::safe_u64</td></tr>
<tr class="memdesc:a5daf39a20babe9761034a4d005632ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type used for returning status from a function. <br /></td></tr>
<tr class="separator:a5daf39a20babe9761034a4d005632ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5384db1d6d8a0b23754219e5ab09af"><td class="memItemLeft" align="right" valign="top"><a id="ade5384db1d6d8a0b23754219e5ab09af" name="ade5384db1d6d8a0b23754219e5ab09af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bf_callback_handler_bootstrap_t</b> = void(*)(bsl::uint16)</td></tr>
<tr class="memdesc:ade5384db1d6d8a0b23754219e5ab09af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the signature of the bootstrap callback handler. <br /></td></tr>
<tr class="separator:ade5384db1d6d8a0b23754219e5ab09af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e24a9c2a154fcf5ac59d3f0164b567b"><td class="memItemLeft" align="right" valign="top"><a id="a6e24a9c2a154fcf5ac59d3f0164b567b" name="a6e24a9c2a154fcf5ac59d3f0164b567b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bf_callback_handler_vmexit_t</b> = void(*)(bsl::uint16, bsl::uint64)</td></tr>
<tr class="memdesc:a6e24a9c2a154fcf5ac59d3f0164b567b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the signature of the VM exit callback handler. <br /></td></tr>
<tr class="separator:a6e24a9c2a154fcf5ac59d3f0164b567b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d84fbe0f1de9ccdb58661d7850fac82"><td class="memItemLeft" align="right" valign="top"><a id="a8d84fbe0f1de9ccdb58661d7850fac82" name="a8d84fbe0f1de9ccdb58661d7850fac82"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bf_callback_handler_fail_t</b> = void(*)(bsl::uint64, bsl::uint64)</td></tr>
<tr class="memdesc:a8d84fbe0f1de9ccdb58661d7850fac82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the signature of the fast fail callback handler. <br /></td></tr>
<tr class="separator:a8d84fbe0f1de9ccdb58661d7850fac82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09987ca6e3a07ade94f63591d8bd1238"><td class="memItemLeft" align="right" valign="top"><a id="a09987ca6e3a07ade94f63591d8bd1238" name="a09987ca6e3a07ade94f63591d8bd1238"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>page_t</b> = lib::basic_page_4k_t</td></tr>
<tr class="separator:a09987ca6e3a07ade94f63591d8bd1238"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a88e3c7a4f139e3d2c85be4c8b8fc90b9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> : bsl::uint64 { <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489">bf_reg_t_unsupported</a> = static_cast&lt;bsl::uint64&gt;(0)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7">bf_reg_t_rbx</a> = static_cast&lt;bsl::uint64&gt;(1)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84">bf_reg_t_rcx</a> = static_cast&lt;bsl::uint64&gt;(2)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b">bf_reg_t_rdx</a> = static_cast&lt;bsl::uint64&gt;(3)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4">bf_reg_t_rbp</a> = static_cast&lt;bsl::uint64&gt;(4)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d">bf_reg_t_rsi</a> = static_cast&lt;bsl::uint64&gt;(5)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843">bf_reg_t_rdi</a> = static_cast&lt;bsl::uint64&gt;(6)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8">bf_reg_t_r8</a> = static_cast&lt;bsl::uint64&gt;(7)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a">bf_reg_t_r9</a> = static_cast&lt;bsl::uint64&gt;(8)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3">bf_reg_t_r10</a> = static_cast&lt;bsl::uint64&gt;(9)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1">bf_reg_t_r11</a> = static_cast&lt;bsl::uint64&gt;(10)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78">bf_reg_t_r12</a> = static_cast&lt;bsl::uint64&gt;(11)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc">bf_reg_t_r13</a> = static_cast&lt;bsl::uint64&gt;(12)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce">bf_reg_t_r14</a> = static_cast&lt;bsl::uint64&gt;(13)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189">bf_reg_t_r15</a> = static_cast&lt;bsl::uint64&gt;(14)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa97688dfecdb28ee4e53ef18d8808477">bf_reg_t_intercept_cr_read</a> = static_cast&lt;bsl::uint64&gt;(15)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aeecd0d0b9698727101f57eee07bfc036">bf_reg_t_intercept_cr_write</a> = static_cast&lt;bsl::uint64&gt;(16)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afe94dca53be1be240606b4021ef48896">bf_reg_t_intercept_dr_read</a> = static_cast&lt;bsl::uint64&gt;(17)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d23feab96fe2f710403007f59071a95">bf_reg_t_intercept_dr_write</a> = static_cast&lt;bsl::uint64&gt;(18)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad6d94b9bbbded796e9764e824f1e7b23">bf_reg_t_intercept_exception</a> = static_cast&lt;bsl::uint64&gt;(19)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6015ab17b020f7012909b6d5c57b72a0">bf_reg_t_intercept_instruction1</a> = static_cast&lt;bsl::uint64&gt;(20)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7e9eb25f33bb81f4972574b82c48d8be">bf_reg_t_intercept_instruction2</a> = static_cast&lt;bsl::uint64&gt;(21)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a815be2536af711f608c60c31bf595ef0">bf_reg_t_intercept_instruction3</a> = static_cast&lt;bsl::uint64&gt;(22)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a32ef25f9973c36148ee629222a9cfc4b">bf_reg_t_pause_filter_threshold</a> = static_cast&lt;bsl::uint64&gt;(23)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afc0ff0bd0c59831b5c56d9855a1624bc">bf_reg_t_pause_filter_count</a> = static_cast&lt;bsl::uint64&gt;(24)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a86d6efa2b9d4cea2b33f2b5a93b34742">bf_reg_t_iopm_base_pa</a> = static_cast&lt;bsl::uint64&gt;(25)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a36cfc16dbc1524ba74f614c4df2d5c3e">bf_reg_t_msrpm_base_pa</a> = static_cast&lt;bsl::uint64&gt;(26)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275">bf_reg_t_tsc_offset</a> = static_cast&lt;bsl::uint64&gt;(27)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a91e6cdebcb2ef2f9fdd01e5b1d332124">bf_reg_t_guest_asid</a> = static_cast&lt;bsl::uint64&gt;(28)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae7b6abeddec279c2e24d530f69e8ea48">bf_reg_t_tlb_control</a> = static_cast&lt;bsl::uint64&gt;(29)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7dfa7b7ad301c186418e0cd8bdcbac1b">bf_reg_t_virtual_interrupt_a</a> = static_cast&lt;bsl::uint64&gt;(30)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a152c3df283c4fc748ee125040bb86032">bf_reg_t_virtual_interrupt_b</a> = static_cast&lt;bsl::uint64&gt;(31)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a584fa23b25dfc2320d0075ecfd5f5724">bf_reg_t_exitcode</a> = static_cast&lt;bsl::uint64&gt;(32)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ace6a44bc577a2e5587df99b7dbcfac18">bf_reg_t_exitinfo1</a> = static_cast&lt;bsl::uint64&gt;(33)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a05731134ec34282c67f0dbe03b4e05c0">bf_reg_t_exitinfo2</a> = static_cast&lt;bsl::uint64&gt;(34)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abe41c9ebc806f09f31143848c7780224">bf_reg_t_exitininfo</a> = static_cast&lt;bsl::uint64&gt;(35)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a36fdc0842641d424829ccaeb99363c35">bf_reg_t_ctls1</a> = static_cast&lt;bsl::uint64&gt;(36)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a22406fac3fb48fbe659908c2000e3f2c">bf_reg_t_avic_apic_bar</a> = static_cast&lt;bsl::uint64&gt;(37)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a83dbdf26d64314db84000353e578f88b">bf_reg_t_guest_pa_of_ghcb</a> = static_cast&lt;bsl::uint64&gt;(38)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3aab240be169e7d1516da9d9f7f57cbe">bf_reg_t_eventinj</a> = static_cast&lt;bsl::uint64&gt;(39)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab359ec586c93e2495766c8e9ff105565">bf_reg_t_n_cr3</a> = static_cast&lt;bsl::uint64&gt;(40)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab251cc88d1b21f7d930ce771fe44784c">bf_reg_t_ctls2</a> = static_cast&lt;bsl::uint64&gt;(41)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9948b21fe77d40fa6dae12949473cd31">bf_reg_t_vmcb_clean_bits</a> = static_cast&lt;bsl::uint64&gt;(42)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9186b6fa41430dc0fd77d0bbe202be80">bf_reg_t_nrip</a> = static_cast&lt;bsl::uint64&gt;(43)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a512e65b853f75b892881a65e6a8d4d9f">bf_reg_t_number_of_bytes_fetched</a> = static_cast&lt;bsl::uint64&gt;(44)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a53a80576ad2a07feca3f651e6f74bc76">bf_reg_t_avic_apic_backing_page_ptr</a> = static_cast&lt;bsl::uint64&gt;(45)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1104bf6127ff0f030aba5ff4cc59b13a">bf_reg_t_avic_logical_table_ptr</a> = static_cast&lt;bsl::uint64&gt;(46)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6d23d215b4e8e99de91ae50098d11c38">bf_reg_t_avic_physical_table_ptr</a> = static_cast&lt;bsl::uint64&gt;(47)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5de963101ef099e898cd5646877b2876">bf_reg_t_vmsa_ptr</a> = static_cast&lt;bsl::uint64&gt;(48)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f">bf_reg_t_es_selector</a> = static_cast&lt;bsl::uint64&gt;(49)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c">bf_reg_t_es_attrib</a> = static_cast&lt;bsl::uint64&gt;(50)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e">bf_reg_t_es_limit</a> = static_cast&lt;bsl::uint64&gt;(51)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8">bf_reg_t_es_base</a> = static_cast&lt;bsl::uint64&gt;(52)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92">bf_reg_t_cs_selector</a> = static_cast&lt;bsl::uint64&gt;(53)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0">bf_reg_t_cs_attrib</a> = static_cast&lt;bsl::uint64&gt;(54)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d">bf_reg_t_cs_limit</a> = static_cast&lt;bsl::uint64&gt;(55)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0">bf_reg_t_cs_base</a> = static_cast&lt;bsl::uint64&gt;(56)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87">bf_reg_t_ss_selector</a> = static_cast&lt;bsl::uint64&gt;(57)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a">bf_reg_t_ss_attrib</a> = static_cast&lt;bsl::uint64&gt;(58)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57">bf_reg_t_ss_limit</a> = static_cast&lt;bsl::uint64&gt;(59)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d">bf_reg_t_ss_base</a> = static_cast&lt;bsl::uint64&gt;(60)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06">bf_reg_t_ds_selector</a> = static_cast&lt;bsl::uint64&gt;(61)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840">bf_reg_t_ds_attrib</a> = static_cast&lt;bsl::uint64&gt;(62)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc">bf_reg_t_ds_limit</a> = static_cast&lt;bsl::uint64&gt;(63)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd">bf_reg_t_ds_base</a> = static_cast&lt;bsl::uint64&gt;(64)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2">bf_reg_t_fs_selector</a> = static_cast&lt;bsl::uint64&gt;(65)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99">bf_reg_t_fs_attrib</a> = static_cast&lt;bsl::uint64&gt;(66)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4">bf_reg_t_fs_limit</a> = static_cast&lt;bsl::uint64&gt;(67)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e">bf_reg_t_fs_base</a> = static_cast&lt;bsl::uint64&gt;(68)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf">bf_reg_t_gs_selector</a> = static_cast&lt;bsl::uint64&gt;(69)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9">bf_reg_t_gs_attrib</a> = static_cast&lt;bsl::uint64&gt;(70)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6">bf_reg_t_gs_limit</a> = static_cast&lt;bsl::uint64&gt;(71)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8">bf_reg_t_gs_base</a> = static_cast&lt;bsl::uint64&gt;(72)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aaf1e1ce886840d9f11363f34d1b22154">bf_reg_t_gdtr_selector</a> = static_cast&lt;bsl::uint64&gt;(73)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1108342645405b79f8a789cbdfd0f3f6">bf_reg_t_gdtr_attrib</a> = static_cast&lt;bsl::uint64&gt;(74)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9">bf_reg_t_gdtr_limit</a> = static_cast&lt;bsl::uint64&gt;(75)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee">bf_reg_t_gdtr_base</a> = static_cast&lt;bsl::uint64&gt;(76)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2">bf_reg_t_ldtr_selector</a> = static_cast&lt;bsl::uint64&gt;(77)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476">bf_reg_t_ldtr_attrib</a> = static_cast&lt;bsl::uint64&gt;(78)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1">bf_reg_t_ldtr_limit</a> = static_cast&lt;bsl::uint64&gt;(79)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69">bf_reg_t_ldtr_base</a> = static_cast&lt;bsl::uint64&gt;(80)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0f1e234d6f188d085527f18e2c7820cc">bf_reg_t_idtr_selector</a> = static_cast&lt;bsl::uint64&gt;(81)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a799920a72530f595381969074967a2b4">bf_reg_t_idtr_attrib</a> = static_cast&lt;bsl::uint64&gt;(82)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7">bf_reg_t_idtr_limit</a> = static_cast&lt;bsl::uint64&gt;(83)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0">bf_reg_t_idtr_base</a> = static_cast&lt;bsl::uint64&gt;(84)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4">bf_reg_t_tr_selector</a> = static_cast&lt;bsl::uint64&gt;(85)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5">bf_reg_t_tr_attrib</a> = static_cast&lt;bsl::uint64&gt;(86)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4">bf_reg_t_tr_limit</a> = static_cast&lt;bsl::uint64&gt;(87)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86">bf_reg_t_tr_base</a> = static_cast&lt;bsl::uint64&gt;(88)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c28258484949c7a52c50e25cdecc6db">bf_reg_t_cpl</a> = static_cast&lt;bsl::uint64&gt;(89)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877">bf_reg_t_efer</a> = static_cast&lt;bsl::uint64&gt;(90)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1">bf_reg_t_cr4</a> = static_cast&lt;bsl::uint64&gt;(91)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c">bf_reg_t_cr3</a> = static_cast&lt;bsl::uint64&gt;(92)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1">bf_reg_t_cr0</a> = static_cast&lt;bsl::uint64&gt;(93)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99">bf_reg_t_dr7</a> = static_cast&lt;bsl::uint64&gt;(94)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4">bf_reg_t_dr6</a> = static_cast&lt;bsl::uint64&gt;(95)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9">bf_reg_t_rflags</a> = static_cast&lt;bsl::uint64&gt;(96)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355">bf_reg_t_rip</a> = static_cast&lt;bsl::uint64&gt;(97)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0">bf_reg_t_rsp</a> = static_cast&lt;bsl::uint64&gt;(98)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78">bf_reg_t_rax</a> = static_cast&lt;bsl::uint64&gt;(99)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6">bf_reg_t_star</a> = static_cast&lt;bsl::uint64&gt;(100)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac">bf_reg_t_lstar</a> = static_cast&lt;bsl::uint64&gt;(101)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b">bf_reg_t_cstar</a> = static_cast&lt;bsl::uint64&gt;(102)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47">bf_reg_t_fmask</a> = static_cast&lt;bsl::uint64&gt;(103)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf">bf_reg_t_kernel_gs_base</a> = static_cast&lt;bsl::uint64&gt;(104)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0">bf_reg_t_sysenter_cs</a> = static_cast&lt;bsl::uint64&gt;(105)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2">bf_reg_t_sysenter_esp</a> = static_cast&lt;bsl::uint64&gt;(106)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1">bf_reg_t_sysenter_eip</a> = static_cast&lt;bsl::uint64&gt;(107)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2">bf_reg_t_cr2</a> = static_cast&lt;bsl::uint64&gt;(108)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3">bf_reg_t_pat</a> = static_cast&lt;bsl::uint64&gt;(109)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acecd07371de6e931e2ef143973846761">bf_reg_t_dbgctl</a> = static_cast&lt;bsl::uint64&gt;(110)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa48147b7094cd91eaa3ca9e8b358dcc5">bf_reg_t_br_from</a> = static_cast&lt;bsl::uint64&gt;(111)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad455c48f5f0e764b7080affcb11ac466">bf_reg_t_br_to</a> = static_cast&lt;bsl::uint64&gt;(112)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7c1d99263f002aed282eee3007f243d">bf_reg_t_lastexcpfrom</a> = static_cast&lt;bsl::uint64&gt;(113)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a61093d9ca5c58a5fd5d1a2ae9783d">bf_reg_t_lastexcpto</a> = static_cast&lt;bsl::uint64&gt;(114)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c">bf_reg_t_cr8</a> = static_cast&lt;bsl::uint64&gt;(115)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20">bf_reg_t_dr0</a> = static_cast&lt;bsl::uint64&gt;(116)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d">bf_reg_t_dr1</a> = static_cast&lt;bsl::uint64&gt;(117)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244">bf_reg_t_dr2</a> = static_cast&lt;bsl::uint64&gt;(118)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d">bf_reg_t_dr3</a> = static_cast&lt;bsl::uint64&gt;(119)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc">bf_reg_t_xcr0</a> = static_cast&lt;bsl::uint64&gt;(120)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7">bf_reg_t_invalid</a> = static_cast&lt;bsl::uint64&gt;(BF_MAX_REG_T)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489">bf_reg_t_unsupported</a> = static_cast&lt;bsl::uint64&gt;(0)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78">bf_reg_t_rax</a> = static_cast&lt;bsl::uint64&gt;(1)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7">bf_reg_t_rbx</a> = static_cast&lt;bsl::uint64&gt;(2)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84">bf_reg_t_rcx</a> = static_cast&lt;bsl::uint64&gt;(3)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b">bf_reg_t_rdx</a> = static_cast&lt;bsl::uint64&gt;(4)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4">bf_reg_t_rbp</a> = static_cast&lt;bsl::uint64&gt;(5)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d">bf_reg_t_rsi</a> = static_cast&lt;bsl::uint64&gt;(6)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843">bf_reg_t_rdi</a> = static_cast&lt;bsl::uint64&gt;(7)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8">bf_reg_t_r8</a> = static_cast&lt;bsl::uint64&gt;(8)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a">bf_reg_t_r9</a> = static_cast&lt;bsl::uint64&gt;(9)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3">bf_reg_t_r10</a> = static_cast&lt;bsl::uint64&gt;(10)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1">bf_reg_t_r11</a> = static_cast&lt;bsl::uint64&gt;(11)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78">bf_reg_t_r12</a> = static_cast&lt;bsl::uint64&gt;(12)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc">bf_reg_t_r13</a> = static_cast&lt;bsl::uint64&gt;(13)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce">bf_reg_t_r14</a> = static_cast&lt;bsl::uint64&gt;(14)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189">bf_reg_t_r15</a> = static_cast&lt;bsl::uint64&gt;(15)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2">bf_reg_t_cr2</a> = static_cast&lt;bsl::uint64&gt;(16)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4">bf_reg_t_dr6</a> = static_cast&lt;bsl::uint64&gt;(17)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6">bf_reg_t_star</a> = static_cast&lt;bsl::uint64&gt;(18)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac">bf_reg_t_lstar</a> = static_cast&lt;bsl::uint64&gt;(19)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b">bf_reg_t_cstar</a> = static_cast&lt;bsl::uint64&gt;(20)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47">bf_reg_t_fmask</a> = static_cast&lt;bsl::uint64&gt;(21)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf">bf_reg_t_kernel_gs_base</a> = static_cast&lt;bsl::uint64&gt;(22)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae2ee757d6545401e81e471df273bc12e">bf_reg_t_virtual_processor_identifier</a> = static_cast&lt;bsl::uint64&gt;(23)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a376d209b416dc268d0fdf0e92d9a5aca">bf_reg_t_posted_interrupt_notification_vector</a> = static_cast&lt;bsl::uint64&gt;(24)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7562877f0136cfa3728a5ea45b7ccfe8">bf_reg_t_eptp_index</a> = static_cast&lt;bsl::uint64&gt;(25)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f">bf_reg_t_es_selector</a> = static_cast&lt;bsl::uint64&gt;(26)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92">bf_reg_t_cs_selector</a> = static_cast&lt;bsl::uint64&gt;(27)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87">bf_reg_t_ss_selector</a> = static_cast&lt;bsl::uint64&gt;(28)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06">bf_reg_t_ds_selector</a> = static_cast&lt;bsl::uint64&gt;(29)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2">bf_reg_t_fs_selector</a> = static_cast&lt;bsl::uint64&gt;(30)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf">bf_reg_t_gs_selector</a> = static_cast&lt;bsl::uint64&gt;(31)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2">bf_reg_t_ldtr_selector</a> = static_cast&lt;bsl::uint64&gt;(32)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4">bf_reg_t_tr_selector</a> = static_cast&lt;bsl::uint64&gt;(33)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad72c489acff86e4b43c58bb5b2c9c19f">bf_reg_t_interrupt_status</a> = static_cast&lt;bsl::uint64&gt;(34)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a67e16357b1825afa1184f37a660cc877">bf_reg_t_pml_index</a> = static_cast&lt;bsl::uint64&gt;(35)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab04fa0d4e272efa9d892cdb5fb3260d9">bf_reg_t_address_of_io_bitmap_a</a> = static_cast&lt;bsl::uint64&gt;(36)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4058487ce76a53c19a93c580047229a2">bf_reg_t_address_of_io_bitmap_b</a> = static_cast&lt;bsl::uint64&gt;(37)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c9b31b39da68c647528be7252b938a8">bf_reg_t_address_of_msr_bitmaps</a> = static_cast&lt;bsl::uint64&gt;(38)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6639f6b9cc541e0a91d21c4908bd465b">bf_reg_t_vmexit_msr_store_address</a> = static_cast&lt;bsl::uint64&gt;(39)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8fa9bafd16887cd3df30de6203baf2ae">bf_reg_t_vmexit_msr_load_address</a> = static_cast&lt;bsl::uint64&gt;(40)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ade8a5405c910ad767f36d901f8ea3280">bf_reg_t_vmentry_msr_load_address</a> = static_cast&lt;bsl::uint64&gt;(41)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3bf1a5071b7759172f1e5502e1b3590d">bf_reg_t_executive_vmcs_pointer</a> = static_cast&lt;bsl::uint64&gt;(42)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a10724f307aa18918e468fbc79bea17e6">bf_reg_t_pml_address</a> = static_cast&lt;bsl::uint64&gt;(43)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275">bf_reg_t_tsc_offset</a> = static_cast&lt;bsl::uint64&gt;(44)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a63c87771bc870f498a93b8e80e0a93ef">bf_reg_t_virtual_apic_address</a> = static_cast&lt;bsl::uint64&gt;(45)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a966c1b2544188f5d43c179d3def40871">bf_reg_t_apic_access_address</a> = static_cast&lt;bsl::uint64&gt;(46)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afbfb415d455265bfe83031365d2c5a7c">bf_reg_t_posted_interrupt_descriptor_address</a> = static_cast&lt;bsl::uint64&gt;(47)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab12c998989de32608b28854d44ae755c">bf_reg_t_vm_function_controls</a> = static_cast&lt;bsl::uint64&gt;(48)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae327819d46c934e0624864733958f4fb">bf_reg_t_ept_pointer</a> = static_cast&lt;bsl::uint64&gt;(49)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7c9db134b2fda34b67400adf6ff2a4">bf_reg_t_eoi_exit_bitmap0</a> = static_cast&lt;bsl::uint64&gt;(50)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e8db285cae84a2142f2c2f0309285ac">bf_reg_t_eoi_exit_bitmap1</a> = static_cast&lt;bsl::uint64&gt;(51)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae86a9e219278b2558a92d312ec7b9c73">bf_reg_t_eoi_exit_bitmap2</a> = static_cast&lt;bsl::uint64&gt;(52)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a07b5329a7129e074ec7b63d897cfa647">bf_reg_t_eoi_exit_bitmap3</a> = static_cast&lt;bsl::uint64&gt;(53)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d26e54db9374a1ea6f2310e919ee01f">bf_reg_t_eptp_list_address</a> = static_cast&lt;bsl::uint64&gt;(54)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8faf367a52935d68159b86b65a30ecc1">bf_reg_t_vmread_bitmap_address</a> = static_cast&lt;bsl::uint64&gt;(55)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae8235a3cbbc35d3d711aa55278e6579e">bf_reg_t_vmwrite_bitmap_address</a> = static_cast&lt;bsl::uint64&gt;(56)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a03172213b8e9a43fa4402b4b6251f929">bf_reg_t_virt_exception_information_address</a> = static_cast&lt;bsl::uint64&gt;(57)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9af8d9f8a0c4896cbde3f0f0b3b0b30ddf">bf_reg_t_xss_exiting_bitmap</a> = static_cast&lt;bsl::uint64&gt;(58)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a64ff356e11f75f7b5deffade8f02a7f3">bf_reg_t_encls_exiting_bitmap</a> = static_cast&lt;bsl::uint64&gt;(59)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d69874113d71ac0abecf18aaa2b9e5d">bf_reg_t_sub_page_permission_table_pointer</a> = static_cast&lt;bsl::uint64&gt;(60)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a77196c5f659935fae634a24f52df8804">bf_reg_t_tsc_multiplier</a> = static_cast&lt;bsl::uint64&gt;(61)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a19bf109c88f09256ce9ee9264b0cca49">bf_reg_t_physical_address</a> = static_cast&lt;bsl::uint64&gt;(62)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c53c95f1e531b13fc305081b9b0a9c1">bf_reg_t_vmcs_link_pointer</a> = static_cast&lt;bsl::uint64&gt;(63)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8f67abd5cfee66d4787d414f9f795165">bf_reg_t_debugctl</a> = static_cast&lt;bsl::uint64&gt;(64)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3">bf_reg_t_pat</a> = static_cast&lt;bsl::uint64&gt;(65)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877">bf_reg_t_efer</a> = static_cast&lt;bsl::uint64&gt;(66)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a194026a8b44306ece714579df44932ed">bf_reg_t_perf_global_ctrl</a> = static_cast&lt;bsl::uint64&gt;(67)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa629195bfa0cf8dbf568ccfbc695f4b7">bf_reg_t_pdpte0</a> = static_cast&lt;bsl::uint64&gt;(68)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5069897fe894add51d8d3d3a8da15c57">bf_reg_t_pdpte1</a> = static_cast&lt;bsl::uint64&gt;(69)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7240b6fb184dba08764a9f2ccc1b89">bf_reg_t_pdpte2</a> = static_cast&lt;bsl::uint64&gt;(70)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a48c769218410f03f1af9c581d4259f1d">bf_reg_t_pdpte3</a> = static_cast&lt;bsl::uint64&gt;(71)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0d78bc979ee1fd49456b39693f81707c">bf_reg_t_bndcfgs</a> = static_cast&lt;bsl::uint64&gt;(72)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac086afef52de3a12706c55de1d207275">bf_reg_t_rtit_ctl</a> = static_cast&lt;bsl::uint64&gt;(73)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab955fd5ba8285dd649a1c3cec1285f6d">bf_reg_t_pin_based_vm_execution_ctls</a> = static_cast&lt;bsl::uint64&gt;(74)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a11301f3f015aae253172a85d976f5829">bf_reg_t_primary_proc_based_vm_execution_ctls</a> = static_cast&lt;bsl::uint64&gt;(75)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a10a249a01e4a8409e44ae97397d23866">bf_reg_t_exception_bitmap</a> = static_cast&lt;bsl::uint64&gt;(76)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab02da89523643d3c6fb1b2520772de08">bf_reg_t_page_fault_error_code_mask</a> = static_cast&lt;bsl::uint64&gt;(77)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abd20bddc030820399d7fb942f0384d6c">bf_reg_t_page_fault_error_code_match</a> = static_cast&lt;bsl::uint64&gt;(78)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aaa62782cf540d9e5a0b784061e2ce21b">bf_reg_t_cr3_target_count</a> = static_cast&lt;bsl::uint64&gt;(79)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4263b9a5148a151548a1bde220cb104b">bf_reg_t_vmexit_ctls</a> = static_cast&lt;bsl::uint64&gt;(80)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3eec7378e3f238cab999ab6b15110d4a">bf_reg_t_vmexit_msr_store_count</a> = static_cast&lt;bsl::uint64&gt;(81)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a896905954a40faa22ae0585c7619e8b6">bf_reg_t_vmexit_msr_load_count</a> = static_cast&lt;bsl::uint64&gt;(82)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac7ab067ca2e1740ef032db483a86c068">bf_reg_t_vmentry_ctls</a> = static_cast&lt;bsl::uint64&gt;(83)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3622da1719bcb20cd0d10d26bfabd795">bf_reg_t_vmentry_msr_load_count</a> = static_cast&lt;bsl::uint64&gt;(84)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a135680a2db2eb680246c4f4333eda778">bf_reg_t_vmentry_interrupt_information_field</a> = static_cast&lt;bsl::uint64&gt;(85)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab3f8b4524e5446839d5df83ccc4fa39a">bf_reg_t_vmentry_exception_error_code</a> = static_cast&lt;bsl::uint64&gt;(86)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0af3822dff2d01f6eee05009ed2a164">bf_reg_t_vmentry_instruction_length</a> = static_cast&lt;bsl::uint64&gt;(87)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a88f56a31b18fbfaec0f76689c223411f">bf_reg_t_tpr_threshold</a> = static_cast&lt;bsl::uint64&gt;(88)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae1e0be868bac167644d4897de6a21a20">bf_reg_t_secondary_proc_based_vm_execution_ctls</a> = static_cast&lt;bsl::uint64&gt;(89)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a876dccb0536d91f345dd094482d705f4">bf_reg_t_ple_gap</a> = static_cast&lt;bsl::uint64&gt;(90)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa36dfb0f98fdba579ffc202e0df323c5">bf_reg_t_ple_window</a> = static_cast&lt;bsl::uint64&gt;(91)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a57de1a34a282f1c1b0740ebecfee98ec">bf_reg_t_vm_instruction_error</a> = static_cast&lt;bsl::uint64&gt;(92)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a91061562226ec47b8bd4571215f4c72f">bf_reg_t_exit_reason</a> = static_cast&lt;bsl::uint64&gt;(93)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e4f1d94e2509e8f53d6c2fcbed60f17">bf_reg_t_vmexit_interruption_information</a> = static_cast&lt;bsl::uint64&gt;(94)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2ef995fa65ef86fdb6e96309fcc3c8a5">bf_reg_t_vmexit_interruption_error_code</a> = static_cast&lt;bsl::uint64&gt;(95)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a11a67f6ac06911c3dfe8a10bc80ea461">bf_reg_t_idt_vectoring_information_field</a> = static_cast&lt;bsl::uint64&gt;(96)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a26dbaf904e1edb4074c87d436806805c">bf_reg_t_idt_vectoring_error_code</a> = static_cast&lt;bsl::uint64&gt;(97)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c376159d0d70b0b4047b69e03f73727">bf_reg_t_vmexit_instruction_length</a> = static_cast&lt;bsl::uint64&gt;(98)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5d23abe220f824162359e9707c1f5eaf">bf_reg_t_vmexit_instruction_information</a> = static_cast&lt;bsl::uint64&gt;(99)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e">bf_reg_t_es_limit</a> = static_cast&lt;bsl::uint64&gt;(100)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d">bf_reg_t_cs_limit</a> = static_cast&lt;bsl::uint64&gt;(101)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57">bf_reg_t_ss_limit</a> = static_cast&lt;bsl::uint64&gt;(102)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc">bf_reg_t_ds_limit</a> = static_cast&lt;bsl::uint64&gt;(103)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4">bf_reg_t_fs_limit</a> = static_cast&lt;bsl::uint64&gt;(104)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6">bf_reg_t_gs_limit</a> = static_cast&lt;bsl::uint64&gt;(105)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1">bf_reg_t_ldtr_limit</a> = static_cast&lt;bsl::uint64&gt;(106)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4">bf_reg_t_tr_limit</a> = static_cast&lt;bsl::uint64&gt;(107)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9">bf_reg_t_gdtr_limit</a> = static_cast&lt;bsl::uint64&gt;(108)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7">bf_reg_t_idtr_limit</a> = static_cast&lt;bsl::uint64&gt;(109)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c">bf_reg_t_es_attrib</a> = static_cast&lt;bsl::uint64&gt;(110)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0">bf_reg_t_cs_attrib</a> = static_cast&lt;bsl::uint64&gt;(111)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a">bf_reg_t_ss_attrib</a> = static_cast&lt;bsl::uint64&gt;(112)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840">bf_reg_t_ds_attrib</a> = static_cast&lt;bsl::uint64&gt;(113)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99">bf_reg_t_fs_attrib</a> = static_cast&lt;bsl::uint64&gt;(114)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9">bf_reg_t_gs_attrib</a> = static_cast&lt;bsl::uint64&gt;(115)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476">bf_reg_t_ldtr_attrib</a> = static_cast&lt;bsl::uint64&gt;(116)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5">bf_reg_t_tr_attrib</a> = static_cast&lt;bsl::uint64&gt;(117)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0ecff748f6e482bf8b46524615ee0c44">bf_reg_t_interruptibility_state</a> = static_cast&lt;bsl::uint64&gt;(118)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a190ada235f06637d33f5d2d7a00869f2">bf_reg_t_activity_state</a> = static_cast&lt;bsl::uint64&gt;(119)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7de1bd0395025dd7abef30fe70e0d67">bf_reg_t_smbase</a> = static_cast&lt;bsl::uint64&gt;(120)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0">bf_reg_t_sysenter_cs</a> = static_cast&lt;bsl::uint64&gt;(121)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a24579f38e622082a14459aa44363ce84">bf_reg_t_vmx_preemption_timer_value</a> = static_cast&lt;bsl::uint64&gt;(122)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9af72c2c12ac14130fb76771305da2db42">bf_reg_t_cr0_guest_host_mask</a> = static_cast&lt;bsl::uint64&gt;(123)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e72419c9ce8e5096d20a816492d488e">bf_reg_t_cr4_guest_host_mask</a> = static_cast&lt;bsl::uint64&gt;(124)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aee9ea84cbcd2f277f9bde6e3c9a0770c">bf_reg_t_cr0_read_shadow</a> = static_cast&lt;bsl::uint64&gt;(125)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac73f9b8bddbffc31f141741d1d901559">bf_reg_t_cr4_read_shadow</a> = static_cast&lt;bsl::uint64&gt;(126)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e635957fbb132be4a6dabb6ce86be94">bf_reg_t_cr3_target_value0</a> = static_cast&lt;bsl::uint64&gt;(127)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a59f94320271476fc04523a3aa321f846">bf_reg_t_cr3_target_value1</a> = static_cast&lt;bsl::uint64&gt;(128)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac6bdd033b73352cda1f4401a9a01f1dd">bf_reg_t_cr3_target_value2</a> = static_cast&lt;bsl::uint64&gt;(129)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c85dd5e2641b8627c1ada1f7e96e913">bf_reg_t_cr3_target_value3</a> = static_cast&lt;bsl::uint64&gt;(130)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f5d7dd1a0554024507b213c5aaacae2">bf_reg_t_exit_qualification</a> = static_cast&lt;bsl::uint64&gt;(131)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae65fe71a1c71a67d0a45f826cedfcf27">bf_reg_t_io_rcx</a> = static_cast&lt;bsl::uint64&gt;(132)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a4b8d5c31723f05be3eacdfeae654b">bf_reg_t_io_rsi</a> = static_cast&lt;bsl::uint64&gt;(133)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9e9092b7e0b5a56e6fb157b7e638c615">bf_reg_t_io_rdi</a> = static_cast&lt;bsl::uint64&gt;(134)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f2f9731ad0cf8a8a4d01b0d59ab951a">bf_reg_t_io_rip</a> = static_cast&lt;bsl::uint64&gt;(135)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2aa41076fe5d64027ffb7fc35691755d">bf_reg_t_linear_address</a> = static_cast&lt;bsl::uint64&gt;(136)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1">bf_reg_t_cr0</a> = static_cast&lt;bsl::uint64&gt;(137)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c">bf_reg_t_cr3</a> = static_cast&lt;bsl::uint64&gt;(138)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1">bf_reg_t_cr4</a> = static_cast&lt;bsl::uint64&gt;(139)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8">bf_reg_t_es_base</a> = static_cast&lt;bsl::uint64&gt;(140)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0">bf_reg_t_cs_base</a> = static_cast&lt;bsl::uint64&gt;(141)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d">bf_reg_t_ss_base</a> = static_cast&lt;bsl::uint64&gt;(142)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd">bf_reg_t_ds_base</a> = static_cast&lt;bsl::uint64&gt;(143)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e">bf_reg_t_fs_base</a> = static_cast&lt;bsl::uint64&gt;(144)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8">bf_reg_t_gs_base</a> = static_cast&lt;bsl::uint64&gt;(145)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69">bf_reg_t_ldtr_base</a> = static_cast&lt;bsl::uint64&gt;(146)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86">bf_reg_t_tr_base</a> = static_cast&lt;bsl::uint64&gt;(147)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee">bf_reg_t_gdtr_base</a> = static_cast&lt;bsl::uint64&gt;(148)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0">bf_reg_t_idtr_base</a> = static_cast&lt;bsl::uint64&gt;(149)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99">bf_reg_t_dr7</a> = static_cast&lt;bsl::uint64&gt;(150)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0">bf_reg_t_rsp</a> = static_cast&lt;bsl::uint64&gt;(151)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355">bf_reg_t_rip</a> = static_cast&lt;bsl::uint64&gt;(152)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9">bf_reg_t_rflags</a> = static_cast&lt;bsl::uint64&gt;(153)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9add6e5a94ed55a7010d5df32eba2ed22e">bf_reg_t_pending_debug_exceptions</a> = static_cast&lt;bsl::uint64&gt;(154)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2">bf_reg_t_sysenter_esp</a> = static_cast&lt;bsl::uint64&gt;(155)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1">bf_reg_t_sysenter_eip</a> = static_cast&lt;bsl::uint64&gt;(156)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c">bf_reg_t_cr8</a> = static_cast&lt;bsl::uint64&gt;(157)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20">bf_reg_t_dr0</a> = static_cast&lt;bsl::uint64&gt;(158)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d">bf_reg_t_dr1</a> = static_cast&lt;bsl::uint64&gt;(159)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244">bf_reg_t_dr2</a> = static_cast&lt;bsl::uint64&gt;(160)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d">bf_reg_t_dr3</a> = static_cast&lt;bsl::uint64&gt;(161)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc">bf_reg_t_xcr0</a> = static_cast&lt;bsl::uint64&gt;(162)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7">bf_reg_t_invalid</a> = static_cast&lt;bsl::uint64&gt;(BF_MAX_REG_T)
<br />
 }</td></tr>
<tr class="memdesc:a88e3c7a4f139e3d2c85be4c8b8fc90b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines which register to use for read/write.  <a href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">More...</a><br /></td></tr>
<tr class="separator:a88e3c7a4f139e3d2c85be4c8b8fc90b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e3c7a4f139e3d2c85be4c8b8fc90b9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> : bsl::uint64 { <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489">bf_reg_t_unsupported</a> = static_cast&lt;bsl::uint64&gt;(0)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7">bf_reg_t_rbx</a> = static_cast&lt;bsl::uint64&gt;(1)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84">bf_reg_t_rcx</a> = static_cast&lt;bsl::uint64&gt;(2)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b">bf_reg_t_rdx</a> = static_cast&lt;bsl::uint64&gt;(3)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4">bf_reg_t_rbp</a> = static_cast&lt;bsl::uint64&gt;(4)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d">bf_reg_t_rsi</a> = static_cast&lt;bsl::uint64&gt;(5)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843">bf_reg_t_rdi</a> = static_cast&lt;bsl::uint64&gt;(6)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8">bf_reg_t_r8</a> = static_cast&lt;bsl::uint64&gt;(7)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a">bf_reg_t_r9</a> = static_cast&lt;bsl::uint64&gt;(8)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3">bf_reg_t_r10</a> = static_cast&lt;bsl::uint64&gt;(9)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1">bf_reg_t_r11</a> = static_cast&lt;bsl::uint64&gt;(10)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78">bf_reg_t_r12</a> = static_cast&lt;bsl::uint64&gt;(11)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc">bf_reg_t_r13</a> = static_cast&lt;bsl::uint64&gt;(12)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce">bf_reg_t_r14</a> = static_cast&lt;bsl::uint64&gt;(13)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189">bf_reg_t_r15</a> = static_cast&lt;bsl::uint64&gt;(14)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa97688dfecdb28ee4e53ef18d8808477">bf_reg_t_intercept_cr_read</a> = static_cast&lt;bsl::uint64&gt;(15)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aeecd0d0b9698727101f57eee07bfc036">bf_reg_t_intercept_cr_write</a> = static_cast&lt;bsl::uint64&gt;(16)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afe94dca53be1be240606b4021ef48896">bf_reg_t_intercept_dr_read</a> = static_cast&lt;bsl::uint64&gt;(17)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d23feab96fe2f710403007f59071a95">bf_reg_t_intercept_dr_write</a> = static_cast&lt;bsl::uint64&gt;(18)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad6d94b9bbbded796e9764e824f1e7b23">bf_reg_t_intercept_exception</a> = static_cast&lt;bsl::uint64&gt;(19)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6015ab17b020f7012909b6d5c57b72a0">bf_reg_t_intercept_instruction1</a> = static_cast&lt;bsl::uint64&gt;(20)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7e9eb25f33bb81f4972574b82c48d8be">bf_reg_t_intercept_instruction2</a> = static_cast&lt;bsl::uint64&gt;(21)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a815be2536af711f608c60c31bf595ef0">bf_reg_t_intercept_instruction3</a> = static_cast&lt;bsl::uint64&gt;(22)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a32ef25f9973c36148ee629222a9cfc4b">bf_reg_t_pause_filter_threshold</a> = static_cast&lt;bsl::uint64&gt;(23)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afc0ff0bd0c59831b5c56d9855a1624bc">bf_reg_t_pause_filter_count</a> = static_cast&lt;bsl::uint64&gt;(24)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a86d6efa2b9d4cea2b33f2b5a93b34742">bf_reg_t_iopm_base_pa</a> = static_cast&lt;bsl::uint64&gt;(25)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a36cfc16dbc1524ba74f614c4df2d5c3e">bf_reg_t_msrpm_base_pa</a> = static_cast&lt;bsl::uint64&gt;(26)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275">bf_reg_t_tsc_offset</a> = static_cast&lt;bsl::uint64&gt;(27)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a91e6cdebcb2ef2f9fdd01e5b1d332124">bf_reg_t_guest_asid</a> = static_cast&lt;bsl::uint64&gt;(28)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae7b6abeddec279c2e24d530f69e8ea48">bf_reg_t_tlb_control</a> = static_cast&lt;bsl::uint64&gt;(29)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7dfa7b7ad301c186418e0cd8bdcbac1b">bf_reg_t_virtual_interrupt_a</a> = static_cast&lt;bsl::uint64&gt;(30)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a152c3df283c4fc748ee125040bb86032">bf_reg_t_virtual_interrupt_b</a> = static_cast&lt;bsl::uint64&gt;(31)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a584fa23b25dfc2320d0075ecfd5f5724">bf_reg_t_exitcode</a> = static_cast&lt;bsl::uint64&gt;(32)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ace6a44bc577a2e5587df99b7dbcfac18">bf_reg_t_exitinfo1</a> = static_cast&lt;bsl::uint64&gt;(33)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a05731134ec34282c67f0dbe03b4e05c0">bf_reg_t_exitinfo2</a> = static_cast&lt;bsl::uint64&gt;(34)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abe41c9ebc806f09f31143848c7780224">bf_reg_t_exitininfo</a> = static_cast&lt;bsl::uint64&gt;(35)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a36fdc0842641d424829ccaeb99363c35">bf_reg_t_ctls1</a> = static_cast&lt;bsl::uint64&gt;(36)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a22406fac3fb48fbe659908c2000e3f2c">bf_reg_t_avic_apic_bar</a> = static_cast&lt;bsl::uint64&gt;(37)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a83dbdf26d64314db84000353e578f88b">bf_reg_t_guest_pa_of_ghcb</a> = static_cast&lt;bsl::uint64&gt;(38)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3aab240be169e7d1516da9d9f7f57cbe">bf_reg_t_eventinj</a> = static_cast&lt;bsl::uint64&gt;(39)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab359ec586c93e2495766c8e9ff105565">bf_reg_t_n_cr3</a> = static_cast&lt;bsl::uint64&gt;(40)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab251cc88d1b21f7d930ce771fe44784c">bf_reg_t_ctls2</a> = static_cast&lt;bsl::uint64&gt;(41)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9948b21fe77d40fa6dae12949473cd31">bf_reg_t_vmcb_clean_bits</a> = static_cast&lt;bsl::uint64&gt;(42)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9186b6fa41430dc0fd77d0bbe202be80">bf_reg_t_nrip</a> = static_cast&lt;bsl::uint64&gt;(43)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a512e65b853f75b892881a65e6a8d4d9f">bf_reg_t_number_of_bytes_fetched</a> = static_cast&lt;bsl::uint64&gt;(44)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a53a80576ad2a07feca3f651e6f74bc76">bf_reg_t_avic_apic_backing_page_ptr</a> = static_cast&lt;bsl::uint64&gt;(45)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1104bf6127ff0f030aba5ff4cc59b13a">bf_reg_t_avic_logical_table_ptr</a> = static_cast&lt;bsl::uint64&gt;(46)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6d23d215b4e8e99de91ae50098d11c38">bf_reg_t_avic_physical_table_ptr</a> = static_cast&lt;bsl::uint64&gt;(47)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5de963101ef099e898cd5646877b2876">bf_reg_t_vmsa_ptr</a> = static_cast&lt;bsl::uint64&gt;(48)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f">bf_reg_t_es_selector</a> = static_cast&lt;bsl::uint64&gt;(49)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c">bf_reg_t_es_attrib</a> = static_cast&lt;bsl::uint64&gt;(50)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e">bf_reg_t_es_limit</a> = static_cast&lt;bsl::uint64&gt;(51)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8">bf_reg_t_es_base</a> = static_cast&lt;bsl::uint64&gt;(52)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92">bf_reg_t_cs_selector</a> = static_cast&lt;bsl::uint64&gt;(53)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0">bf_reg_t_cs_attrib</a> = static_cast&lt;bsl::uint64&gt;(54)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d">bf_reg_t_cs_limit</a> = static_cast&lt;bsl::uint64&gt;(55)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0">bf_reg_t_cs_base</a> = static_cast&lt;bsl::uint64&gt;(56)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87">bf_reg_t_ss_selector</a> = static_cast&lt;bsl::uint64&gt;(57)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a">bf_reg_t_ss_attrib</a> = static_cast&lt;bsl::uint64&gt;(58)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57">bf_reg_t_ss_limit</a> = static_cast&lt;bsl::uint64&gt;(59)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d">bf_reg_t_ss_base</a> = static_cast&lt;bsl::uint64&gt;(60)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06">bf_reg_t_ds_selector</a> = static_cast&lt;bsl::uint64&gt;(61)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840">bf_reg_t_ds_attrib</a> = static_cast&lt;bsl::uint64&gt;(62)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc">bf_reg_t_ds_limit</a> = static_cast&lt;bsl::uint64&gt;(63)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd">bf_reg_t_ds_base</a> = static_cast&lt;bsl::uint64&gt;(64)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2">bf_reg_t_fs_selector</a> = static_cast&lt;bsl::uint64&gt;(65)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99">bf_reg_t_fs_attrib</a> = static_cast&lt;bsl::uint64&gt;(66)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4">bf_reg_t_fs_limit</a> = static_cast&lt;bsl::uint64&gt;(67)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e">bf_reg_t_fs_base</a> = static_cast&lt;bsl::uint64&gt;(68)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf">bf_reg_t_gs_selector</a> = static_cast&lt;bsl::uint64&gt;(69)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9">bf_reg_t_gs_attrib</a> = static_cast&lt;bsl::uint64&gt;(70)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6">bf_reg_t_gs_limit</a> = static_cast&lt;bsl::uint64&gt;(71)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8">bf_reg_t_gs_base</a> = static_cast&lt;bsl::uint64&gt;(72)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aaf1e1ce886840d9f11363f34d1b22154">bf_reg_t_gdtr_selector</a> = static_cast&lt;bsl::uint64&gt;(73)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1108342645405b79f8a789cbdfd0f3f6">bf_reg_t_gdtr_attrib</a> = static_cast&lt;bsl::uint64&gt;(74)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9">bf_reg_t_gdtr_limit</a> = static_cast&lt;bsl::uint64&gt;(75)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee">bf_reg_t_gdtr_base</a> = static_cast&lt;bsl::uint64&gt;(76)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2">bf_reg_t_ldtr_selector</a> = static_cast&lt;bsl::uint64&gt;(77)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476">bf_reg_t_ldtr_attrib</a> = static_cast&lt;bsl::uint64&gt;(78)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1">bf_reg_t_ldtr_limit</a> = static_cast&lt;bsl::uint64&gt;(79)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69">bf_reg_t_ldtr_base</a> = static_cast&lt;bsl::uint64&gt;(80)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0f1e234d6f188d085527f18e2c7820cc">bf_reg_t_idtr_selector</a> = static_cast&lt;bsl::uint64&gt;(81)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a799920a72530f595381969074967a2b4">bf_reg_t_idtr_attrib</a> = static_cast&lt;bsl::uint64&gt;(82)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7">bf_reg_t_idtr_limit</a> = static_cast&lt;bsl::uint64&gt;(83)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0">bf_reg_t_idtr_base</a> = static_cast&lt;bsl::uint64&gt;(84)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4">bf_reg_t_tr_selector</a> = static_cast&lt;bsl::uint64&gt;(85)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5">bf_reg_t_tr_attrib</a> = static_cast&lt;bsl::uint64&gt;(86)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4">bf_reg_t_tr_limit</a> = static_cast&lt;bsl::uint64&gt;(87)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86">bf_reg_t_tr_base</a> = static_cast&lt;bsl::uint64&gt;(88)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c28258484949c7a52c50e25cdecc6db">bf_reg_t_cpl</a> = static_cast&lt;bsl::uint64&gt;(89)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877">bf_reg_t_efer</a> = static_cast&lt;bsl::uint64&gt;(90)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1">bf_reg_t_cr4</a> = static_cast&lt;bsl::uint64&gt;(91)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c">bf_reg_t_cr3</a> = static_cast&lt;bsl::uint64&gt;(92)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1">bf_reg_t_cr0</a> = static_cast&lt;bsl::uint64&gt;(93)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99">bf_reg_t_dr7</a> = static_cast&lt;bsl::uint64&gt;(94)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4">bf_reg_t_dr6</a> = static_cast&lt;bsl::uint64&gt;(95)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9">bf_reg_t_rflags</a> = static_cast&lt;bsl::uint64&gt;(96)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355">bf_reg_t_rip</a> = static_cast&lt;bsl::uint64&gt;(97)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0">bf_reg_t_rsp</a> = static_cast&lt;bsl::uint64&gt;(98)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78">bf_reg_t_rax</a> = static_cast&lt;bsl::uint64&gt;(99)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6">bf_reg_t_star</a> = static_cast&lt;bsl::uint64&gt;(100)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac">bf_reg_t_lstar</a> = static_cast&lt;bsl::uint64&gt;(101)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b">bf_reg_t_cstar</a> = static_cast&lt;bsl::uint64&gt;(102)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47">bf_reg_t_fmask</a> = static_cast&lt;bsl::uint64&gt;(103)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf">bf_reg_t_kernel_gs_base</a> = static_cast&lt;bsl::uint64&gt;(104)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0">bf_reg_t_sysenter_cs</a> = static_cast&lt;bsl::uint64&gt;(105)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2">bf_reg_t_sysenter_esp</a> = static_cast&lt;bsl::uint64&gt;(106)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1">bf_reg_t_sysenter_eip</a> = static_cast&lt;bsl::uint64&gt;(107)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2">bf_reg_t_cr2</a> = static_cast&lt;bsl::uint64&gt;(108)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3">bf_reg_t_pat</a> = static_cast&lt;bsl::uint64&gt;(109)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acecd07371de6e931e2ef143973846761">bf_reg_t_dbgctl</a> = static_cast&lt;bsl::uint64&gt;(110)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa48147b7094cd91eaa3ca9e8b358dcc5">bf_reg_t_br_from</a> = static_cast&lt;bsl::uint64&gt;(111)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad455c48f5f0e764b7080affcb11ac466">bf_reg_t_br_to</a> = static_cast&lt;bsl::uint64&gt;(112)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7c1d99263f002aed282eee3007f243d">bf_reg_t_lastexcpfrom</a> = static_cast&lt;bsl::uint64&gt;(113)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a61093d9ca5c58a5fd5d1a2ae9783d">bf_reg_t_lastexcpto</a> = static_cast&lt;bsl::uint64&gt;(114)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c">bf_reg_t_cr8</a> = static_cast&lt;bsl::uint64&gt;(115)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20">bf_reg_t_dr0</a> = static_cast&lt;bsl::uint64&gt;(116)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d">bf_reg_t_dr1</a> = static_cast&lt;bsl::uint64&gt;(117)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244">bf_reg_t_dr2</a> = static_cast&lt;bsl::uint64&gt;(118)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d">bf_reg_t_dr3</a> = static_cast&lt;bsl::uint64&gt;(119)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc">bf_reg_t_xcr0</a> = static_cast&lt;bsl::uint64&gt;(120)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7">bf_reg_t_invalid</a> = static_cast&lt;bsl::uint64&gt;(BF_MAX_REG_T)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489">bf_reg_t_unsupported</a> = static_cast&lt;bsl::uint64&gt;(0)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78">bf_reg_t_rax</a> = static_cast&lt;bsl::uint64&gt;(1)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7">bf_reg_t_rbx</a> = static_cast&lt;bsl::uint64&gt;(2)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84">bf_reg_t_rcx</a> = static_cast&lt;bsl::uint64&gt;(3)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b">bf_reg_t_rdx</a> = static_cast&lt;bsl::uint64&gt;(4)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4">bf_reg_t_rbp</a> = static_cast&lt;bsl::uint64&gt;(5)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d">bf_reg_t_rsi</a> = static_cast&lt;bsl::uint64&gt;(6)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843">bf_reg_t_rdi</a> = static_cast&lt;bsl::uint64&gt;(7)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8">bf_reg_t_r8</a> = static_cast&lt;bsl::uint64&gt;(8)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a">bf_reg_t_r9</a> = static_cast&lt;bsl::uint64&gt;(9)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3">bf_reg_t_r10</a> = static_cast&lt;bsl::uint64&gt;(10)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1">bf_reg_t_r11</a> = static_cast&lt;bsl::uint64&gt;(11)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78">bf_reg_t_r12</a> = static_cast&lt;bsl::uint64&gt;(12)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc">bf_reg_t_r13</a> = static_cast&lt;bsl::uint64&gt;(13)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce">bf_reg_t_r14</a> = static_cast&lt;bsl::uint64&gt;(14)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189">bf_reg_t_r15</a> = static_cast&lt;bsl::uint64&gt;(15)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2">bf_reg_t_cr2</a> = static_cast&lt;bsl::uint64&gt;(16)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4">bf_reg_t_dr6</a> = static_cast&lt;bsl::uint64&gt;(17)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6">bf_reg_t_star</a> = static_cast&lt;bsl::uint64&gt;(18)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac">bf_reg_t_lstar</a> = static_cast&lt;bsl::uint64&gt;(19)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b">bf_reg_t_cstar</a> = static_cast&lt;bsl::uint64&gt;(20)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47">bf_reg_t_fmask</a> = static_cast&lt;bsl::uint64&gt;(21)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf">bf_reg_t_kernel_gs_base</a> = static_cast&lt;bsl::uint64&gt;(22)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae2ee757d6545401e81e471df273bc12e">bf_reg_t_virtual_processor_identifier</a> = static_cast&lt;bsl::uint64&gt;(23)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a376d209b416dc268d0fdf0e92d9a5aca">bf_reg_t_posted_interrupt_notification_vector</a> = static_cast&lt;bsl::uint64&gt;(24)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7562877f0136cfa3728a5ea45b7ccfe8">bf_reg_t_eptp_index</a> = static_cast&lt;bsl::uint64&gt;(25)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f">bf_reg_t_es_selector</a> = static_cast&lt;bsl::uint64&gt;(26)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92">bf_reg_t_cs_selector</a> = static_cast&lt;bsl::uint64&gt;(27)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87">bf_reg_t_ss_selector</a> = static_cast&lt;bsl::uint64&gt;(28)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06">bf_reg_t_ds_selector</a> = static_cast&lt;bsl::uint64&gt;(29)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2">bf_reg_t_fs_selector</a> = static_cast&lt;bsl::uint64&gt;(30)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf">bf_reg_t_gs_selector</a> = static_cast&lt;bsl::uint64&gt;(31)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2">bf_reg_t_ldtr_selector</a> = static_cast&lt;bsl::uint64&gt;(32)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4">bf_reg_t_tr_selector</a> = static_cast&lt;bsl::uint64&gt;(33)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad72c489acff86e4b43c58bb5b2c9c19f">bf_reg_t_interrupt_status</a> = static_cast&lt;bsl::uint64&gt;(34)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a67e16357b1825afa1184f37a660cc877">bf_reg_t_pml_index</a> = static_cast&lt;bsl::uint64&gt;(35)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab04fa0d4e272efa9d892cdb5fb3260d9">bf_reg_t_address_of_io_bitmap_a</a> = static_cast&lt;bsl::uint64&gt;(36)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4058487ce76a53c19a93c580047229a2">bf_reg_t_address_of_io_bitmap_b</a> = static_cast&lt;bsl::uint64&gt;(37)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c9b31b39da68c647528be7252b938a8">bf_reg_t_address_of_msr_bitmaps</a> = static_cast&lt;bsl::uint64&gt;(38)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6639f6b9cc541e0a91d21c4908bd465b">bf_reg_t_vmexit_msr_store_address</a> = static_cast&lt;bsl::uint64&gt;(39)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8fa9bafd16887cd3df30de6203baf2ae">bf_reg_t_vmexit_msr_load_address</a> = static_cast&lt;bsl::uint64&gt;(40)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ade8a5405c910ad767f36d901f8ea3280">bf_reg_t_vmentry_msr_load_address</a> = static_cast&lt;bsl::uint64&gt;(41)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3bf1a5071b7759172f1e5502e1b3590d">bf_reg_t_executive_vmcs_pointer</a> = static_cast&lt;bsl::uint64&gt;(42)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a10724f307aa18918e468fbc79bea17e6">bf_reg_t_pml_address</a> = static_cast&lt;bsl::uint64&gt;(43)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275">bf_reg_t_tsc_offset</a> = static_cast&lt;bsl::uint64&gt;(44)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a63c87771bc870f498a93b8e80e0a93ef">bf_reg_t_virtual_apic_address</a> = static_cast&lt;bsl::uint64&gt;(45)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a966c1b2544188f5d43c179d3def40871">bf_reg_t_apic_access_address</a> = static_cast&lt;bsl::uint64&gt;(46)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afbfb415d455265bfe83031365d2c5a7c">bf_reg_t_posted_interrupt_descriptor_address</a> = static_cast&lt;bsl::uint64&gt;(47)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab12c998989de32608b28854d44ae755c">bf_reg_t_vm_function_controls</a> = static_cast&lt;bsl::uint64&gt;(48)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae327819d46c934e0624864733958f4fb">bf_reg_t_ept_pointer</a> = static_cast&lt;bsl::uint64&gt;(49)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7c9db134b2fda34b67400adf6ff2a4">bf_reg_t_eoi_exit_bitmap0</a> = static_cast&lt;bsl::uint64&gt;(50)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e8db285cae84a2142f2c2f0309285ac">bf_reg_t_eoi_exit_bitmap1</a> = static_cast&lt;bsl::uint64&gt;(51)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae86a9e219278b2558a92d312ec7b9c73">bf_reg_t_eoi_exit_bitmap2</a> = static_cast&lt;bsl::uint64&gt;(52)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a07b5329a7129e074ec7b63d897cfa647">bf_reg_t_eoi_exit_bitmap3</a> = static_cast&lt;bsl::uint64&gt;(53)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d26e54db9374a1ea6f2310e919ee01f">bf_reg_t_eptp_list_address</a> = static_cast&lt;bsl::uint64&gt;(54)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8faf367a52935d68159b86b65a30ecc1">bf_reg_t_vmread_bitmap_address</a> = static_cast&lt;bsl::uint64&gt;(55)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae8235a3cbbc35d3d711aa55278e6579e">bf_reg_t_vmwrite_bitmap_address</a> = static_cast&lt;bsl::uint64&gt;(56)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a03172213b8e9a43fa4402b4b6251f929">bf_reg_t_virt_exception_information_address</a> = static_cast&lt;bsl::uint64&gt;(57)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9af8d9f8a0c4896cbde3f0f0b3b0b30ddf">bf_reg_t_xss_exiting_bitmap</a> = static_cast&lt;bsl::uint64&gt;(58)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a64ff356e11f75f7b5deffade8f02a7f3">bf_reg_t_encls_exiting_bitmap</a> = static_cast&lt;bsl::uint64&gt;(59)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d69874113d71ac0abecf18aaa2b9e5d">bf_reg_t_sub_page_permission_table_pointer</a> = static_cast&lt;bsl::uint64&gt;(60)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a77196c5f659935fae634a24f52df8804">bf_reg_t_tsc_multiplier</a> = static_cast&lt;bsl::uint64&gt;(61)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a19bf109c88f09256ce9ee9264b0cca49">bf_reg_t_physical_address</a> = static_cast&lt;bsl::uint64&gt;(62)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c53c95f1e531b13fc305081b9b0a9c1">bf_reg_t_vmcs_link_pointer</a> = static_cast&lt;bsl::uint64&gt;(63)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8f67abd5cfee66d4787d414f9f795165">bf_reg_t_debugctl</a> = static_cast&lt;bsl::uint64&gt;(64)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3">bf_reg_t_pat</a> = static_cast&lt;bsl::uint64&gt;(65)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877">bf_reg_t_efer</a> = static_cast&lt;bsl::uint64&gt;(66)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a194026a8b44306ece714579df44932ed">bf_reg_t_perf_global_ctrl</a> = static_cast&lt;bsl::uint64&gt;(67)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa629195bfa0cf8dbf568ccfbc695f4b7">bf_reg_t_pdpte0</a> = static_cast&lt;bsl::uint64&gt;(68)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5069897fe894add51d8d3d3a8da15c57">bf_reg_t_pdpte1</a> = static_cast&lt;bsl::uint64&gt;(69)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7240b6fb184dba08764a9f2ccc1b89">bf_reg_t_pdpte2</a> = static_cast&lt;bsl::uint64&gt;(70)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a48c769218410f03f1af9c581d4259f1d">bf_reg_t_pdpte3</a> = static_cast&lt;bsl::uint64&gt;(71)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0d78bc979ee1fd49456b39693f81707c">bf_reg_t_bndcfgs</a> = static_cast&lt;bsl::uint64&gt;(72)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac086afef52de3a12706c55de1d207275">bf_reg_t_rtit_ctl</a> = static_cast&lt;bsl::uint64&gt;(73)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab955fd5ba8285dd649a1c3cec1285f6d">bf_reg_t_pin_based_vm_execution_ctls</a> = static_cast&lt;bsl::uint64&gt;(74)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a11301f3f015aae253172a85d976f5829">bf_reg_t_primary_proc_based_vm_execution_ctls</a> = static_cast&lt;bsl::uint64&gt;(75)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a10a249a01e4a8409e44ae97397d23866">bf_reg_t_exception_bitmap</a> = static_cast&lt;bsl::uint64&gt;(76)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab02da89523643d3c6fb1b2520772de08">bf_reg_t_page_fault_error_code_mask</a> = static_cast&lt;bsl::uint64&gt;(77)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abd20bddc030820399d7fb942f0384d6c">bf_reg_t_page_fault_error_code_match</a> = static_cast&lt;bsl::uint64&gt;(78)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aaa62782cf540d9e5a0b784061e2ce21b">bf_reg_t_cr3_target_count</a> = static_cast&lt;bsl::uint64&gt;(79)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4263b9a5148a151548a1bde220cb104b">bf_reg_t_vmexit_ctls</a> = static_cast&lt;bsl::uint64&gt;(80)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3eec7378e3f238cab999ab6b15110d4a">bf_reg_t_vmexit_msr_store_count</a> = static_cast&lt;bsl::uint64&gt;(81)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a896905954a40faa22ae0585c7619e8b6">bf_reg_t_vmexit_msr_load_count</a> = static_cast&lt;bsl::uint64&gt;(82)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac7ab067ca2e1740ef032db483a86c068">bf_reg_t_vmentry_ctls</a> = static_cast&lt;bsl::uint64&gt;(83)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3622da1719bcb20cd0d10d26bfabd795">bf_reg_t_vmentry_msr_load_count</a> = static_cast&lt;bsl::uint64&gt;(84)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a135680a2db2eb680246c4f4333eda778">bf_reg_t_vmentry_interrupt_information_field</a> = static_cast&lt;bsl::uint64&gt;(85)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab3f8b4524e5446839d5df83ccc4fa39a">bf_reg_t_vmentry_exception_error_code</a> = static_cast&lt;bsl::uint64&gt;(86)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0af3822dff2d01f6eee05009ed2a164">bf_reg_t_vmentry_instruction_length</a> = static_cast&lt;bsl::uint64&gt;(87)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a88f56a31b18fbfaec0f76689c223411f">bf_reg_t_tpr_threshold</a> = static_cast&lt;bsl::uint64&gt;(88)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae1e0be868bac167644d4897de6a21a20">bf_reg_t_secondary_proc_based_vm_execution_ctls</a> = static_cast&lt;bsl::uint64&gt;(89)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a876dccb0536d91f345dd094482d705f4">bf_reg_t_ple_gap</a> = static_cast&lt;bsl::uint64&gt;(90)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa36dfb0f98fdba579ffc202e0df323c5">bf_reg_t_ple_window</a> = static_cast&lt;bsl::uint64&gt;(91)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a57de1a34a282f1c1b0740ebecfee98ec">bf_reg_t_vm_instruction_error</a> = static_cast&lt;bsl::uint64&gt;(92)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a91061562226ec47b8bd4571215f4c72f">bf_reg_t_exit_reason</a> = static_cast&lt;bsl::uint64&gt;(93)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e4f1d94e2509e8f53d6c2fcbed60f17">bf_reg_t_vmexit_interruption_information</a> = static_cast&lt;bsl::uint64&gt;(94)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2ef995fa65ef86fdb6e96309fcc3c8a5">bf_reg_t_vmexit_interruption_error_code</a> = static_cast&lt;bsl::uint64&gt;(95)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a11a67f6ac06911c3dfe8a10bc80ea461">bf_reg_t_idt_vectoring_information_field</a> = static_cast&lt;bsl::uint64&gt;(96)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a26dbaf904e1edb4074c87d436806805c">bf_reg_t_idt_vectoring_error_code</a> = static_cast&lt;bsl::uint64&gt;(97)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c376159d0d70b0b4047b69e03f73727">bf_reg_t_vmexit_instruction_length</a> = static_cast&lt;bsl::uint64&gt;(98)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5d23abe220f824162359e9707c1f5eaf">bf_reg_t_vmexit_instruction_information</a> = static_cast&lt;bsl::uint64&gt;(99)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e">bf_reg_t_es_limit</a> = static_cast&lt;bsl::uint64&gt;(100)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d">bf_reg_t_cs_limit</a> = static_cast&lt;bsl::uint64&gt;(101)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57">bf_reg_t_ss_limit</a> = static_cast&lt;bsl::uint64&gt;(102)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc">bf_reg_t_ds_limit</a> = static_cast&lt;bsl::uint64&gt;(103)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4">bf_reg_t_fs_limit</a> = static_cast&lt;bsl::uint64&gt;(104)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6">bf_reg_t_gs_limit</a> = static_cast&lt;bsl::uint64&gt;(105)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1">bf_reg_t_ldtr_limit</a> = static_cast&lt;bsl::uint64&gt;(106)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4">bf_reg_t_tr_limit</a> = static_cast&lt;bsl::uint64&gt;(107)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9">bf_reg_t_gdtr_limit</a> = static_cast&lt;bsl::uint64&gt;(108)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7">bf_reg_t_idtr_limit</a> = static_cast&lt;bsl::uint64&gt;(109)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c">bf_reg_t_es_attrib</a> = static_cast&lt;bsl::uint64&gt;(110)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0">bf_reg_t_cs_attrib</a> = static_cast&lt;bsl::uint64&gt;(111)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a">bf_reg_t_ss_attrib</a> = static_cast&lt;bsl::uint64&gt;(112)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840">bf_reg_t_ds_attrib</a> = static_cast&lt;bsl::uint64&gt;(113)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99">bf_reg_t_fs_attrib</a> = static_cast&lt;bsl::uint64&gt;(114)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9">bf_reg_t_gs_attrib</a> = static_cast&lt;bsl::uint64&gt;(115)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476">bf_reg_t_ldtr_attrib</a> = static_cast&lt;bsl::uint64&gt;(116)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5">bf_reg_t_tr_attrib</a> = static_cast&lt;bsl::uint64&gt;(117)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a0ecff748f6e482bf8b46524615ee0c44">bf_reg_t_interruptibility_state</a> = static_cast&lt;bsl::uint64&gt;(118)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a190ada235f06637d33f5d2d7a00869f2">bf_reg_t_activity_state</a> = static_cast&lt;bsl::uint64&gt;(119)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7de1bd0395025dd7abef30fe70e0d67">bf_reg_t_smbase</a> = static_cast&lt;bsl::uint64&gt;(120)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0">bf_reg_t_sysenter_cs</a> = static_cast&lt;bsl::uint64&gt;(121)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a24579f38e622082a14459aa44363ce84">bf_reg_t_vmx_preemption_timer_value</a> = static_cast&lt;bsl::uint64&gt;(122)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9af72c2c12ac14130fb76771305da2db42">bf_reg_t_cr0_guest_host_mask</a> = static_cast&lt;bsl::uint64&gt;(123)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e72419c9ce8e5096d20a816492d488e">bf_reg_t_cr4_guest_host_mask</a> = static_cast&lt;bsl::uint64&gt;(124)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aee9ea84cbcd2f277f9bde6e3c9a0770c">bf_reg_t_cr0_read_shadow</a> = static_cast&lt;bsl::uint64&gt;(125)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac73f9b8bddbffc31f141741d1d901559">bf_reg_t_cr4_read_shadow</a> = static_cast&lt;bsl::uint64&gt;(126)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e635957fbb132be4a6dabb6ce86be94">bf_reg_t_cr3_target_value0</a> = static_cast&lt;bsl::uint64&gt;(127)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a59f94320271476fc04523a3aa321f846">bf_reg_t_cr3_target_value1</a> = static_cast&lt;bsl::uint64&gt;(128)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ac6bdd033b73352cda1f4401a9a01f1dd">bf_reg_t_cr3_target_value2</a> = static_cast&lt;bsl::uint64&gt;(129)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c85dd5e2641b8627c1ada1f7e96e913">bf_reg_t_cr3_target_value3</a> = static_cast&lt;bsl::uint64&gt;(130)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f5d7dd1a0554024507b213c5aaacae2">bf_reg_t_exit_qualification</a> = static_cast&lt;bsl::uint64&gt;(131)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae65fe71a1c71a67d0a45f826cedfcf27">bf_reg_t_io_rcx</a> = static_cast&lt;bsl::uint64&gt;(132)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a4b8d5c31723f05be3eacdfeae654b">bf_reg_t_io_rsi</a> = static_cast&lt;bsl::uint64&gt;(133)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a9e9092b7e0b5a56e6fb157b7e638c615">bf_reg_t_io_rdi</a> = static_cast&lt;bsl::uint64&gt;(134)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f2f9731ad0cf8a8a4d01b0d59ab951a">bf_reg_t_io_rip</a> = static_cast&lt;bsl::uint64&gt;(135)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2aa41076fe5d64027ffb7fc35691755d">bf_reg_t_linear_address</a> = static_cast&lt;bsl::uint64&gt;(136)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1">bf_reg_t_cr0</a> = static_cast&lt;bsl::uint64&gt;(137)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c">bf_reg_t_cr3</a> = static_cast&lt;bsl::uint64&gt;(138)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1">bf_reg_t_cr4</a> = static_cast&lt;bsl::uint64&gt;(139)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8">bf_reg_t_es_base</a> = static_cast&lt;bsl::uint64&gt;(140)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0">bf_reg_t_cs_base</a> = static_cast&lt;bsl::uint64&gt;(141)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d">bf_reg_t_ss_base</a> = static_cast&lt;bsl::uint64&gt;(142)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd">bf_reg_t_ds_base</a> = static_cast&lt;bsl::uint64&gt;(143)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e">bf_reg_t_fs_base</a> = static_cast&lt;bsl::uint64&gt;(144)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8">bf_reg_t_gs_base</a> = static_cast&lt;bsl::uint64&gt;(145)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69">bf_reg_t_ldtr_base</a> = static_cast&lt;bsl::uint64&gt;(146)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86">bf_reg_t_tr_base</a> = static_cast&lt;bsl::uint64&gt;(147)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee">bf_reg_t_gdtr_base</a> = static_cast&lt;bsl::uint64&gt;(148)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0">bf_reg_t_idtr_base</a> = static_cast&lt;bsl::uint64&gt;(149)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99">bf_reg_t_dr7</a> = static_cast&lt;bsl::uint64&gt;(150)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0">bf_reg_t_rsp</a> = static_cast&lt;bsl::uint64&gt;(151)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355">bf_reg_t_rip</a> = static_cast&lt;bsl::uint64&gt;(152)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9">bf_reg_t_rflags</a> = static_cast&lt;bsl::uint64&gt;(153)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9add6e5a94ed55a7010d5df32eba2ed22e">bf_reg_t_pending_debug_exceptions</a> = static_cast&lt;bsl::uint64&gt;(154)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2">bf_reg_t_sysenter_esp</a> = static_cast&lt;bsl::uint64&gt;(155)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1">bf_reg_t_sysenter_eip</a> = static_cast&lt;bsl::uint64&gt;(156)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c">bf_reg_t_cr8</a> = static_cast&lt;bsl::uint64&gt;(157)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20">bf_reg_t_dr0</a> = static_cast&lt;bsl::uint64&gt;(158)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d">bf_reg_t_dr1</a> = static_cast&lt;bsl::uint64&gt;(159)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244">bf_reg_t_dr2</a> = static_cast&lt;bsl::uint64&gt;(160)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d">bf_reg_t_dr3</a> = static_cast&lt;bsl::uint64&gt;(161)
, <br />
&#160;&#160;<a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc">bf_reg_t_xcr0</a> = static_cast&lt;bsl::uint64&gt;(162)
, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7">bf_reg_t_invalid</a> = static_cast&lt;bsl::uint64&gt;(BF_MAX_REG_T)
<br />
 }</td></tr>
<tr class="memdesc:a88e3c7a4f139e3d2c85be4c8b8fc90b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines which register is being requested by certain syscalls.  <a href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">More...</a><br /></td></tr>
<tr class="separator:a88e3c7a4f139e3d2c85be4c8b8fc90b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a707f2093b716a114cb8b90618ceffaff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a707f2093b716a114cb8b90618ceffaff">bootstrap_entry</a> (bsl::safe_u16::value_type const ppid0) noexcept</td></tr>
<tr class="memdesc:a707f2093b716a114cb8b90618ceffaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bootstrap entry function. This function is called on each PP while the hypervisor is being bootstrapped.  <a href="namespacesyscall.html#a707f2093b716a114cb8b90618ceffaff">More...</a><br /></td></tr>
<tr class="separator:a707f2093b716a114cb8b90618ceffaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c15871007d0563a77b217d88c420b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a46c15871007d0563a77b217d88c420b6">fail_entry</a> (bsl::safe_u64::value_type const errc, bsl::safe_u64::value_type const addr) noexcept</td></tr>
<tr class="memdesc:a46c15871007d0563a77b217d88c420b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the fast fail entry function. This is registered by the main function to execute whenever a fast fail occurs.  <a href="namespacesyscall.html#a46c15871007d0563a77b217d88c420b6">More...</a><br /></td></tr>
<tr class="separator:a46c15871007d0563a77b217d88c420b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a093cf4e16e3e438b1154d0b52522d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ac3a093cf4e16e3e438b1154d0b52522d">vmexit_entry</a> (bsl::safe_u16::value_type const vsid, bsl::safe_u64::value_type const exit_reason) noexcept</td></tr>
<tr class="memdesc:ac3a093cf4e16e3e438b1154d0b52522d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the VMExit entry function. This is registered by the main function to execute whenever a VMExit occurs.  <a href="namespacesyscall.html#ac3a093cf4e16e3e438b1154d0b52522d">More...</a><br /></td></tr>
<tr class="separator:ac3a093cf4e16e3e438b1154d0b52522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f2f3d774b6a9ba0c8aa9d716c673a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a03f2f3d774b6a9ba0c8aa9d716c673a7">ext_main_entry</a> (bsl::uint32 const version) noexcept</td></tr>
<tr class="memdesc:a03f2f3d774b6a9ba0c8aa9d716c673a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the main entry function for this example.  <a href="namespacesyscall.html#a03f2f3d774b6a9ba0c8aa9d716c673a7">More...</a><br /></td></tr>
<tr class="separator:a03f2f3d774b6a9ba0c8aa9d716c673a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e408c172d4f703f7dc76f85bf2f760c"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a7e408c172d4f703f7dc76f85bf2f760c">dispatch_bootstrap</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;gs, <a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;mut_sys, <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, <a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, bsl::safe_u16 const &amp;ppid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a7e408c172d4f703f7dc76f85bf2f760c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bootstrap process as needed. Note that the bootstrap callback is only called when starting the hypervisor on root VPs.  <a href="namespacesyscall.html#a7e408c172d4f703f7dc76f85bf2f760c">More...</a><br /></td></tr>
<tr class="separator:a7e408c172d4f703f7dc76f85bf2f760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777d105758a8fbd2486be5e1db2e92e6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a777d105758a8fbd2486be5e1db2e92e6">dispatch_fail</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;gs, <a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classsyscall_1_1bf__syscall__t.html">syscall::bf_syscall_t</a> const &amp;sys, <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, <a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, <a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u64 const &amp;errc, bsl::safe_u64 const &amp;addr) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a777d105758a8fbd2486be5e1db2e92e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the fail as needed, or returns an error so that the microkernel can halt the PP.  <a href="namespacesyscall.html#a777d105758a8fbd2486be5e1db2e92e6">More...</a><br /></td></tr>
<tr class="separator:a777d105758a8fbd2486be5e1db2e92e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c601348fb90b5eacaaf5da37c2b6291"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a9c601348fb90b5eacaaf5da37c2b6291">dispatch_vmexit</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;gs, <a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;mut_sys, <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, <a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, <a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u16 const &amp;vsid, bsl::safe_u64 const &amp;exit_reason) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a9c601348fb90b5eacaaf5da37c2b6291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the VMExit.  <a href="namespacesyscall.html#a9c601348fb90b5eacaaf5da37c2b6291">More...</a><br /></td></tr>
<tr class="separator:a9c601348fb90b5eacaaf5da37c2b6291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d1a825e37273b8a383684cb0520a0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a4a4d1a825e37273b8a383684cb0520a0">gs_initialize</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;gs, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> const &amp;sys, <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a4a4d1a825e37273b8a383684cb0520a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Global Storage (GS).  <a href="namespacesyscall.html#a4a4d1a825e37273b8a383684cb0520a0">More...</a><br /></td></tr>
<tr class="separator:a4a4d1a825e37273b8a383684cb0520a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7473dc81e4f78dd0e0816b5742ac34"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#abd7473dc81e4f78dd0e0816b5742ac34">tls_initialize</a> (<a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> const &amp;sys, <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:abd7473dc81e4f78dd0e0816b5742ac34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Thread Local Storage (TLS).  <a href="namespacesyscall.html#abd7473dc81e4f78dd0e0816b5742ac34">More...</a><br /></td></tr>
<tr class="separator:abd7473dc81e4f78dd0e0816b5742ac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313bb4626c4abdf92e7269d9529c6065"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a313bb4626c4abdf92e7269d9529c6065">dispatch_vmexit_cpuid</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;gs, <a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;mut_sys, <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a313bb4626c4abdf92e7269d9529c6065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the CPUID VMexit.  <a href="namespacesyscall.html#a313bb4626c4abdf92e7269d9529c6065">More...</a><br /></td></tr>
<tr class="separator:a313bb4626c4abdf92e7269d9529c6065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c601348fb90b5eacaaf5da37c2b6291"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a9c601348fb90b5eacaaf5da37c2b6291">dispatch_vmexit</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;gs, <a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;mut_sys, <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, <a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, <a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u16 const &amp;vsid, bsl::safe_u64 const &amp;exit_reason) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a9c601348fb90b5eacaaf5da37c2b6291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the VMExit.  <a href="namespacesyscall.html#a9c601348fb90b5eacaaf5da37c2b6291">More...</a><br /></td></tr>
<tr class="separator:a9c601348fb90b5eacaaf5da37c2b6291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3598f22234decde7b6f75f2e9bc4cb"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a9f3598f22234decde7b6f75f2e9bc4cb">dispatch_vmexit_nmi</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;gs, <a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;mut_sys, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a9f3598f22234decde7b6f75f2e9bc4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle NMIs. This is required by Intel.  <a href="namespacesyscall.html#a9f3598f22234decde7b6f75f2e9bc4cb">More...</a><br /></td></tr>
<tr class="separator:a9f3598f22234decde7b6f75f2e9bc4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceef7b9d56cda14fa44cf8328fabe6b6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aceef7b9d56cda14fa44cf8328fabe6b6">dispatch_vmexit_nmi_window</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;gs, <a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;mut_sys, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aceef7b9d56cda14fa44cf8328fabe6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle NMIs Windows.  <a href="namespacesyscall.html#aceef7b9d56cda14fa44cf8328fabe6b6">More...</a><br /></td></tr>
<tr class="separator:aceef7b9d56cda14fa44cf8328fabe6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b221af3c62ca2c8a5d1ff45aa7b9915"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a6b221af3c62ca2c8a5d1ff45aa7b9915">gs_initialize</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> &amp;mut_gs, <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;mut_sys, <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a6b221af3c62ca2c8a5d1ff45aa7b9915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Global Storage (GS).  <a href="namespacesyscall.html#a6b221af3c62ca2c8a5d1ff45aa7b9915">More...</a><br /></td></tr>
<tr class="separator:a6b221af3c62ca2c8a5d1ff45aa7b9915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27da9bf1217e3a1dfc8fba7ed688249"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aa27da9bf1217e3a1dfc8fba7ed688249">ctls_mask</a> (bsl::safe_u64 const &amp;val) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aa27da9bf1217e3a1dfc8fba7ed688249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the masked version of the VMCS control fields.  <a href="namespacesyscall.html#aa27da9bf1217e3a1dfc8fba7ed688249">More...</a><br /></td></tr>
<tr class="separator:aa27da9bf1217e3a1dfc8fba7ed688249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d809420c90180c9ed61fcaf2671272"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#af3d809420c90180c9ed61fcaf2671272">intrinsic_cpuid_impl</a> (<a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const *const gs, bsl::uint64 *const pmut_rax, bsl::uint64 *const pmut_rbx, bsl::uint64 *const pmut_rcx, bsl::uint64 *const pmut_rdx) noexcept</td></tr>
<tr class="memdesc:af3d809420c90180c9ed61fcaf2671272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the CPUID instruction given the provided EAX and ECX and returns the results.  <a href="namespacesyscall.html#af3d809420c90180c9ed61fcaf2671272">More...</a><br /></td></tr>
<tr class="separator:af3d809420c90180c9ed61fcaf2671272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1429c7888cde3b43234ce79bcafab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a5d1429c7888cde3b43234ce79bcafab3">bf_debug_op_write_c_impl</a> (bsl::char_type const reg0_in) noexcept</td></tr>
<tr class="memdesc:a5d1429c7888cde3b43234ce79bcafab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_write_c.  <a href="namespacesyscall.html#a5d1429c7888cde3b43234ce79bcafab3">More...</a><br /></td></tr>
<tr class="separator:a5d1429c7888cde3b43234ce79bcafab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56b557d471fdec839ee3db8a832d1d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ae56b557d471fdec839ee3db8a832d1d8">bf_debug_op_write_str_impl</a> (bsl::char_type const *const reg0_in, bsl::uintmx const reg1_in) noexcept</td></tr>
<tr class="memdesc:ae56b557d471fdec839ee3db8a832d1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_write_str.  <a href="namespacesyscall.html#ae56b557d471fdec839ee3db8a832d1d8">More...</a><br /></td></tr>
<tr class="separator:ae56b557d471fdec839ee3db8a832d1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8902b1641cfb10c26b0dd3cca709fbf2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a8902b1641cfb10c26b0dd3cca709fbf2">bf_is_page_aligned</a> (bsl::safe_u64 const &amp;addr) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a8902b1641cfb10c26b0dd3cca709fbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided address is 4k page aligned, returns false otherwise.  <a href="namespacesyscall.html#a8902b1641cfb10c26b0dd3cca709fbf2">More...</a><br /></td></tr>
<tr class="separator:a8902b1641cfb10c26b0dd3cca709fbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce4996d13c91cbe1d4ff513825259d0"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#acce4996d13c91cbe1d4ff513825259d0">bf_page_aligned</a> (bsl::safe_umx const &amp;addr) noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:acce4996d13c91cbe1d4ff513825259d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page aligned version of the addr.  <a href="namespacesyscall.html#acce4996d13c91cbe1d4ff513825259d0">More...</a><br /></td></tr>
<tr class="separator:acce4996d13c91cbe1d4ff513825259d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef10bcd3b4c711f61158b99f87cb9767"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aef10bcd3b4c711f61158b99f87cb9767">bf_syscall_sig</a> (bsl::uint64 const &amp;rax) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aef10bcd3b4c711f61158b99f87cb9767"><td class="mdescLeft">&#160;</td><td class="mdescRight">n/a  <a href="namespacesyscall.html#aef10bcd3b4c711f61158b99f87cb9767">More...</a><br /></td></tr>
<tr class="separator:aef10bcd3b4c711f61158b99f87cb9767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dfae2295a25b28b9f857edd09559a6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aa5dfae2295a25b28b9f857edd09559a6">bf_syscall_flags</a> (bsl::uint64 const &amp;rax) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:aa5dfae2295a25b28b9f857edd09559a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">n/a  <a href="namespacesyscall.html#aa5dfae2295a25b28b9f857edd09559a6">More...</a><br /></td></tr>
<tr class="separator:aa5dfae2295a25b28b9f857edd09559a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe2ca295edfa1eb15f67d759a29773a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a3fe2ca295edfa1eb15f67d759a29773a">bf_syscall_opcode</a> (bsl::uint64 const &amp;rax) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a3fe2ca295edfa1eb15f67d759a29773a"><td class="mdescLeft">&#160;</td><td class="mdescRight">n/a  <a href="namespacesyscall.html#a3fe2ca295edfa1eb15f67d759a29773a">More...</a><br /></td></tr>
<tr class="separator:a3fe2ca295edfa1eb15f67d759a29773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8f4c9caf8c2e1af3ee5bc575a6bc24"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a1e8f4c9caf8c2e1af3ee5bc575a6bc24">bf_syscall_opcode_nosig</a> (bsl::uint64 const &amp;rax) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a1e8f4c9caf8c2e1af3ee5bc575a6bc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">n/a  <a href="namespacesyscall.html#a1e8f4c9caf8c2e1af3ee5bc575a6bc24">More...</a><br /></td></tr>
<tr class="separator:a1e8f4c9caf8c2e1af3ee5bc575a6bc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9199d36f01cc32ec37529db2bd3d6132"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a9199d36f01cc32ec37529db2bd3d6132">bf_syscall_index</a> (bsl::uint64 const &amp;rax) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a9199d36f01cc32ec37529db2bd3d6132"><td class="mdescLeft">&#160;</td><td class="mdescRight">n/a  <a href="namespacesyscall.html#a9199d36f01cc32ec37529db2bd3d6132">More...</a><br /></td></tr>
<tr class="separator:a9199d36f01cc32ec37529db2bd3d6132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9de2ccc5b2057fc2349dd625382cc23"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ad9de2ccc5b2057fc2349dd625382cc23">bf_is_spec1_supported</a> (bsl::safe_u32 const &amp;version) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ad9de2ccc5b2057fc2349dd625382cc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">n/a  <a href="namespacesyscall.html#ad9de2ccc5b2057fc2349dd625382cc23">More...</a><br /></td></tr>
<tr class="separator:ad9de2ccc5b2057fc2349dd625382cc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccae35c404865bc999a327c982e7d28"><td class="memItemLeft" align="right" valign="top"><a id="a6ccae35c404865bc999a327c982e7d28" name="a6ccae35c404865bc999a327c982e7d28"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_control_op_exit</b> () noexcept</td></tr>
<tr class="memdesc:a6ccae35c404865bc999a327c982e7d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to exit the execution of an extension, providing a means to fast fail. <br /></td></tr>
<tr class="separator:a6ccae35c404865bc999a327c982e7d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafe07a3cba8fb4da5e94ec81e8f7f16"><td class="memItemLeft" align="right" valign="top"><a id="adafe07a3cba8fb4da5e94ec81e8f7f16" name="adafe07a3cba8fb4da5e94ec81e8f7f16"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_control_op_wait</b> () noexcept</td></tr>
<tr class="memdesc:adafe07a3cba8fb4da5e94ec81e8f7f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel that the extension would like to wait for a callback. This is a blocking syscall that never returns and should be used to return from the successful execution of the _start function. <br /></td></tr>
<tr class="separator:adafe07a3cba8fb4da5e94ec81e8f7f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6560bcb0682659e93ffaed27690007"><td class="memItemLeft" align="right" valign="top"><a id="a3b6560bcb0682659e93ffaed27690007" name="a3b6560bcb0682659e93ffaed27690007"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_control_op_again</b> () noexcept</td></tr>
<tr class="memdesc:a3b6560bcb0682659e93ffaed27690007"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel that the extension would like to try again from a fast fail callback. This syscall is a blocking syscall that never returns and should be used to return from the fail_entry function. <br /></td></tr>
<tr class="separator:a3b6560bcb0682659e93ffaed27690007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f95b5fa9595f5ebf41e72467062d77"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a19f95b5fa9595f5ebf41e72467062d77">bf_debug_op_out</a> (bsl::safe_u64 const &amp;val1, bsl::safe_u64 const &amp;val2) noexcept</td></tr>
<tr class="memdesc:a19f95b5fa9595f5ebf41e72467062d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output reg0 and reg1 to the console device the microkernel is currently using for debugging.  <a href="namespacesyscall.html#a19f95b5fa9595f5ebf41e72467062d77">More...</a><br /></td></tr>
<tr class="separator:a19f95b5fa9595f5ebf41e72467062d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb54c9251cd14af0ac10afeaa01901fe"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#abb54c9251cd14af0ac10afeaa01901fe">bf_debug_op_dump_vm</a> (bsl::safe_u16 const &amp;vmid) noexcept</td></tr>
<tr class="memdesc:abb54c9251cd14af0ac10afeaa01901fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output the state of a VM to the console device the microkernel is currently using for debugging.  <a href="namespacesyscall.html#abb54c9251cd14af0ac10afeaa01901fe">More...</a><br /></td></tr>
<tr class="separator:abb54c9251cd14af0ac10afeaa01901fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c27c77909a2ee1319b45ddea97d7f9e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a9c27c77909a2ee1319b45ddea97d7f9e">bf_debug_op_dump_vp</a> (bsl::safe_u16 const &amp;vpid) noexcept</td></tr>
<tr class="memdesc:a9c27c77909a2ee1319b45ddea97d7f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output the state of a VP to the console device the microkernel is currently using for debugging.  <a href="namespacesyscall.html#a9c27c77909a2ee1319b45ddea97d7f9e">More...</a><br /></td></tr>
<tr class="separator:a9c27c77909a2ee1319b45ddea97d7f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d3d55db4fea5d801d6cc57b35d0087"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a94d3d55db4fea5d801d6cc57b35d0087">bf_debug_op_dump_vs</a> (bsl::safe_u16 const &amp;vsid) noexcept</td></tr>
<tr class="memdesc:a94d3d55db4fea5d801d6cc57b35d0087"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output the state of a VS to the console device the microkernel is currently using for debugging.  <a href="namespacesyscall.html#a94d3d55db4fea5d801d6cc57b35d0087">More...</a><br /></td></tr>
<tr class="separator:a94d3d55db4fea5d801d6cc57b35d0087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89a633c35b09d0369622260e52556d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a6e89a633c35b09d0369622260e52556d">bf_debug_op_dump_vmexit_log</a> (bsl::safe_u16 const &amp;ppid) noexcept</td></tr>
<tr class="memdesc:a6e89a633c35b09d0369622260e52556d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output the VMExit log. The VMExit log is a chronological log of the "X" number of exits that have occurred on a specific physical processor.  <a href="namespacesyscall.html#a6e89a633c35b09d0369622260e52556d">More...</a><br /></td></tr>
<tr class="separator:a6e89a633c35b09d0369622260e52556d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f7b9589e3252f5451dcfed41ec5409"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ab3f7b9589e3252f5451dcfed41ec5409">bf_debug_op_write_c</a> (bsl::char_type const c) noexcept</td></tr>
<tr class="memdesc:ab3f7b9589e3252f5451dcfed41ec5409"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output a provided character to the microkernel's console.  <a href="namespacesyscall.html#ab3f7b9589e3252f5451dcfed41ec5409">More...</a><br /></td></tr>
<tr class="separator:ab3f7b9589e3252f5451dcfed41ec5409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7921e6139c4ce39571d78c373d9efa8f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a7921e6139c4ce39571d78c373d9efa8f">bf_debug_op_write_str</a> (bsl::cstr_type const str, bsl::uintmx const len) noexcept</td></tr>
<tr class="memdesc:a7921e6139c4ce39571d78c373d9efa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output a provided string to the microkernel's console.  <a href="namespacesyscall.html#a7921e6139c4ce39571d78c373d9efa8f">More...</a><br /></td></tr>
<tr class="separator:a7921e6139c4ce39571d78c373d9efa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd0a56efd39f21d4303b96876833b8f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aabd0a56efd39f21d4303b96876833b8f">bf_debug_op_dump_ext</a> (bsl::safe_u16 const &amp;extid) noexcept</td></tr>
<tr class="memdesc:aabd0a56efd39f21d4303b96876833b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output an extension's state to the console device the microkernel is currently using for debugging.  <a href="namespacesyscall.html#aabd0a56efd39f21d4303b96876833b8f">More...</a><br /></td></tr>
<tr class="separator:aabd0a56efd39f21d4303b96876833b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bd99f5a31fa74716dbf3737e0fa6fe"><td class="memItemLeft" align="right" valign="top"><a id="ab3bd99f5a31fa74716dbf3737e0fa6fe" name="ab3bd99f5a31fa74716dbf3737e0fa6fe"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_debug_op_dump_page_pool</b> () noexcept</td></tr>
<tr class="memdesc:ab3bd99f5a31fa74716dbf3737e0fa6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output the page pool's stats to the console device the microkernel is currently using for debugging. <br /></td></tr>
<tr class="separator:ab3bd99f5a31fa74716dbf3737e0fa6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8fe33f4e1b7db68cdc56444397ad7"><td class="memItemLeft" align="right" valign="top"><a id="a7ad8fe33f4e1b7db68cdc56444397ad7" name="a7ad8fe33f4e1b7db68cdc56444397ad7"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_debug_op_dump_huge_pool</b> () noexcept</td></tr>
<tr class="memdesc:a7ad8fe33f4e1b7db68cdc56444397ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This syscall tells the microkernel to output the huge pool's stats to the console device the microkernel is currently using for debugging. <br /></td></tr>
<tr class="separator:a7ad8fe33f4e1b7db68cdc56444397ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c5cbf03e54b1f1cdfb321a3491bf6e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ab2c5cbf03e54b1f1cdfb321a3491bf6e">bf_tls_rax_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ab2c5cbf03e54b1f1cdfb321a3491bf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_rax.  <a href="namespacesyscall.html#ab2c5cbf03e54b1f1cdfb321a3491bf6e">More...</a><br /></td></tr>
<tr class="separator:ab2c5cbf03e54b1f1cdfb321a3491bf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25caa49fe12448c113fb881a26cad8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ad25caa49fe12448c113fb881a26cad8c">bf_tls_set_rax_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:ad25caa49fe12448c113fb881a26cad8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_rax.  <a href="namespacesyscall.html#ad25caa49fe12448c113fb881a26cad8c">More...</a><br /></td></tr>
<tr class="separator:ad25caa49fe12448c113fb881a26cad8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353692e40a5527d244be7b719df23d28"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a353692e40a5527d244be7b719df23d28">bf_tls_rbx_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a353692e40a5527d244be7b719df23d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_rbx.  <a href="namespacesyscall.html#a353692e40a5527d244be7b719df23d28">More...</a><br /></td></tr>
<tr class="separator:a353692e40a5527d244be7b719df23d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089a641e2b3c92178e648c8c36189d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a089a641e2b3c92178e648c8c36189d67">bf_tls_set_rbx_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a089a641e2b3c92178e648c8c36189d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_rbx.  <a href="namespacesyscall.html#a089a641e2b3c92178e648c8c36189d67">More...</a><br /></td></tr>
<tr class="separator:a089a641e2b3c92178e648c8c36189d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff4446081d794c983a8ffff1505c1ad"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a6ff4446081d794c983a8ffff1505c1ad">bf_tls_rcx_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a6ff4446081d794c983a8ffff1505c1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_rcx.  <a href="namespacesyscall.html#a6ff4446081d794c983a8ffff1505c1ad">More...</a><br /></td></tr>
<tr class="separator:a6ff4446081d794c983a8ffff1505c1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab3fe34be47ef7acb606900ca2dd96f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aaab3fe34be47ef7acb606900ca2dd96f">bf_tls_set_rcx_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:aaab3fe34be47ef7acb606900ca2dd96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_rcx.  <a href="namespacesyscall.html#aaab3fe34be47ef7acb606900ca2dd96f">More...</a><br /></td></tr>
<tr class="separator:aaab3fe34be47ef7acb606900ca2dd96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7f9ab2dc2d815651e5cc03cecd543c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a3a7f9ab2dc2d815651e5cc03cecd543c">bf_tls_rdx_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a3a7f9ab2dc2d815651e5cc03cecd543c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_rdx.  <a href="namespacesyscall.html#a3a7f9ab2dc2d815651e5cc03cecd543c">More...</a><br /></td></tr>
<tr class="separator:a3a7f9ab2dc2d815651e5cc03cecd543c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d2b1acf7e3c1204c749eb51ab25bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a28d2b1acf7e3c1204c749eb51ab25bf1">bf_tls_set_rdx_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a28d2b1acf7e3c1204c749eb51ab25bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_rdx.  <a href="namespacesyscall.html#a28d2b1acf7e3c1204c749eb51ab25bf1">More...</a><br /></td></tr>
<tr class="separator:a28d2b1acf7e3c1204c749eb51ab25bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b66063b3797a733270bb602e0455d6c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a5b66063b3797a733270bb602e0455d6c">bf_tls_rbp_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a5b66063b3797a733270bb602e0455d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_rbp.  <a href="namespacesyscall.html#a5b66063b3797a733270bb602e0455d6c">More...</a><br /></td></tr>
<tr class="separator:a5b66063b3797a733270bb602e0455d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a1a235ab778ca775160aa43dbb369e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a08a1a235ab778ca775160aa43dbb369e">bf_tls_set_rbp_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a08a1a235ab778ca775160aa43dbb369e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_rbp.  <a href="namespacesyscall.html#a08a1a235ab778ca775160aa43dbb369e">More...</a><br /></td></tr>
<tr class="separator:a08a1a235ab778ca775160aa43dbb369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a0a3a7352c1ace47f684786c65ecea"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#af4a0a3a7352c1ace47f684786c65ecea">bf_tls_rsi_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:af4a0a3a7352c1ace47f684786c65ecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_rsi.  <a href="namespacesyscall.html#af4a0a3a7352c1ace47f684786c65ecea">More...</a><br /></td></tr>
<tr class="separator:af4a0a3a7352c1ace47f684786c65ecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee15d7f07ab09fa77e769e8b2ba89c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a1ee15d7f07ab09fa77e769e8b2ba89c4">bf_tls_set_rsi_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a1ee15d7f07ab09fa77e769e8b2ba89c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_rsi.  <a href="namespacesyscall.html#a1ee15d7f07ab09fa77e769e8b2ba89c4">More...</a><br /></td></tr>
<tr class="separator:a1ee15d7f07ab09fa77e769e8b2ba89c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46595d057d7f94eabb75a28199c3128"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ae46595d057d7f94eabb75a28199c3128">bf_tls_rdi_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ae46595d057d7f94eabb75a28199c3128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_rdi.  <a href="namespacesyscall.html#ae46595d057d7f94eabb75a28199c3128">More...</a><br /></td></tr>
<tr class="separator:ae46595d057d7f94eabb75a28199c3128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd937235379bbdd943d36087d78dd3e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#afd937235379bbdd943d36087d78dd3e7">bf_tls_set_rdi_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:afd937235379bbdd943d36087d78dd3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_rdi.  <a href="namespacesyscall.html#afd937235379bbdd943d36087d78dd3e7">More...</a><br /></td></tr>
<tr class="separator:afd937235379bbdd943d36087d78dd3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef909ea7e108faf9f7974066d6ad7517"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aef909ea7e108faf9f7974066d6ad7517">bf_tls_r8_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:aef909ea7e108faf9f7974066d6ad7517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_r8.  <a href="namespacesyscall.html#aef909ea7e108faf9f7974066d6ad7517">More...</a><br /></td></tr>
<tr class="separator:aef909ea7e108faf9f7974066d6ad7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6f07259e4fcb139f63fd7ff1cdb9a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a2c6f07259e4fcb139f63fd7ff1cdb9a2">bf_tls_set_r8_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a2c6f07259e4fcb139f63fd7ff1cdb9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_r8.  <a href="namespacesyscall.html#a2c6f07259e4fcb139f63fd7ff1cdb9a2">More...</a><br /></td></tr>
<tr class="separator:a2c6f07259e4fcb139f63fd7ff1cdb9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67101c478625caa85cb674c9a8d344df"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a67101c478625caa85cb674c9a8d344df">bf_tls_r9_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a67101c478625caa85cb674c9a8d344df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_r9.  <a href="namespacesyscall.html#a67101c478625caa85cb674c9a8d344df">More...</a><br /></td></tr>
<tr class="separator:a67101c478625caa85cb674c9a8d344df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea7b4c0b2739a46bf8b8019dbe09795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a5ea7b4c0b2739a46bf8b8019dbe09795">bf_tls_set_r9_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a5ea7b4c0b2739a46bf8b8019dbe09795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_r9.  <a href="namespacesyscall.html#a5ea7b4c0b2739a46bf8b8019dbe09795">More...</a><br /></td></tr>
<tr class="separator:a5ea7b4c0b2739a46bf8b8019dbe09795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee9d1aa0f263fac5f32032e61850ff3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#afee9d1aa0f263fac5f32032e61850ff3">bf_tls_r10_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:afee9d1aa0f263fac5f32032e61850ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_r10.  <a href="namespacesyscall.html#afee9d1aa0f263fac5f32032e61850ff3">More...</a><br /></td></tr>
<tr class="separator:afee9d1aa0f263fac5f32032e61850ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b0387b79d06bce8ec03517e341d1e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a05b0387b79d06bce8ec03517e341d1e7">bf_tls_set_r10_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a05b0387b79d06bce8ec03517e341d1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_r10.  <a href="namespacesyscall.html#a05b0387b79d06bce8ec03517e341d1e7">More...</a><br /></td></tr>
<tr class="separator:a05b0387b79d06bce8ec03517e341d1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a4865a75bf208d5e73902c09d2067d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a56a4865a75bf208d5e73902c09d2067d">bf_tls_r11_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a56a4865a75bf208d5e73902c09d2067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_r11.  <a href="namespacesyscall.html#a56a4865a75bf208d5e73902c09d2067d">More...</a><br /></td></tr>
<tr class="separator:a56a4865a75bf208d5e73902c09d2067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab922b95f098c43eac17ad421d51721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a9ab922b95f098c43eac17ad421d51721">bf_tls_set_r11_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a9ab922b95f098c43eac17ad421d51721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_r11.  <a href="namespacesyscall.html#a9ab922b95f098c43eac17ad421d51721">More...</a><br /></td></tr>
<tr class="separator:a9ab922b95f098c43eac17ad421d51721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8355ed161bb0a7da6e19a9c3352d7330"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a8355ed161bb0a7da6e19a9c3352d7330">bf_tls_r12_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a8355ed161bb0a7da6e19a9c3352d7330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_r12.  <a href="namespacesyscall.html#a8355ed161bb0a7da6e19a9c3352d7330">More...</a><br /></td></tr>
<tr class="separator:a8355ed161bb0a7da6e19a9c3352d7330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82857b970e5e13434b8adbb14b809717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a82857b970e5e13434b8adbb14b809717">bf_tls_set_r12_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a82857b970e5e13434b8adbb14b809717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_r12.  <a href="namespacesyscall.html#a82857b970e5e13434b8adbb14b809717">More...</a><br /></td></tr>
<tr class="separator:a82857b970e5e13434b8adbb14b809717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99c862dd5e45328612d2b284e37c004"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ac99c862dd5e45328612d2b284e37c004">bf_tls_r13_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ac99c862dd5e45328612d2b284e37c004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_r13.  <a href="namespacesyscall.html#ac99c862dd5e45328612d2b284e37c004">More...</a><br /></td></tr>
<tr class="separator:ac99c862dd5e45328612d2b284e37c004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a25c8931b84d7406dae8af976ba563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a58a25c8931b84d7406dae8af976ba563">bf_tls_set_r13_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a58a25c8931b84d7406dae8af976ba563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_r13.  <a href="namespacesyscall.html#a58a25c8931b84d7406dae8af976ba563">More...</a><br /></td></tr>
<tr class="separator:a58a25c8931b84d7406dae8af976ba563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308165fa871eb1f85e13208e2734d613"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a308165fa871eb1f85e13208e2734d613">bf_tls_r14_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a308165fa871eb1f85e13208e2734d613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_r14.  <a href="namespacesyscall.html#a308165fa871eb1f85e13208e2734d613">More...</a><br /></td></tr>
<tr class="separator:a308165fa871eb1f85e13208e2734d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b92a1aed1619cb9c1b4fb016dd727d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a2b92a1aed1619cb9c1b4fb016dd727d7">bf_tls_set_r14_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a2b92a1aed1619cb9c1b4fb016dd727d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_r14.  <a href="namespacesyscall.html#a2b92a1aed1619cb9c1b4fb016dd727d7">More...</a><br /></td></tr>
<tr class="separator:a2b92a1aed1619cb9c1b4fb016dd727d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d615e1a5046e226912b3573bd9b71a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ae7d615e1a5046e226912b3573bd9b71a">bf_tls_r15_impl</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ae7d615e1a5046e226912b3573bd9b71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_r15.  <a href="namespacesyscall.html#ae7d615e1a5046e226912b3573bd9b71a">More...</a><br /></td></tr>
<tr class="separator:ae7d615e1a5046e226912b3573bd9b71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3d45786ca0223c9c3f1c128ef64f4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ada3d45786ca0223c9c3f1c128ef64f4b">bf_tls_set_r15_impl</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:ada3d45786ca0223c9c3f1c128ef64f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_set_r15.  <a href="namespacesyscall.html#ada3d45786ca0223c9c3f1c128ef64f4b">More...</a><br /></td></tr>
<tr class="separator:ada3d45786ca0223c9c3f1c128ef64f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936341cbd448d690db392d469eee28a9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a936341cbd448d690db392d469eee28a9">bf_tls_extid_impl</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:a936341cbd448d690db392d469eee28a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_extid.  <a href="namespacesyscall.html#a936341cbd448d690db392d469eee28a9">More...</a><br /></td></tr>
<tr class="separator:a936341cbd448d690db392d469eee28a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a388401bb280940c6234359f3fc9fef"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a4a388401bb280940c6234359f3fc9fef">bf_tls_vmid_impl</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:a4a388401bb280940c6234359f3fc9fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_vmid.  <a href="namespacesyscall.html#a4a388401bb280940c6234359f3fc9fef">More...</a><br /></td></tr>
<tr class="separator:a4a388401bb280940c6234359f3fc9fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d7369406fe8fe7df0dd03c794920f0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ab2d7369406fe8fe7df0dd03c794920f0">bf_tls_vpid_impl</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:ab2d7369406fe8fe7df0dd03c794920f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_vpid.  <a href="namespacesyscall.html#ab2d7369406fe8fe7df0dd03c794920f0">More...</a><br /></td></tr>
<tr class="separator:ab2d7369406fe8fe7df0dd03c794920f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641bcd4938f126304761434f4ae57f0c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a641bcd4938f126304761434f4ae57f0c">bf_tls_vsid_impl</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:a641bcd4938f126304761434f4ae57f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_vsid.  <a href="namespacesyscall.html#a641bcd4938f126304761434f4ae57f0c">More...</a><br /></td></tr>
<tr class="separator:a641bcd4938f126304761434f4ae57f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c41a89a67679a0733505f95ed9a4b94"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a2c41a89a67679a0733505f95ed9a4b94">bf_tls_ppid_impl</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:a2c41a89a67679a0733505f95ed9a4b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_ppid.  <a href="namespacesyscall.html#a2c41a89a67679a0733505f95ed9a4b94">More...</a><br /></td></tr>
<tr class="separator:a2c41a89a67679a0733505f95ed9a4b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d0af168228b553d5647b8045eb3f27"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ab4d0af168228b553d5647b8045eb3f27">bf_tls_online_pps_impl</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:ab4d0af168228b553d5647b8045eb3f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_tls_online_pps.  <a href="namespacesyscall.html#ab4d0af168228b553d5647b8045eb3f27">More...</a><br /></td></tr>
<tr class="separator:ab4d0af168228b553d5647b8045eb3f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7125ed59fe061390c0a52d7b3f7345af"><td class="memItemLeft" align="right" valign="top"><a id="a7125ed59fe061390c0a52d7b3f7345af" name="a7125ed59fe061390c0a52d7b3f7345af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_control_op_exit_impl</b> () noexcept</td></tr>
<tr class="memdesc:a7125ed59fe061390c0a52d7b3f7345af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_control_op_exit. <br /></td></tr>
<tr class="separator:a7125ed59fe061390c0a52d7b3f7345af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38af53a0033bdf42e9e6d1f7404d2027"><td class="memItemLeft" align="right" valign="top"><a id="a38af53a0033bdf42e9e6d1f7404d2027" name="a38af53a0033bdf42e9e6d1f7404d2027"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_control_op_wait_impl</b> () noexcept</td></tr>
<tr class="memdesc:a38af53a0033bdf42e9e6d1f7404d2027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_control_op_wait. <br /></td></tr>
<tr class="separator:a38af53a0033bdf42e9e6d1f7404d2027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890d9fa01c22a66e8f100b9e1c58797f"><td class="memItemLeft" align="right" valign="top"><a id="a890d9fa01c22a66e8f100b9e1c58797f" name="a890d9fa01c22a66e8f100b9e1c58797f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_control_op_again_impl</b> () noexcept</td></tr>
<tr class="memdesc:a890d9fa01c22a66e8f100b9e1c58797f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_control_op_again. <br /></td></tr>
<tr class="separator:a890d9fa01c22a66e8f100b9e1c58797f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0618ee9ec570e50a3d187dbe9ae35dfc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a0618ee9ec570e50a3d187dbe9ae35dfc">bf_handle_op_open_handle_impl</a> (bsl::uint32 const reg0_in, bsl::uint64 *const pmut_reg0_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a0618ee9ec570e50a3d187dbe9ae35dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_handle_op_open_handle.  <a href="namespacesyscall.html#a0618ee9ec570e50a3d187dbe9ae35dfc">More...</a><br /></td></tr>
<tr class="separator:a0618ee9ec570e50a3d187dbe9ae35dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528b81780ce39b81600064d7eb83ce8e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a528b81780ce39b81600064d7eb83ce8e">bf_handle_op_close_handle_impl</a> (bsl::uint64 const reg0_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a528b81780ce39b81600064d7eb83ce8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_handle_op_close_handle.  <a href="namespacesyscall.html#a528b81780ce39b81600064d7eb83ce8e">More...</a><br /></td></tr>
<tr class="separator:a528b81780ce39b81600064d7eb83ce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3496bf02a0f98f746c68a2705f06c99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ae3496bf02a0f98f746c68a2705f06c99">bf_debug_op_out_impl</a> (bsl::uint64 const reg0_in, bsl::uint64 const reg1_in) noexcept</td></tr>
<tr class="memdesc:ae3496bf02a0f98f746c68a2705f06c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_out.  <a href="namespacesyscall.html#ae3496bf02a0f98f746c68a2705f06c99">More...</a><br /></td></tr>
<tr class="separator:ae3496bf02a0f98f746c68a2705f06c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e59b1622f9d76092adf0f7d20b1b392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a6e59b1622f9d76092adf0f7d20b1b392">bf_debug_op_dump_vm_impl</a> (bsl::uint16 const reg0_in) noexcept</td></tr>
<tr class="memdesc:a6e59b1622f9d76092adf0f7d20b1b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_dump_vm.  <a href="namespacesyscall.html#a6e59b1622f9d76092adf0f7d20b1b392">More...</a><br /></td></tr>
<tr class="separator:a6e59b1622f9d76092adf0f7d20b1b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84075996ccc30dd8188bd2af2ef41612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a84075996ccc30dd8188bd2af2ef41612">bf_debug_op_dump_vp_impl</a> (bsl::uint16 const reg0_in) noexcept</td></tr>
<tr class="memdesc:a84075996ccc30dd8188bd2af2ef41612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_dump_vp.  <a href="namespacesyscall.html#a84075996ccc30dd8188bd2af2ef41612">More...</a><br /></td></tr>
<tr class="separator:a84075996ccc30dd8188bd2af2ef41612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8966783eb7c2a14142dd93560a870bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ab8966783eb7c2a14142dd93560a870bd">bf_debug_op_dump_vs_impl</a> (bsl::uint16 const reg0_in) noexcept</td></tr>
<tr class="memdesc:ab8966783eb7c2a14142dd93560a870bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_dump_vs.  <a href="namespacesyscall.html#ab8966783eb7c2a14142dd93560a870bd">More...</a><br /></td></tr>
<tr class="separator:ab8966783eb7c2a14142dd93560a870bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50fa594d0f8c83352f1f2155f5da1da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ab50fa594d0f8c83352f1f2155f5da1da">bf_debug_op_dump_vmexit_log_impl</a> (bsl::uint16 const reg0_in) noexcept</td></tr>
<tr class="memdesc:ab50fa594d0f8c83352f1f2155f5da1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_dump_vmexit_log.  <a href="namespacesyscall.html#ab50fa594d0f8c83352f1f2155f5da1da">More...</a><br /></td></tr>
<tr class="separator:ab50fa594d0f8c83352f1f2155f5da1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653e7dda4b032c4c0c787c00a4d1159a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a653e7dda4b032c4c0c787c00a4d1159a">bf_debug_op_dump_ext_impl</a> (bsl::uint16 const reg0_in) noexcept</td></tr>
<tr class="memdesc:a653e7dda4b032c4c0c787c00a4d1159a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_dump_ext.  <a href="namespacesyscall.html#a653e7dda4b032c4c0c787c00a4d1159a">More...</a><br /></td></tr>
<tr class="separator:a653e7dda4b032c4c0c787c00a4d1159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1135bfbc094cbb9ce597b6c394bc7086"><td class="memItemLeft" align="right" valign="top"><a id="a1135bfbc094cbb9ce597b6c394bc7086" name="a1135bfbc094cbb9ce597b6c394bc7086"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_debug_op_dump_page_pool_impl</b> () noexcept</td></tr>
<tr class="memdesc:a1135bfbc094cbb9ce597b6c394bc7086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_dump_page_pool. <br /></td></tr>
<tr class="separator:a1135bfbc094cbb9ce597b6c394bc7086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f7f1e4beb57e1efcbe6a75a11b770"><td class="memItemLeft" align="right" valign="top"><a id="a6e4f7f1e4beb57e1efcbe6a75a11b770" name="a6e4f7f1e4beb57e1efcbe6a75a11b770"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bf_debug_op_dump_huge_pool_impl</b> () noexcept</td></tr>
<tr class="memdesc:a6e4f7f1e4beb57e1efcbe6a75a11b770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_debug_op_dump_huge_pool. <br /></td></tr>
<tr class="separator:a6e4f7f1e4beb57e1efcbe6a75a11b770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5f0e8964484f8f6c75875589011eb3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a3f5f0e8964484f8f6c75875589011eb3">bf_callback_op_register_bootstrap_impl</a> (bsl::uint64 const reg0_in, <a class="el" href="namespacesyscall.html#ade5384db1d6d8a0b23754219e5ab09af">bf_callback_handler_bootstrap_t</a> const pmut_reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a3f5f0e8964484f8f6c75875589011eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_callback_op_register_bootstrap.  <a href="namespacesyscall.html#a3f5f0e8964484f8f6c75875589011eb3">More...</a><br /></td></tr>
<tr class="separator:a3f5f0e8964484f8f6c75875589011eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4151657acbaacf84630c7fbeef54b71"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aa4151657acbaacf84630c7fbeef54b71">bf_callback_op_register_vmexit_impl</a> (bsl::uint64 const reg0_in, <a class="el" href="namespacesyscall.html#a6e24a9c2a154fcf5ac59d3f0164b567b">bf_callback_handler_vmexit_t</a> const pmut_reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:aa4151657acbaacf84630c7fbeef54b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_callback_op_register_vmexit.  <a href="namespacesyscall.html#aa4151657acbaacf84630c7fbeef54b71">More...</a><br /></td></tr>
<tr class="separator:aa4151657acbaacf84630c7fbeef54b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeceda3a65c5d4f7f7726465b0a9fa1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#afdeceda3a65c5d4f7f7726465b0a9fa1">bf_callback_op_register_fail_impl</a> (bsl::uint64 const reg0_in, <a class="el" href="namespacesyscall.html#a8d84fbe0f1de9ccdb58661d7850fac82">bf_callback_handler_fail_t</a> const pmut_reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:afdeceda3a65c5d4f7f7726465b0a9fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_callback_op_register_fail.  <a href="namespacesyscall.html#afdeceda3a65c5d4f7f7726465b0a9fa1">More...</a><br /></td></tr>
<tr class="separator:afdeceda3a65c5d4f7f7726465b0a9fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3261df20a4d54976b5f1dccfa44e5e85"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a3261df20a4d54976b5f1dccfa44e5e85">bf_vm_op_create_vm_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 *const pmut_reg0_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a3261df20a4d54976b5f1dccfa44e5e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vm_op_create_vm.  <a href="namespacesyscall.html#a3261df20a4d54976b5f1dccfa44e5e85">More...</a><br /></td></tr>
<tr class="separator:a3261df20a4d54976b5f1dccfa44e5e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69aaac5d2583b2faa3520b24c9f5c525"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a69aaac5d2583b2faa3520b24c9f5c525">bf_vm_op_destroy_vm_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a69aaac5d2583b2faa3520b24c9f5c525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vm_op_destroy_vm.  <a href="namespacesyscall.html#a69aaac5d2583b2faa3520b24c9f5c525">More...</a><br /></td></tr>
<tr class="separator:a69aaac5d2583b2faa3520b24c9f5c525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2771ffe6395939f0808f53852ea3ec04"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a2771ffe6395939f0808f53852ea3ec04">bf_vm_op_map_direct_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint64 const reg2_in, void **const pmut_reg0_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a2771ffe6395939f0808f53852ea3ec04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vm_op_map_direct.  <a href="namespacesyscall.html#a2771ffe6395939f0808f53852ea3ec04">More...</a><br /></td></tr>
<tr class="separator:a2771ffe6395939f0808f53852ea3ec04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8d800aed20722b66cfd65965670f4a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#afd8d800aed20722b66cfd65965670f4a">bf_vm_op_unmap_direct_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint64 const reg2_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:afd8d800aed20722b66cfd65965670f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vm_op_unmap_direct.  <a href="namespacesyscall.html#afd8d800aed20722b66cfd65965670f4a">More...</a><br /></td></tr>
<tr class="separator:afd8d800aed20722b66cfd65965670f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0c908fcdea0a0ae1627e2e7f2559c2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#abf0c908fcdea0a0ae1627e2e7f2559c2">bf_vm_op_unmap_direct_broadcast_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint64 const reg2_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:abf0c908fcdea0a0ae1627e2e7f2559c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vm_op_unmap_direct_broadcast.  <a href="namespacesyscall.html#abf0c908fcdea0a0ae1627e2e7f2559c2">More...</a><br /></td></tr>
<tr class="separator:abf0c908fcdea0a0ae1627e2e7f2559c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ac540bbcee1cdbfc942b91177e6862"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ab0ac540bbcee1cdbfc942b91177e6862">bf_vm_op_tlb_flush_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ab0ac540bbcee1cdbfc942b91177e6862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vm_op_tlb_flush.  <a href="namespacesyscall.html#ab0ac540bbcee1cdbfc942b91177e6862">More...</a><br /></td></tr>
<tr class="separator:ab0ac540bbcee1cdbfc942b91177e6862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad806a27848b38ac4b8cd838194193aa5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ad806a27848b38ac4b8cd838194193aa5">bf_vp_op_create_vp_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint16 *const pmut_reg0_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ad806a27848b38ac4b8cd838194193aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vp_op_create_vp.  <a href="namespacesyscall.html#ad806a27848b38ac4b8cd838194193aa5">More...</a><br /></td></tr>
<tr class="separator:ad806a27848b38ac4b8cd838194193aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b7ea4b4c5f98c827ebeea9904362a4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ac6b7ea4b4c5f98c827ebeea9904362a4">bf_vp_op_destroy_vp_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ac6b7ea4b4c5f98c827ebeea9904362a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vp_op_destroy_vp.  <a href="namespacesyscall.html#ac6b7ea4b4c5f98c827ebeea9904362a4">More...</a><br /></td></tr>
<tr class="separator:ac6b7ea4b4c5f98c827ebeea9904362a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2d40394add6513c9a0e50b81529851"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aec2d40394add6513c9a0e50b81529851">bf_vs_op_create_vs_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint16 const reg2_in, bsl::uint16 *const pmut_reg0_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:aec2d40394add6513c9a0e50b81529851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_create_vs.  <a href="namespacesyscall.html#aec2d40394add6513c9a0e50b81529851">More...</a><br /></td></tr>
<tr class="separator:aec2d40394add6513c9a0e50b81529851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91c527f400b7f0c74c9259e38db83fe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ae91c527f400b7f0c74c9259e38db83fe">bf_vs_op_destroy_vs_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ae91c527f400b7f0c74c9259e38db83fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_destroy_vs.  <a href="namespacesyscall.html#ae91c527f400b7f0c74c9259e38db83fe">More...</a><br /></td></tr>
<tr class="separator:ae91c527f400b7f0c74c9259e38db83fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0bf0380a516a218a29d8877f386b6c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#abf0bf0380a516a218a29d8877f386b6c">bf_vs_op_init_as_root_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:abf0bf0380a516a218a29d8877f386b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_init_as_root.  <a href="namespacesyscall.html#abf0bf0380a516a218a29d8877f386b6c">More...</a><br /></td></tr>
<tr class="separator:abf0bf0380a516a218a29d8877f386b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4910a95386b04d2a0f3e1ea67dddf74"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ae4910a95386b04d2a0f3e1ea67dddf74">bf_vs_op_read_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg2_in, bsl::uint64 *const pmut_reg0_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ae4910a95386b04d2a0f3e1ea67dddf74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_read_impl.  <a href="namespacesyscall.html#ae4910a95386b04d2a0f3e1ea67dddf74">More...</a><br /></td></tr>
<tr class="separator:ae4910a95386b04d2a0f3e1ea67dddf74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a10dd549ac91eee775b12e160adb4d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a92a10dd549ac91eee775b12e160adb4d">bf_vs_op_write_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const reg2_in, bsl::uint64 const reg3_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a92a10dd549ac91eee775b12e160adb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_write.  <a href="namespacesyscall.html#a92a10dd549ac91eee775b12e160adb4d">More...</a><br /></td></tr>
<tr class="separator:a92a10dd549ac91eee775b12e160adb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6db25af36629d7b39ff8806d39d692"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#aae6db25af36629d7b39ff8806d39d692">bf_vs_op_run_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint16 const reg2_in, bsl::uint16 const reg3_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:aae6db25af36629d7b39ff8806d39d692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_run.  <a href="namespacesyscall.html#aae6db25af36629d7b39ff8806d39d692">More...</a><br /></td></tr>
<tr class="separator:aae6db25af36629d7b39ff8806d39d692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e0dd82459854c95df9e131988f7441"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a93e0dd82459854c95df9e131988f7441">bf_vs_op_run_current_impl</a> (bsl::uint64 const reg0_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a93e0dd82459854c95df9e131988f7441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_run_current.  <a href="namespacesyscall.html#a93e0dd82459854c95df9e131988f7441">More...</a><br /></td></tr>
<tr class="separator:a93e0dd82459854c95df9e131988f7441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcc6d95425bbcc4cf8552c4100d63a2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a5dcc6d95425bbcc4cf8552c4100d63a2">bf_vs_op_advance_ip_and_run_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint16 const reg2_in, bsl::uint16 const reg3_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a5dcc6d95425bbcc4cf8552c4100d63a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_advance_ip_and_run.  <a href="namespacesyscall.html#a5dcc6d95425bbcc4cf8552c4100d63a2">More...</a><br /></td></tr>
<tr class="separator:a5dcc6d95425bbcc4cf8552c4100d63a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ace049cf912a7ab3e181122e40ba862"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a1ace049cf912a7ab3e181122e40ba862">bf_vs_op_advance_ip_and_run_current_impl</a> (bsl::uint64 const reg0_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a1ace049cf912a7ab3e181122e40ba862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_advance_ip_and_run_current.  <a href="namespacesyscall.html#a1ace049cf912a7ab3e181122e40ba862">More...</a><br /></td></tr>
<tr class="separator:a1ace049cf912a7ab3e181122e40ba862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d44c838edbf31b256a6168938a9f84d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a7d44c838edbf31b256a6168938a9f84d">bf_vs_op_promote_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a7d44c838edbf31b256a6168938a9f84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_promote.  <a href="namespacesyscall.html#a7d44c838edbf31b256a6168938a9f84d">More...</a><br /></td></tr>
<tr class="separator:a7d44c838edbf31b256a6168938a9f84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14daee9335a09588fd1d7d2e75982def"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a14daee9335a09588fd1d7d2e75982def">bf_vs_op_clear_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a14daee9335a09588fd1d7d2e75982def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_clear.  <a href="namespacesyscall.html#a14daee9335a09588fd1d7d2e75982def">More...</a><br /></td></tr>
<tr class="separator:a14daee9335a09588fd1d7d2e75982def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9eb432e30d33387a42494b299ea96"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a13e9eb432e30d33387a42494b299ea96">bf_vs_op_migrate_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint16 const reg2_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a13e9eb432e30d33387a42494b299ea96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_migrate.  <a href="namespacesyscall.html#a13e9eb432e30d33387a42494b299ea96">More...</a><br /></td></tr>
<tr class="separator:a13e9eb432e30d33387a42494b299ea96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac773030711f307200b38d41fc1f70ba1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ac773030711f307200b38d41fc1f70ba1">bf_vs_op_set_active_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint16 const reg2_in, bsl::uint16 const reg3_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ac773030711f307200b38d41fc1f70ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_set_active.  <a href="namespacesyscall.html#ac773030711f307200b38d41fc1f70ba1">More...</a><br /></td></tr>
<tr class="separator:ac773030711f307200b38d41fc1f70ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784d530de84afca81be9e51c3e41e04d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a784d530de84afca81be9e51c3e41e04d">bf_vs_op_advance_ip_and_set_active_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint16 const reg2_in, bsl::uint16 const reg3_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a784d530de84afca81be9e51c3e41e04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_advance_ip_and_set_active.  <a href="namespacesyscall.html#a784d530de84afca81be9e51c3e41e04d">More...</a><br /></td></tr>
<tr class="separator:a784d530de84afca81be9e51c3e41e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b36f6f7ce8a6bbc71d24da19c4aadbc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a0b36f6f7ce8a6bbc71d24da19c4aadbc">bf_vs_op_tlb_flush_impl</a> (bsl::uint64 const reg0_in, bsl::uint16 const reg1_in, bsl::uint64 const reg2_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a0b36f6f7ce8a6bbc71d24da19c4aadbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_vs_op_tlb_flush.  <a href="namespacesyscall.html#a0b36f6f7ce8a6bbc71d24da19c4aadbc">More...</a><br /></td></tr>
<tr class="separator:a0b36f6f7ce8a6bbc71d24da19c4aadbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbe87a47b65a6fca3237de3e27662d6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a5bbe87a47b65a6fca3237de3e27662d6">bf_intrinsic_op_rdmsr_impl</a> (bsl::uint64 const reg0_in, bsl::uint32 const reg1_in, bsl::uint64 *const pmut_reg0_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a5bbe87a47b65a6fca3237de3e27662d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_intrinsic_op_rdmsr.  <a href="namespacesyscall.html#a5bbe87a47b65a6fca3237de3e27662d6">More...</a><br /></td></tr>
<tr class="separator:a5bbe87a47b65a6fca3237de3e27662d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191508923b165cccff17a5712be6aa83"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a191508923b165cccff17a5712be6aa83">bf_intrinsic_op_wrmsr_impl</a> (bsl::uint64 const reg0_in, bsl::uint32 const reg1_in, bsl::uint64 const reg2_in) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a191508923b165cccff17a5712be6aa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_intrinsic_op_wrmsr.  <a href="namespacesyscall.html#a191508923b165cccff17a5712be6aa83">More...</a><br /></td></tr>
<tr class="separator:a191508923b165cccff17a5712be6aa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95140d85764d7238b5edddd178f4b32c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a95140d85764d7238b5edddd178f4b32c">bf_mem_op_alloc_page_impl</a> (bsl::uint64 const reg0_in, void **const pmut_reg0_out, bsl::uint64 *const pmut_reg1_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a95140d85764d7238b5edddd178f4b32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_mem_op_alloc_page.  <a href="namespacesyscall.html#a95140d85764d7238b5edddd178f4b32c">More...</a><br /></td></tr>
<tr class="separator:a95140d85764d7238b5edddd178f4b32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29824212e26bb606943ab3c27599d569"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#a29824212e26bb606943ab3c27599d569">bf_mem_op_alloc_huge_impl</a> (bsl::uint64 const reg0_in, bsl::uint64 const reg1_in, void **const pmut_reg0_out, bsl::uint64 *const pmut_reg1_out) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a29824212e26bb606943ab3c27599d569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the ABI for bf_mem_op_alloc_huge.  <a href="namespacesyscall.html#a29824212e26bb606943ab3c27599d569">More...</a><br /></td></tr>
<tr class="separator:a29824212e26bb606943ab3c27599d569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b7f86ee984d3aa0524f9e20ab91479"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#ab4b7f86ee984d3aa0524f9e20ab91479">tests</a> () noexcept -&gt; bsl::exit_code</td></tr>
<tr class="memdesc:ab4b7f86ee984d3aa0524f9e20ab91479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to execute the actual checks. We put the checks in this function so that we can validate the tests both at compile-time and at run-time. If a bsl::ut_check fails, the tests will either fail fast at run-time, or will produce a compile-time error.  <a href="namespacesyscall.html#ab4b7f86ee984d3aa0524f9e20ab91479">More...</a><br /></td></tr>
<tr class="separator:ab4b7f86ee984d3aa0524f9e20ab91479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abb84aa125213fd601fad43c9cec583f1"><td class="memItemLeft" align="right" valign="top">constinit <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyscall.html#abb84aa125213fd601fad43c9cec583f1">g_mut_sys</a> {}</td></tr>
<tr class="memdesc:abb84aa125213fd601fad43c9cec583f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> that this code will use  <a href="namespacesyscall.html#abb84aa125213fd601fad43c9cec583f1">More...</a><br /></td></tr>
<tr class="separator:abb84aa125213fd601fad43c9cec583f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b9c824262d11f870c0573547a983b9"><td class="memItemLeft" align="right" valign="top"><a id="a52b9c824262d11f870c0573547a983b9" name="a52b9c824262d11f870c0573547a983b9"></a>
constinit <a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_intrinsic</b> {}</td></tr>
<tr class="memdesc:a52b9c824262d11f870c0573547a983b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> that this code will use <br /></td></tr>
<tr class="separator:a52b9c824262d11f870c0573547a983b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7b89aa6edb8ebbe06c6ddf13d83a8b"><td class="memItemLeft" align="right" valign="top"><a id="afd7b89aa6edb8ebbe06c6ddf13d83a8b" name="afd7b89aa6edb8ebbe06c6ddf13d83a8b"></a>
constinit <a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_vp_pool</b> {}</td></tr>
<tr class="memdesc:afd7b89aa6edb8ebbe06c6ddf13d83a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the pool of VPs that we will use <br /></td></tr>
<tr class="separator:afd7b89aa6edb8ebbe06c6ddf13d83a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df47821ac466a383f4245fbfcbb428b"><td class="memItemLeft" align="right" valign="top"><a id="a2df47821ac466a383f4245fbfcbb428b" name="a2df47821ac466a383f4245fbfcbb428b"></a>
constinit <a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_vs_pool</b> {}</td></tr>
<tr class="memdesc:a2df47821ac466a383f4245fbfcbb428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the pool of VSs that we will use <br /></td></tr>
<tr class="separator:a2df47821ac466a383f4245fbfcbb428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2ca1abdc34b00053c2b026bad41f52"><td class="memItemLeft" align="right" valign="top"><a id="afa2ca1abdc34b00053c2b026bad41f52" name="afa2ca1abdc34b00053c2b026bad41f52"></a>
constinit <a class="el" href="structsyscall_1_1gs__t.html">gs_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_gs</b> {}</td></tr>
<tr class="memdesc:afa2ca1abdc34b00053c2b026bad41f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the Global Storage for this extension <br /></td></tr>
<tr class="separator:afa2ca1abdc34b00053c2b026bad41f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799e71589cb639a6a566547a6c7da9f8"><td class="memItemLeft" align="right" valign="top"><a id="a799e71589cb639a6a566547a6c7da9f8" name="a799e71589cb639a6a566547a6c7da9f8"></a>
constinit thread_local <a class="el" href="structsyscall_1_1tls__t.html">tls_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_tls</b> {}</td></tr>
<tr class="memdesc:a799e71589cb639a6a566547a6c7da9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the Thread Local Storage for this extension on this PP <br /></td></tr>
<tr class="separator:a799e71589cb639a6a566547a6c7da9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741ea46b30598919151730b0fd79401d"><td class="memItemLeft" align="right" valign="top"><a id="a741ea46b30598919151730b0fd79401d" name="a741ea46b30598919151730b0fd79401d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TLS_SIZE</b> {HYPERVISOR_PAGE_SIZE}</td></tr>
<tr class="memdesc:a741ea46b30598919151730b0fd79401d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the max size supported for the TLS block <br /></td></tr>
<tr class="separator:a741ea46b30598919151730b0fd79401d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694755c639d2f17275ef7716bf9dc12d"><td class="memItemLeft" align="right" valign="top"><a id="a694755c639d2f17275ef7716bf9dc12d" name="a694755c639d2f17275ef7716bf9dc12d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_INVALID_ID</b> {0xFFFF_u16}</td></tr>
<tr class="memdesc:a694755c639d2f17275ef7716bf9dc12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an invalid ID for an extension, VM, VP and VS. <br /></td></tr>
<tr class="separator:a694755c639d2f17275ef7716bf9dc12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e48558e6f2bd6008713edb5ddf52183"><td class="memItemLeft" align="right" valign="top"><a id="a8e48558e6f2bd6008713edb5ddf52183" name="a8e48558e6f2bd6008713edb5ddf52183"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_BS_PPID</b> {0x0_u16}</td></tr>
<tr class="memdesc:a8e48558e6f2bd6008713edb5ddf52183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the bootstrap physical processor ID. <br /></td></tr>
<tr class="separator:a8e48558e6f2bd6008713edb5ddf52183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d76bde1c2ac30929d2364ca47ee6b36"><td class="memItemLeft" align="right" valign="top"><a id="a6d76bde1c2ac30929d2364ca47ee6b36" name="a6d76bde1c2ac30929d2364ca47ee6b36"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_ROOT_VMID</b> {0x0_u16}</td></tr>
<tr class="memdesc:a6d76bde1c2ac30929d2364ca47ee6b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the root virtual machine ID. <br /></td></tr>
<tr class="separator:a6d76bde1c2ac30929d2364ca47ee6b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8fdd8c1f997a094e3a05f85caf9a8d"><td class="memItemLeft" align="right" valign="top"><a id="a5d8fdd8c1f997a094e3a05f85caf9a8d" name="a5d8fdd8c1f997a094e3a05f85caf9a8d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_SUCCESS</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:a5d8fdd8c1f997a094e3a05f85caf9a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the syscall returned successfully. <br /></td></tr>
<tr class="separator:a5d8fdd8c1f997a094e3a05f85caf9a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510171def258911f933d5f8f3f167f2a"><td class="memItemLeft" align="right" valign="top"><a id="a510171def258911f933d5f8f3f167f2a" name="a510171def258911f933d5f8f3f167f2a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_FAILURE_UNKNOWN</b> {0xDEAD000000010001_u64}</td></tr>
<tr class="memdesc:a510171def258911f933d5f8f3f167f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates an unknown error occurred. <br /></td></tr>
<tr class="separator:a510171def258911f933d5f8f3f167f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1532e63719700b37e020bbc3e5277ab8"><td class="memItemLeft" align="right" valign="top"><a id="a1532e63719700b37e020bbc3e5277ab8" name="a1532e63719700b37e020bbc3e5277ab8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_FAILURE_INVALID_HANDLE</b> {0xDEAD000000020001_u64}</td></tr>
<tr class="memdesc:a1532e63719700b37e020bbc3e5277ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the syscall is unsupported. <br /></td></tr>
<tr class="separator:a1532e63719700b37e020bbc3e5277ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159ff5cbb2d567a020ef371c22905182"><td class="memItemLeft" align="right" valign="top"><a id="a159ff5cbb2d567a020ef371c22905182" name="a159ff5cbb2d567a020ef371c22905182"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_FAILURE_UNSUPPORTED</b> {0xDEAD000000040001_u64}</td></tr>
<tr class="memdesc:a159ff5cbb2d567a020ef371c22905182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the provided handle is invalid. <br /></td></tr>
<tr class="separator:a159ff5cbb2d567a020ef371c22905182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00891b3fceb2e09ad08a5dbb2f48e28"><td class="memItemLeft" align="right" valign="top"><a id="ad00891b3fceb2e09ad08a5dbb2f48e28" name="ad00891b3fceb2e09ad08a5dbb2f48e28"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_PERM_DENIED</b> {0xDEAD000000010002_u64}</td></tr>
<tr class="memdesc:ad00891b3fceb2e09ad08a5dbb2f48e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the policy engine denied the syscall. <br /></td></tr>
<tr class="separator:ad00891b3fceb2e09ad08a5dbb2f48e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8683b88ee9098c7e3ca32b20ff602b6"><td class="memItemLeft" align="right" valign="top"><a id="ab8683b88ee9098c7e3ca32b20ff602b6" name="ab8683b88ee9098c7e3ca32b20ff602b6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_INPUT_REG0</b> {0xDEAD000000010003_u64}</td></tr>
<tr class="memdesc:ab8683b88ee9098c7e3ca32b20ff602b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates input reg0 is invalid. <br /></td></tr>
<tr class="separator:ab8683b88ee9098c7e3ca32b20ff602b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb485cb6144e884e522869a4f97bfdab"><td class="memItemLeft" align="right" valign="top"><a id="afb485cb6144e884e522869a4f97bfdab" name="afb485cb6144e884e522869a4f97bfdab"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_INPUT_REG1</b> {0xDEAD000000020003_u64}</td></tr>
<tr class="memdesc:afb485cb6144e884e522869a4f97bfdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates input reg1 is invalid. <br /></td></tr>
<tr class="separator:afb485cb6144e884e522869a4f97bfdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2297bfe4ae98d1916e12f7c0391e11be"><td class="memItemLeft" align="right" valign="top"><a id="a2297bfe4ae98d1916e12f7c0391e11be" name="a2297bfe4ae98d1916e12f7c0391e11be"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_INPUT_REG2</b> {0xDEAD000000040003_u64}</td></tr>
<tr class="memdesc:a2297bfe4ae98d1916e12f7c0391e11be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates input reg2 is invalid. <br /></td></tr>
<tr class="separator:a2297bfe4ae98d1916e12f7c0391e11be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe61240d6ab07d403c0209b8da25a28"><td class="memItemLeft" align="right" valign="top"><a id="a9fe61240d6ab07d403c0209b8da25a28" name="a9fe61240d6ab07d403c0209b8da25a28"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_INPUT_REG3</b> {0xDEAD000000080003_u64}</td></tr>
<tr class="memdesc:a9fe61240d6ab07d403c0209b8da25a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates input reg3 is invalid. <br /></td></tr>
<tr class="separator:a9fe61240d6ab07d403c0209b8da25a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7478ef72f2c328a196f53ba7d44ddbdf"><td class="memItemLeft" align="right" valign="top"><a id="a7478ef72f2c328a196f53ba7d44ddbdf" name="a7478ef72f2c328a196f53ba7d44ddbdf"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_INPUT_REG4</b> {0xDEAD000000100003_u64}</td></tr>
<tr class="memdesc:a7478ef72f2c328a196f53ba7d44ddbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates input reg4 is invalid. <br /></td></tr>
<tr class="separator:a7478ef72f2c328a196f53ba7d44ddbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc85d3a2ab9e2928c04b7985ca589821"><td class="memItemLeft" align="right" valign="top"><a id="abc85d3a2ab9e2928c04b7985ca589821" name="abc85d3a2ab9e2928c04b7985ca589821"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_INPUT_REG5</b> {0xDEAD000000200003_u64}</td></tr>
<tr class="memdesc:abc85d3a2ab9e2928c04b7985ca589821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates input reg5 is invalid. <br /></td></tr>
<tr class="separator:abc85d3a2ab9e2928c04b7985ca589821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e376cc7ff4fdef1e8b5e8509ec675e8"><td class="memItemLeft" align="right" valign="top"><a id="a2e376cc7ff4fdef1e8b5e8509ec675e8" name="a2e376cc7ff4fdef1e8b5e8509ec675e8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_OUTPUT_REG0</b> {0xDEAD000000400003_u64}</td></tr>
<tr class="memdesc:a2e376cc7ff4fdef1e8b5e8509ec675e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates output reg0 is invalid. <br /></td></tr>
<tr class="separator:a2e376cc7ff4fdef1e8b5e8509ec675e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d0bb9a8ef0c79131826ae7b1653319"><td class="memItemLeft" align="right" valign="top"><a id="a33d0bb9a8ef0c79131826ae7b1653319" name="a33d0bb9a8ef0c79131826ae7b1653319"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_OUTPUT_REG1</b> {0xDEAD000000800003_u64}</td></tr>
<tr class="memdesc:a33d0bb9a8ef0c79131826ae7b1653319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates output reg1 is invalid. <br /></td></tr>
<tr class="separator:a33d0bb9a8ef0c79131826ae7b1653319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae044b806123fdbe8237672775e833ab6"><td class="memItemLeft" align="right" valign="top"><a id="ae044b806123fdbe8237672775e833ab6" name="ae044b806123fdbe8237672775e833ab6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_OUTPUT_REG2</b> {0xDEAD000001000003_u64}</td></tr>
<tr class="memdesc:ae044b806123fdbe8237672775e833ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates output reg2 is invalid. <br /></td></tr>
<tr class="separator:ae044b806123fdbe8237672775e833ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e01855b69811fe26c528a3f80c988d"><td class="memItemLeft" align="right" valign="top"><a id="a63e01855b69811fe26c528a3f80c988d" name="a63e01855b69811fe26c528a3f80c988d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_OUTPUT_REG3</b> {0xDEAD000002000003_u64}</td></tr>
<tr class="memdesc:a63e01855b69811fe26c528a3f80c988d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates output reg3 is invalid. <br /></td></tr>
<tr class="separator:a63e01855b69811fe26c528a3f80c988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac97b7c1171796ea55e21289155cb82f"><td class="memItemLeft" align="right" valign="top"><a id="aac97b7c1171796ea55e21289155cb82f" name="aac97b7c1171796ea55e21289155cb82f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_OUTPUT_REG4</b> {0xDEAD000004000003_u64}</td></tr>
<tr class="memdesc:aac97b7c1171796ea55e21289155cb82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates output reg4 is invalid. <br /></td></tr>
<tr class="separator:aac97b7c1171796ea55e21289155cb82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d98f4d025c6a5e9c3d6b0df9579363"><td class="memItemLeft" align="right" valign="top"><a id="a83d98f4d025c6a5e9c3d6b0df9579363" name="a83d98f4d025c6a5e9c3d6b0df9579363"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_STATUS_INVALID_OUTPUT_REG5</b> {0xDEAD000008000003_u64}</td></tr>
<tr class="memdesc:a83d98f4d025c6a5e9c3d6b0df9579363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates output reg5 is invalid. <br /></td></tr>
<tr class="separator:a83d98f4d025c6a5e9c3d6b0df9579363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f447b2195eae8b4a51da079d9107526"><td class="memItemLeft" align="right" valign="top"><a id="a0f447b2195eae8b4a51da079d9107526" name="a0f447b2195eae8b4a51da079d9107526"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_SYSCALL_SIG_VAL</b> {0x6642000000000000_u64}</td></tr>
<tr class="memdesc:a0f447b2195eae8b4a51da079d9107526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the BF_SYSCALL_SIG field for RAX. <br /></td></tr>
<tr class="separator:a0f447b2195eae8b4a51da079d9107526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1d35580ac3b5e77c647f3c8ed397ea"><td class="memItemLeft" align="right" valign="top"><a id="aef1d35580ac3b5e77c647f3c8ed397ea" name="aef1d35580ac3b5e77c647f3c8ed397ea"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_SYSCALL_SIG_MASK</b> {0xFFFF000000000000_u64}</td></tr>
<tr class="memdesc:aef1d35580ac3b5e77c647f3c8ed397ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mask for BF_SYSCALL_SIG. <br /></td></tr>
<tr class="separator:aef1d35580ac3b5e77c647f3c8ed397ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf1eac16a1307db654d4baeef82149a"><td class="memItemLeft" align="right" valign="top"><a id="a1bf1eac16a1307db654d4baeef82149a" name="a1bf1eac16a1307db654d4baeef82149a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_SYSCALL_FLAGS_MASK</b> {0x0000FFFF00000000_u64}</td></tr>
<tr class="memdesc:a1bf1eac16a1307db654d4baeef82149a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mask for BF_SYSCALL_FLAGS. <br /></td></tr>
<tr class="separator:a1bf1eac16a1307db654d4baeef82149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380ab919af0a0421e38bd591942156d5"><td class="memItemLeft" align="right" valign="top"><a id="a380ab919af0a0421e38bd591942156d5" name="a380ab919af0a0421e38bd591942156d5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_SYSCALL_OPCODE_MASK</b> {0xFFFF0000FFFF0000_u64}</td></tr>
<tr class="memdesc:a380ab919af0a0421e38bd591942156d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mask for BF_SYSCALL_OP. <br /></td></tr>
<tr class="separator:a380ab919af0a0421e38bd591942156d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4887d51fe92d43c93d298ec94d337d"><td class="memItemLeft" align="right" valign="top"><a id="abf4887d51fe92d43c93d298ec94d337d" name="abf4887d51fe92d43c93d298ec94d337d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_SYSCALL_OPCODE_NOSIG_MASK</b> {0x00000000FFFF0000_u64}</td></tr>
<tr class="memdesc:abf4887d51fe92d43c93d298ec94d337d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mask for BF_SYSCALL_OP (with no signature added) <br /></td></tr>
<tr class="separator:abf4887d51fe92d43c93d298ec94d337d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1cc6c2b4cbb8b2637a219161416aa9"><td class="memItemLeft" align="right" valign="top"><a id="aef1cc6c2b4cbb8b2637a219161416aa9" name="aef1cc6c2b4cbb8b2637a219161416aa9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_SYSCALL_INDEX_MASK</b> {0x000000000000FFFF_u64}</td></tr>
<tr class="memdesc:aef1cc6c2b4cbb8b2637a219161416aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mask for BF_SYSCALL_IDX. <br /></td></tr>
<tr class="separator:aef1cc6c2b4cbb8b2637a219161416aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a764cefff9aca515a0fb84a309603f"><td class="memItemLeft" align="right" valign="top"><a id="a44a764cefff9aca515a0fb84a309603f" name="a44a764cefff9aca515a0fb84a309603f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_SPEC_ID1_VAL</b> {0x31236642_u32}</td></tr>
<tr class="memdesc:a44a764cefff9aca515a0fb84a309603f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the ID for version #1 of this spec. <br /></td></tr>
<tr class="separator:a44a764cefff9aca515a0fb84a309603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afabfac1e6d92478b2fbb62a548b09c"><td class="memItemLeft" align="right" valign="top"><a id="a7afabfac1e6d92478b2fbb62a548b09c" name="a7afabfac1e6d92478b2fbb62a548b09c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_SPEC_ID1_MASK</b> {0x2_u32}</td></tr>
<tr class="memdesc:a7afabfac1e6d92478b2fbb62a548b09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the mask for checking support for version #1 of this spec. <br /></td></tr>
<tr class="separator:a7afabfac1e6d92478b2fbb62a548b09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51a569a988e7eff8fa4655a2d31707a"><td class="memItemLeft" align="right" valign="top"><a id="ac51a569a988e7eff8fa4655a2d31707a" name="ac51a569a988e7eff8fa4655a2d31707a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_ALL_SPECS_SUPPORTED_VAL</b> {0x2_u32}</td></tr>
<tr class="memdesc:ac51a569a988e7eff8fa4655a2d31707a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all versions supported. <br /></td></tr>
<tr class="separator:ac51a569a988e7eff8fa4655a2d31707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de1f143092a520e3ae76c9c11b08060"><td class="memItemLeft" align="right" valign="top"><a id="a9de1f143092a520e3ae76c9c11b08060" name="a9de1f143092a520e3ae76c9c11b08060"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_INVALID_VERSION</b> {0x80000000_u32}</td></tr>
<tr class="memdesc:a9de1f143092a520e3ae76c9c11b08060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an invalid version. <br /></td></tr>
<tr class="separator:a9de1f143092a520e3ae76c9c11b08060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f1fb7a936395a45933b144b61102cd"><td class="memItemLeft" align="right" valign="top"><a id="a09f1fb7a936395a45933b144b61102cd" name="a09f1fb7a936395a45933b144b61102cd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CONTROL_OP_VAL</b> {0x6642000000000000_u64}</td></tr>
<tr class="memdesc:a09f1fb7a936395a45933b144b61102cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_control_op. <br /></td></tr>
<tr class="separator:a09f1fb7a936395a45933b144b61102cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d3da080f0f4dfae63931e80b4beb2b"><td class="memItemLeft" align="right" valign="top"><a id="ac2d3da080f0f4dfae63931e80b4beb2b" name="ac2d3da080f0f4dfae63931e80b4beb2b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CONTROL_OP_NOSIG_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:ac2d3da080f0f4dfae63931e80b4beb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_control_op (nosig) <br /></td></tr>
<tr class="separator:ac2d3da080f0f4dfae63931e80b4beb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3268976b4d024c28d54d99909c5fa9b7"><td class="memItemLeft" align="right" valign="top"><a id="a3268976b4d024c28d54d99909c5fa9b7" name="a3268976b4d024c28d54d99909c5fa9b7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_HANDLE_OP_VAL</b> {0x6642000000010000_u64}</td></tr>
<tr class="memdesc:a3268976b4d024c28d54d99909c5fa9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_handle_op. <br /></td></tr>
<tr class="separator:a3268976b4d024c28d54d99909c5fa9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10de02fca25613955de6639158b76ef3"><td class="memItemLeft" align="right" valign="top"><a id="a10de02fca25613955de6639158b76ef3" name="a10de02fca25613955de6639158b76ef3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_HANDLE_OP_NOSIG_VAL</b> {0x0000000000010000_u64}</td></tr>
<tr class="memdesc:a10de02fca25613955de6639158b76ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_handle_op (nosig) <br /></td></tr>
<tr class="separator:a10de02fca25613955de6639158b76ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b8d84262a5ef58fc8454265c16414"><td class="memItemLeft" align="right" valign="top"><a id="a4a8b8d84262a5ef58fc8454265c16414" name="a4a8b8d84262a5ef58fc8454265c16414"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_VAL</b> {0x6642000000020000_u64}</td></tr>
<tr class="memdesc:a4a8b8d84262a5ef58fc8454265c16414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_debug_op. <br /></td></tr>
<tr class="separator:a4a8b8d84262a5ef58fc8454265c16414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69257c83f2c44ae2903951fac8d6c16f"><td class="memItemLeft" align="right" valign="top"><a id="a69257c83f2c44ae2903951fac8d6c16f" name="a69257c83f2c44ae2903951fac8d6c16f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_NOSIG_VAL</b> {0x00000000000020000_u64}</td></tr>
<tr class="memdesc:a69257c83f2c44ae2903951fac8d6c16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_debug_op (nosig) <br /></td></tr>
<tr class="separator:a69257c83f2c44ae2903951fac8d6c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9ddb704e0b578b0fc9b7914bfa582d"><td class="memItemLeft" align="right" valign="top"><a id="a2c9ddb704e0b578b0fc9b7914bfa582d" name="a2c9ddb704e0b578b0fc9b7914bfa582d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CALLBACK_OP_VAL</b> {0x6642000000030000_u64}</td></tr>
<tr class="memdesc:a2c9ddb704e0b578b0fc9b7914bfa582d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_callback_op. <br /></td></tr>
<tr class="separator:a2c9ddb704e0b578b0fc9b7914bfa582d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54b3e0a28c169be405a703c6fba36ae"><td class="memItemLeft" align="right" valign="top"><a id="ae54b3e0a28c169be405a703c6fba36ae" name="ae54b3e0a28c169be405a703c6fba36ae"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CALLBACK_OP_NOSIG_VAL</b> {0x0000000000030000_u64}</td></tr>
<tr class="memdesc:ae54b3e0a28c169be405a703c6fba36ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_callback_op (nosig) <br /></td></tr>
<tr class="separator:ae54b3e0a28c169be405a703c6fba36ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b97799a6fac3eff0582ee610fde2288"><td class="memItemLeft" align="right" valign="top"><a id="a2b97799a6fac3eff0582ee610fde2288" name="a2b97799a6fac3eff0582ee610fde2288"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VM_OP_VAL</b> {0x6642000000040000_u64}</td></tr>
<tr class="memdesc:a2b97799a6fac3eff0582ee610fde2288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_vm_op. <br /></td></tr>
<tr class="separator:a2b97799a6fac3eff0582ee610fde2288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e45cb7b1524b906d380184aece162c"><td class="memItemLeft" align="right" valign="top"><a id="a91e45cb7b1524b906d380184aece162c" name="a91e45cb7b1524b906d380184aece162c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VM_OP_NOSIG_VAL</b> {0x0000000000040000_u64}</td></tr>
<tr class="memdesc:a91e45cb7b1524b906d380184aece162c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_vm_op (nosig) <br /></td></tr>
<tr class="separator:a91e45cb7b1524b906d380184aece162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963aba7b79de75fcb7e6879156ddf989"><td class="memItemLeft" align="right" valign="top"><a id="a963aba7b79de75fcb7e6879156ddf989" name="a963aba7b79de75fcb7e6879156ddf989"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VP_OP_VAL</b> {0x6642000000050000_u64}</td></tr>
<tr class="memdesc:a963aba7b79de75fcb7e6879156ddf989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_vp_op. <br /></td></tr>
<tr class="separator:a963aba7b79de75fcb7e6879156ddf989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a0631eea7fef865bddd50dac4dc367"><td class="memItemLeft" align="right" valign="top"><a id="a55a0631eea7fef865bddd50dac4dc367" name="a55a0631eea7fef865bddd50dac4dc367"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VP_OP_NOSIG_VAL</b> {0x0000000000050000_u64}</td></tr>
<tr class="memdesc:a55a0631eea7fef865bddd50dac4dc367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_vp_op (nosig) <br /></td></tr>
<tr class="separator:a55a0631eea7fef865bddd50dac4dc367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ff762b9c9985b15ee70b9547e45002"><td class="memItemLeft" align="right" valign="top"><a id="a58ff762b9c9985b15ee70b9547e45002" name="a58ff762b9c9985b15ee70b9547e45002"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_VAL</b> {0x6642000000060000_u64}</td></tr>
<tr class="memdesc:a58ff762b9c9985b15ee70b9547e45002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_vs_op. <br /></td></tr>
<tr class="separator:a58ff762b9c9985b15ee70b9547e45002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0200c72d0d46282f3f63b78b2b87a436"><td class="memItemLeft" align="right" valign="top"><a id="a0200c72d0d46282f3f63b78b2b87a436" name="a0200c72d0d46282f3f63b78b2b87a436"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_NOSIG_VAL</b> {0x0000000000060000_u64}</td></tr>
<tr class="memdesc:a0200c72d0d46282f3f63b78b2b87a436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_vs_op (nosig) <br /></td></tr>
<tr class="separator:a0200c72d0d46282f3f63b78b2b87a436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fcdf558f37adc88a7013adfe640460"><td class="memItemLeft" align="right" valign="top"><a id="a33fcdf558f37adc88a7013adfe640460" name="a33fcdf558f37adc88a7013adfe640460"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_INTRINSIC_OP_VAL</b> {0x6642000000070000_u64}</td></tr>
<tr class="memdesc:a33fcdf558f37adc88a7013adfe640460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_intrinsic_op. <br /></td></tr>
<tr class="separator:a33fcdf558f37adc88a7013adfe640460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae066545c3ed9e394e8907b61c74c801e"><td class="memItemLeft" align="right" valign="top"><a id="ae066545c3ed9e394e8907b61c74c801e" name="ae066545c3ed9e394e8907b61c74c801e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_INTRINSIC_OP_NOSIG_VAL</b> {0x0000000000070000_u64}</td></tr>
<tr class="memdesc:ae066545c3ed9e394e8907b61c74c801e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_intrinsic_op (nosig) <br /></td></tr>
<tr class="separator:ae066545c3ed9e394e8907b61c74c801e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0749c15170b486977bb7748db8cc6e9"><td class="memItemLeft" align="right" valign="top"><a id="aa0749c15170b486977bb7748db8cc6e9" name="aa0749c15170b486977bb7748db8cc6e9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_MEM_OP_VAL</b> {0x6642000000080000_u64}</td></tr>
<tr class="memdesc:aa0749c15170b486977bb7748db8cc6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_mem_op. <br /></td></tr>
<tr class="separator:aa0749c15170b486977bb7748db8cc6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c76f6ea5123a076ca1c0291c2316f7d"><td class="memItemLeft" align="right" valign="top"><a id="a3c76f6ea5123a076ca1c0291c2316f7d" name="a3c76f6ea5123a076ca1c0291c2316f7d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_MEM_OP_NOSIG_VAL</b> {0x0000000000080000_u64}</td></tr>
<tr class="memdesc:a3c76f6ea5123a076ca1c0291c2316f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the syscall opcode for bf_mem_op (nosig) <br /></td></tr>
<tr class="separator:a3c76f6ea5123a076ca1c0291c2316f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de66bf13843e021cba51d2d4058a55a"><td class="memItemLeft" align="right" valign="top"><a id="a1de66bf13843e021cba51d2d4058a55a" name="a1de66bf13843e021cba51d2d4058a55a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_RAX</b> {0x800_u64}</td></tr>
<tr class="memdesc:a1de66bf13843e021cba51d2d4058a55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for rax <br /></td></tr>
<tr class="separator:a1de66bf13843e021cba51d2d4058a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fe51e23f1519354bc66671168d1969"><td class="memItemLeft" align="right" valign="top"><a id="a50fe51e23f1519354bc66671168d1969" name="a50fe51e23f1519354bc66671168d1969"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_RBX</b> {0x808_u64}</td></tr>
<tr class="memdesc:a50fe51e23f1519354bc66671168d1969"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for rbx <br /></td></tr>
<tr class="separator:a50fe51e23f1519354bc66671168d1969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85d1db791c4deeec298b90185716f50"><td class="memItemLeft" align="right" valign="top"><a id="ad85d1db791c4deeec298b90185716f50" name="ad85d1db791c4deeec298b90185716f50"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_RCX</b> {0x810_u64}</td></tr>
<tr class="memdesc:ad85d1db791c4deeec298b90185716f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for rcx <br /></td></tr>
<tr class="separator:ad85d1db791c4deeec298b90185716f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7928edb4f3c50fc5161da441d226665b"><td class="memItemLeft" align="right" valign="top"><a id="a7928edb4f3c50fc5161da441d226665b" name="a7928edb4f3c50fc5161da441d226665b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_RDX</b> {0x818_u64}</td></tr>
<tr class="memdesc:a7928edb4f3c50fc5161da441d226665b"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for rdx <br /></td></tr>
<tr class="separator:a7928edb4f3c50fc5161da441d226665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abf20bb28014e2d47d4cde916bee1d2"><td class="memItemLeft" align="right" valign="top"><a id="a3abf20bb28014e2d47d4cde916bee1d2" name="a3abf20bb28014e2d47d4cde916bee1d2"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_RBP</b> {0x820_u64}</td></tr>
<tr class="memdesc:a3abf20bb28014e2d47d4cde916bee1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for rbp <br /></td></tr>
<tr class="separator:a3abf20bb28014e2d47d4cde916bee1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeecf2a87763e75b9118fd7f364810d"><td class="memItemLeft" align="right" valign="top"><a id="afdeecf2a87763e75b9118fd7f364810d" name="afdeecf2a87763e75b9118fd7f364810d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_RSI</b> {0x828_u64}</td></tr>
<tr class="memdesc:afdeecf2a87763e75b9118fd7f364810d"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for rsi <br /></td></tr>
<tr class="separator:afdeecf2a87763e75b9118fd7f364810d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f38f4653e13caab647f0450346e87f8"><td class="memItemLeft" align="right" valign="top"><a id="a3f38f4653e13caab647f0450346e87f8" name="a3f38f4653e13caab647f0450346e87f8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_RDI</b> {0x830_u64}</td></tr>
<tr class="memdesc:a3f38f4653e13caab647f0450346e87f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for rdi <br /></td></tr>
<tr class="separator:a3f38f4653e13caab647f0450346e87f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198f7bd94a89a6cf1e5b69a6cff98193"><td class="memItemLeft" align="right" valign="top"><a id="a198f7bd94a89a6cf1e5b69a6cff98193" name="a198f7bd94a89a6cf1e5b69a6cff98193"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_R8</b> {0x838_u64}</td></tr>
<tr class="memdesc:a198f7bd94a89a6cf1e5b69a6cff98193"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for r8 <br /></td></tr>
<tr class="separator:a198f7bd94a89a6cf1e5b69a6cff98193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf89a8f0385e67857a3b0676e179ebb"><td class="memItemLeft" align="right" valign="top"><a id="afaf89a8f0385e67857a3b0676e179ebb" name="afaf89a8f0385e67857a3b0676e179ebb"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_R9</b> {0x840_u64}</td></tr>
<tr class="memdesc:afaf89a8f0385e67857a3b0676e179ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for r9 <br /></td></tr>
<tr class="separator:afaf89a8f0385e67857a3b0676e179ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c41f23e1a53692da86e1ea08ca9eaca"><td class="memItemLeft" align="right" valign="top"><a id="a0c41f23e1a53692da86e1ea08ca9eaca" name="a0c41f23e1a53692da86e1ea08ca9eaca"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_R10</b> {0x848_u64}</td></tr>
<tr class="memdesc:a0c41f23e1a53692da86e1ea08ca9eaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for r10 <br /></td></tr>
<tr class="separator:a0c41f23e1a53692da86e1ea08ca9eaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7e62d2e94d4ce0086fd4c91c6d5a95"><td class="memItemLeft" align="right" valign="top"><a id="aab7e62d2e94d4ce0086fd4c91c6d5a95" name="aab7e62d2e94d4ce0086fd4c91c6d5a95"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_R11</b> {0x850_u64}</td></tr>
<tr class="memdesc:aab7e62d2e94d4ce0086fd4c91c6d5a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for r11 <br /></td></tr>
<tr class="separator:aab7e62d2e94d4ce0086fd4c91c6d5a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf42cd9f720d0d136cbf099c06d9cc56"><td class="memItemLeft" align="right" valign="top"><a id="adf42cd9f720d0d136cbf099c06d9cc56" name="adf42cd9f720d0d136cbf099c06d9cc56"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_R12</b> {0x858_u64}</td></tr>
<tr class="memdesc:adf42cd9f720d0d136cbf099c06d9cc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for r12 <br /></td></tr>
<tr class="separator:adf42cd9f720d0d136cbf099c06d9cc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7768865d00cac56705645ea9b2b99f86"><td class="memItemLeft" align="right" valign="top"><a id="a7768865d00cac56705645ea9b2b99f86" name="a7768865d00cac56705645ea9b2b99f86"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_R13</b> {0x860_u64}</td></tr>
<tr class="memdesc:a7768865d00cac56705645ea9b2b99f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for r13 <br /></td></tr>
<tr class="separator:a7768865d00cac56705645ea9b2b99f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7782cced55895ef72d07d5bc468449dd"><td class="memItemLeft" align="right" valign="top"><a id="a7782cced55895ef72d07d5bc468449dd" name="a7782cced55895ef72d07d5bc468449dd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_R14</b> {0x868_u64}</td></tr>
<tr class="memdesc:a7782cced55895ef72d07d5bc468449dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for r14 <br /></td></tr>
<tr class="separator:a7782cced55895ef72d07d5bc468449dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6630bf83f69f9bfc0abb598f264465c"><td class="memItemLeft" align="right" valign="top"><a id="ad6630bf83f69f9bfc0abb598f264465c" name="ad6630bf83f69f9bfc0abb598f264465c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_R15</b> {0x870_u64}</td></tr>
<tr class="memdesc:ad6630bf83f69f9bfc0abb598f264465c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset for r15 <br /></td></tr>
<tr class="separator:ad6630bf83f69f9bfc0abb598f264465c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3d6ce6ea6bcb51a0dc53940725d500"><td class="memItemLeft" align="right" valign="top"><a id="a8a3d6ce6ea6bcb51a0dc53940725d500" name="a8a3d6ce6ea6bcb51a0dc53940725d500"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_ACTIVE_EXTID</b> {0xFF0_u64}</td></tr>
<tr class="memdesc:a8a3d6ce6ea6bcb51a0dc53940725d500"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset of the active extid <br /></td></tr>
<tr class="separator:a8a3d6ce6ea6bcb51a0dc53940725d500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51125b241d0043da1abfe569942fdbe0"><td class="memItemLeft" align="right" valign="top"><a id="a51125b241d0043da1abfe569942fdbe0" name="a51125b241d0043da1abfe569942fdbe0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_ACTIVE_VMID</b> {0xFF2_u64}</td></tr>
<tr class="memdesc:a51125b241d0043da1abfe569942fdbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset of the active vmid <br /></td></tr>
<tr class="separator:a51125b241d0043da1abfe569942fdbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61aa609df9fa2249d94b4d864b879c18"><td class="memItemLeft" align="right" valign="top"><a id="a61aa609df9fa2249d94b4d864b879c18" name="a61aa609df9fa2249d94b4d864b879c18"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_ACTIVE_VPID</b> {0xFF4_u64}</td></tr>
<tr class="memdesc:a61aa609df9fa2249d94b4d864b879c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset of the active vpid <br /></td></tr>
<tr class="separator:a61aa609df9fa2249d94b4d864b879c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03865efcd54cf3caa1a374bab02ab90"><td class="memItemLeft" align="right" valign="top"><a id="af03865efcd54cf3caa1a374bab02ab90" name="af03865efcd54cf3caa1a374bab02ab90"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_ACTIVE_VSID</b> {0xFF6_u64}</td></tr>
<tr class="memdesc:af03865efcd54cf3caa1a374bab02ab90"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset of the active vsid <br /></td></tr>
<tr class="separator:af03865efcd54cf3caa1a374bab02ab90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568d16adeb1e9e4abfec7a6cdb0ddd58"><td class="memItemLeft" align="right" valign="top"><a id="a568d16adeb1e9e4abfec7a6cdb0ddd58" name="a568d16adeb1e9e4abfec7a6cdb0ddd58"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_ACTIVE_PPID</b> {0xFF8_u64}</td></tr>
<tr class="memdesc:a568d16adeb1e9e4abfec7a6cdb0ddd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the offset of the active ppid <br /></td></tr>
<tr class="separator:a568d16adeb1e9e4abfec7a6cdb0ddd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f924c642978c9bf8fb846bca27e71c6"><td class="memItemLeft" align="right" valign="top"><a id="a4f924c642978c9bf8fb846bca27e71c6" name="a4f924c642978c9bf8fb846bca27e71c6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_OFFSET_ONLINE_PPS</b> {0xFFA_u64}</td></tr>
<tr class="memdesc:a4f924c642978c9bf8fb846bca27e71c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the number of PPs that are online <br /></td></tr>
<tr class="separator:a4f924c642978c9bf8fb846bca27e71c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18149deaf4acf85e13705424419c9787"><td class="memItemLeft" align="right" valign="top"><a id="a18149deaf4acf85e13705424419c9787" name="a18149deaf4acf85e13705424419c9787"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_INVALID_HANDLE</b> {0xFFFFFFFFFFFFFFFF_u64}</td></tr>
<tr class="memdesc:a18149deaf4acf85e13705424419c9787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an invalid handle. <br /></td></tr>
<tr class="separator:a18149deaf4acf85e13705424419c9787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3db1161d0787ad054d08466ee22b08"><td class="memItemLeft" align="right" valign="top"><a id="aaa3db1161d0787ad054d08466ee22b08" name="aaa3db1161d0787ad054d08466ee22b08"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CONTROL_OP_EXIT_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:aaa3db1161d0787ad054d08466ee22b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_control_op_exit. <br /></td></tr>
<tr class="separator:aaa3db1161d0787ad054d08466ee22b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bed571934b63476099ac1bfb8267b9"><td class="memItemLeft" align="right" valign="top"><a id="a70bed571934b63476099ac1bfb8267b9" name="a70bed571934b63476099ac1bfb8267b9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CONTROL_OP_WAIT_IDX_VAL</b> {0x0000000000000001_u64}</td></tr>
<tr class="memdesc:a70bed571934b63476099ac1bfb8267b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_control_op_wait. <br /></td></tr>
<tr class="separator:a70bed571934b63476099ac1bfb8267b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02938068f26bbbe3c3c7d79a0fbf80e"><td class="memItemLeft" align="right" valign="top"><a id="ac02938068f26bbbe3c3c7d79a0fbf80e" name="ac02938068f26bbbe3c3c7d79a0fbf80e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CONTROL_OP_AGAIN_IDX_VAL</b> {0x0000000000000002_u64}</td></tr>
<tr class="memdesc:ac02938068f26bbbe3c3c7d79a0fbf80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_control_op_again. <br /></td></tr>
<tr class="separator:ac02938068f26bbbe3c3c7d79a0fbf80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0658987235e66c5e41331d025e529d33"><td class="memItemLeft" align="right" valign="top"><a id="a0658987235e66c5e41331d025e529d33" name="a0658987235e66c5e41331d025e529d33"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_HANDLE_OP_OPEN_HANDLE_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:a0658987235e66c5e41331d025e529d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_handle_op_open_handle. <br /></td></tr>
<tr class="separator:a0658987235e66c5e41331d025e529d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47e17f2b3dd72407f2eef5f7557962d"><td class="memItemLeft" align="right" valign="top"><a id="ab47e17f2b3dd72407f2eef5f7557962d" name="ab47e17f2b3dd72407f2eef5f7557962d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_HANDLE_OP_CLOSE_HANDLE_IDX_VAL</b> {0x0000000000000001_u64}</td></tr>
<tr class="memdesc:ab47e17f2b3dd72407f2eef5f7557962d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_handle_op_close_handle. <br /></td></tr>
<tr class="separator:ab47e17f2b3dd72407f2eef5f7557962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5ea51b611f0418cf5a4518ae8284f9"><td class="memItemLeft" align="right" valign="top"><a id="a3e5ea51b611f0418cf5a4518ae8284f9" name="a3e5ea51b611f0418cf5a4518ae8284f9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_OUT_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:a3e5ea51b611f0418cf5a4518ae8284f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_out. <br /></td></tr>
<tr class="separator:a3e5ea51b611f0418cf5a4518ae8284f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5af709340503db013b90939446a9542"><td class="memItemLeft" align="right" valign="top"><a id="aa5af709340503db013b90939446a9542" name="aa5af709340503db013b90939446a9542"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_DUMP_VM_IDX_VAL</b> {0x0000000000000001_u64}</td></tr>
<tr class="memdesc:aa5af709340503db013b90939446a9542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_dump_vm. <br /></td></tr>
<tr class="separator:aa5af709340503db013b90939446a9542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0b9e3ac17d076afe7e65806e3b4e30"><td class="memItemLeft" align="right" valign="top"><a id="a0c0b9e3ac17d076afe7e65806e3b4e30" name="a0c0b9e3ac17d076afe7e65806e3b4e30"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_DUMP_VP_IDX_VAL</b> {0x0000000000000002_u64}</td></tr>
<tr class="memdesc:a0c0b9e3ac17d076afe7e65806e3b4e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_dump_vp. <br /></td></tr>
<tr class="separator:a0c0b9e3ac17d076afe7e65806e3b4e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758d86edc75958db958e16f47fbbb217"><td class="memItemLeft" align="right" valign="top"><a id="a758d86edc75958db958e16f47fbbb217" name="a758d86edc75958db958e16f47fbbb217"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_DUMP_VS_IDX_VAL</b> {0x0000000000000003_u64}</td></tr>
<tr class="memdesc:a758d86edc75958db958e16f47fbbb217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_dump_vs. <br /></td></tr>
<tr class="separator:a758d86edc75958db958e16f47fbbb217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe13d2805301b6c77eba0e8a37426e7"><td class="memItemLeft" align="right" valign="top"><a id="abfe13d2805301b6c77eba0e8a37426e7" name="abfe13d2805301b6c77eba0e8a37426e7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_DUMP_VMEXIT_LOG_IDX_VAL</b> {0x0000000000000004_u64}</td></tr>
<tr class="memdesc:abfe13d2805301b6c77eba0e8a37426e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_dump_vmexit_log. <br /></td></tr>
<tr class="separator:abfe13d2805301b6c77eba0e8a37426e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2912b133cc42b203a11fcb1c38b3f3c0"><td class="memItemLeft" align="right" valign="top"><a id="a2912b133cc42b203a11fcb1c38b3f3c0" name="a2912b133cc42b203a11fcb1c38b3f3c0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_WRITE_C_IDX_VAL</b> {0x0000000000000005_u64}</td></tr>
<tr class="memdesc:a2912b133cc42b203a11fcb1c38b3f3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_write_c. <br /></td></tr>
<tr class="separator:a2912b133cc42b203a11fcb1c38b3f3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3ee2bca09831b067b306855ba04e80"><td class="memItemLeft" align="right" valign="top"><a id="afc3ee2bca09831b067b306855ba04e80" name="afc3ee2bca09831b067b306855ba04e80"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_WRITE_STR_IDX_VAL</b> {0x0000000000000006_u64}</td></tr>
<tr class="memdesc:afc3ee2bca09831b067b306855ba04e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_write_str. <br /></td></tr>
<tr class="separator:afc3ee2bca09831b067b306855ba04e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324854a3ec1bc4fa48ee22777c913c9d"><td class="memItemLeft" align="right" valign="top"><a id="a324854a3ec1bc4fa48ee22777c913c9d" name="a324854a3ec1bc4fa48ee22777c913c9d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_DUMP_EXT_IDX_VAL</b> {0x0000000000000007_u64}</td></tr>
<tr class="memdesc:a324854a3ec1bc4fa48ee22777c913c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_dump_ext. <br /></td></tr>
<tr class="separator:a324854a3ec1bc4fa48ee22777c913c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8aa5aac660a5360a1633b8773299e2"><td class="memItemLeft" align="right" valign="top"><a id="a5e8aa5aac660a5360a1633b8773299e2" name="a5e8aa5aac660a5360a1633b8773299e2"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_DUMP_PAGE_POOL_IDX_VAL</b> {0x0000000000000008_u64}</td></tr>
<tr class="memdesc:a5e8aa5aac660a5360a1633b8773299e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_dump_page_pool. <br /></td></tr>
<tr class="separator:a5e8aa5aac660a5360a1633b8773299e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb9a2b4e10fc778d26fefde2529c6cf"><td class="memItemLeft" align="right" valign="top"><a id="aceb9a2b4e10fc778d26fefde2529c6cf" name="aceb9a2b4e10fc778d26fefde2529c6cf"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_DEBUG_OP_DUMP_HUGE_POOL_IDX_VAL</b> {0x0000000000000009_u64}</td></tr>
<tr class="memdesc:aceb9a2b4e10fc778d26fefde2529c6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_debug_op_dump_huge_pool. <br /></td></tr>
<tr class="separator:aceb9a2b4e10fc778d26fefde2529c6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad117fb4c3823b5a4790b9a90ec0fc878"><td class="memItemLeft" align="right" valign="top"><a id="ad117fb4c3823b5a4790b9a90ec0fc878" name="ad117fb4c3823b5a4790b9a90ec0fc878"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CALLBACK_OP_REGISTER_BOOTSTRAP_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:ad117fb4c3823b5a4790b9a90ec0fc878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_callback_op_register_bootstrap. <br /></td></tr>
<tr class="separator:ad117fb4c3823b5a4790b9a90ec0fc878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a477a16baf489491d422605a3b0ce6"><td class="memItemLeft" align="right" valign="top"><a id="a41a477a16baf489491d422605a3b0ce6" name="a41a477a16baf489491d422605a3b0ce6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CALLBACK_OP_REGISTER_VMEXIT_IDX_VAL</b> {0x0000000000000001_u64}</td></tr>
<tr class="memdesc:a41a477a16baf489491d422605a3b0ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_callback_op_register_vmexit. <br /></td></tr>
<tr class="separator:a41a477a16baf489491d422605a3b0ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5867d48dba381cd695fce9fc033b579"><td class="memItemLeft" align="right" valign="top"><a id="af5867d48dba381cd695fce9fc033b579" name="af5867d48dba381cd695fce9fc033b579"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_CALLBACK_OP_REGISTER_FAIL_IDX_VAL</b> {0x0000000000000002_u64}</td></tr>
<tr class="memdesc:af5867d48dba381cd695fce9fc033b579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_callback_op_register_fail. <br /></td></tr>
<tr class="separator:af5867d48dba381cd695fce9fc033b579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af617e70af96bd668bc8c846480de9674"><td class="memItemLeft" align="right" valign="top"><a id="af617e70af96bd668bc8c846480de9674" name="af617e70af96bd668bc8c846480de9674"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VM_OP_CREATE_VM_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:af617e70af96bd668bc8c846480de9674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vm_op_create_vm. <br /></td></tr>
<tr class="separator:af617e70af96bd668bc8c846480de9674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d8c6ce954e6219c254c4dfd350b95"><td class="memItemLeft" align="right" valign="top"><a id="a416d8c6ce954e6219c254c4dfd350b95" name="a416d8c6ce954e6219c254c4dfd350b95"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VM_OP_DESTROY_VM_IDX_VAL</b> {0x0000000000000001_u64}</td></tr>
<tr class="memdesc:a416d8c6ce954e6219c254c4dfd350b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vm_op_destroy_vm. <br /></td></tr>
<tr class="separator:a416d8c6ce954e6219c254c4dfd350b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac162dc90ab1be5f6e4aa5b50d33c31cd"><td class="memItemLeft" align="right" valign="top"><a id="ac162dc90ab1be5f6e4aa5b50d33c31cd" name="ac162dc90ab1be5f6e4aa5b50d33c31cd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VM_OP_MAP_DIRECT_IDX_VAL</b> {0x0000000000000002_u64}</td></tr>
<tr class="memdesc:ac162dc90ab1be5f6e4aa5b50d33c31cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vm_op_map_direct. <br /></td></tr>
<tr class="separator:ac162dc90ab1be5f6e4aa5b50d33c31cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f38acc0edcc6d922340074a8ff3f9"><td class="memItemLeft" align="right" valign="top"><a id="afe7f38acc0edcc6d922340074a8ff3f9" name="afe7f38acc0edcc6d922340074a8ff3f9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VM_OP_UNMAP_DIRECT_IDX_VAL</b> {0x0000000000000003_u64}</td></tr>
<tr class="memdesc:afe7f38acc0edcc6d922340074a8ff3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vm_op_unmap_direct. <br /></td></tr>
<tr class="separator:afe7f38acc0edcc6d922340074a8ff3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5359d516db069befb591c86999ea2f31"><td class="memItemLeft" align="right" valign="top"><a id="a5359d516db069befb591c86999ea2f31" name="a5359d516db069befb591c86999ea2f31"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VM_OP_UNMAP_DIRECT_BROADCAST_IDX_VAL</b> {0x0000000000000004_u64}</td></tr>
<tr class="memdesc:a5359d516db069befb591c86999ea2f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vm_op_unmap_direct_broadcast. <br /></td></tr>
<tr class="separator:a5359d516db069befb591c86999ea2f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fef8cadfc04bf30eef503b215cf995"><td class="memItemLeft" align="right" valign="top"><a id="a29fef8cadfc04bf30eef503b215cf995" name="a29fef8cadfc04bf30eef503b215cf995"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VM_OP_TLB_FLUSH_IDX_VAL</b> {0x0000000000000005_u64}</td></tr>
<tr class="memdesc:a29fef8cadfc04bf30eef503b215cf995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vm_op_tlb_flush. <br /></td></tr>
<tr class="separator:a29fef8cadfc04bf30eef503b215cf995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60884831d25c41e764ed9bfaa916845"><td class="memItemLeft" align="right" valign="top"><a id="ad60884831d25c41e764ed9bfaa916845" name="ad60884831d25c41e764ed9bfaa916845"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VP_OP_CREATE_VP_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:ad60884831d25c41e764ed9bfaa916845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vp_op_create_vp. <br /></td></tr>
<tr class="separator:ad60884831d25c41e764ed9bfaa916845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70581297c167eeafde4cdcd70a0b1e5"><td class="memItemLeft" align="right" valign="top"><a id="af70581297c167eeafde4cdcd70a0b1e5" name="af70581297c167eeafde4cdcd70a0b1e5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VP_OP_DESTROY_VP_IDX_VAL</b> {0x0000000000000001_u64}</td></tr>
<tr class="memdesc:af70581297c167eeafde4cdcd70a0b1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vp_op_destroy_vp. <br /></td></tr>
<tr class="separator:af70581297c167eeafde4cdcd70a0b1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb811e6445180a5c5b00a53890a8a406"><td class="memItemLeft" align="right" valign="top"><a id="aeb811e6445180a5c5b00a53890a8a406" name="aeb811e6445180a5c5b00a53890a8a406"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_CREATE_VS_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:aeb811e6445180a5c5b00a53890a8a406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_create_vs. <br /></td></tr>
<tr class="separator:aeb811e6445180a5c5b00a53890a8a406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89803da42427e49b610fbb09f83ec9c4"><td class="memItemLeft" align="right" valign="top"><a id="a89803da42427e49b610fbb09f83ec9c4" name="a89803da42427e49b610fbb09f83ec9c4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_DESTROY_VS_IDX_VAL</b> {0x0000000000000001_u64}</td></tr>
<tr class="memdesc:a89803da42427e49b610fbb09f83ec9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_destroy_vs. <br /></td></tr>
<tr class="separator:a89803da42427e49b610fbb09f83ec9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018b8536ceccdc5c94a959920ecd0249"><td class="memItemLeft" align="right" valign="top"><a id="a018b8536ceccdc5c94a959920ecd0249" name="a018b8536ceccdc5c94a959920ecd0249"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_INIT_AS_ROOT_IDX_VAL</b> {0x0000000000000002_u64}</td></tr>
<tr class="memdesc:a018b8536ceccdc5c94a959920ecd0249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_init_as_root. <br /></td></tr>
<tr class="separator:a018b8536ceccdc5c94a959920ecd0249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ec19c2274957f31c19b1e2bafaaf03"><td class="memItemLeft" align="right" valign="top"><a id="a03ec19c2274957f31c19b1e2bafaaf03" name="a03ec19c2274957f31c19b1e2bafaaf03"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_READ_IDX_VAL</b> {0x0000000000000003_u64}</td></tr>
<tr class="memdesc:a03ec19c2274957f31c19b1e2bafaaf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_read_reg. <br /></td></tr>
<tr class="separator:a03ec19c2274957f31c19b1e2bafaaf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0555698072ab9e8d82817cc7f21d1f92"><td class="memItemLeft" align="right" valign="top"><a id="a0555698072ab9e8d82817cc7f21d1f92" name="a0555698072ab9e8d82817cc7f21d1f92"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_WRITE_IDX_VAL</b> {0x0000000000000004_u64}</td></tr>
<tr class="memdesc:a0555698072ab9e8d82817cc7f21d1f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_write_reg. <br /></td></tr>
<tr class="separator:a0555698072ab9e8d82817cc7f21d1f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97acc035882de5d002fc29206ad48811"><td class="memItemLeft" align="right" valign="top"><a id="a97acc035882de5d002fc29206ad48811" name="a97acc035882de5d002fc29206ad48811"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_RUN_IDX_VAL</b> {0x0000000000000005_u64}</td></tr>
<tr class="memdesc:a97acc035882de5d002fc29206ad48811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_run. <br /></td></tr>
<tr class="separator:a97acc035882de5d002fc29206ad48811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1511a449115b5b3049b05a0f06c9aaa4"><td class="memItemLeft" align="right" valign="top"><a id="a1511a449115b5b3049b05a0f06c9aaa4" name="a1511a449115b5b3049b05a0f06c9aaa4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_RUN_CURRENT_IDX_VAL</b> {0x0000000000000006_u64}</td></tr>
<tr class="memdesc:a1511a449115b5b3049b05a0f06c9aaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_run_current. <br /></td></tr>
<tr class="separator:a1511a449115b5b3049b05a0f06c9aaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09340c71e9b3ebb3581c931a13821139"><td class="memItemLeft" align="right" valign="top"><a id="a09340c71e9b3ebb3581c931a13821139" name="a09340c71e9b3ebb3581c931a13821139"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_ADVANCE_IP_AND_RUN_IDX_VAL</b> {0x0000000000000007_u64}</td></tr>
<tr class="memdesc:a09340c71e9b3ebb3581c931a13821139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_advance_ip_and_run. <br /></td></tr>
<tr class="separator:a09340c71e9b3ebb3581c931a13821139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1e2779868562a6f8a863fcc35b848c"><td class="memItemLeft" align="right" valign="top"><a id="aca1e2779868562a6f8a863fcc35b848c" name="aca1e2779868562a6f8a863fcc35b848c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_ADVANCE_IP_AND_RUN_CURRENT_IDX_VAL</b> {0x0000000000000008_u64}</td></tr>
<tr class="memdesc:aca1e2779868562a6f8a863fcc35b848c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_advance_ip_and_run_current. <br /></td></tr>
<tr class="separator:aca1e2779868562a6f8a863fcc35b848c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c769b61a93b1909c65fced2bc96860f"><td class="memItemLeft" align="right" valign="top"><a id="a3c769b61a93b1909c65fced2bc96860f" name="a3c769b61a93b1909c65fced2bc96860f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_PROMOTE_IDX_VAL</b> {0x0000000000000009_u64}</td></tr>
<tr class="memdesc:a3c769b61a93b1909c65fced2bc96860f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_promote. <br /></td></tr>
<tr class="separator:a3c769b61a93b1909c65fced2bc96860f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fa6b79050bb483f9a4bb816e1312c8"><td class="memItemLeft" align="right" valign="top"><a id="ae8fa6b79050bb483f9a4bb816e1312c8" name="ae8fa6b79050bb483f9a4bb816e1312c8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_CLEAR_IDX_VAL</b> {0x000000000000000A_u64}</td></tr>
<tr class="memdesc:ae8fa6b79050bb483f9a4bb816e1312c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_clear. <br /></td></tr>
<tr class="separator:ae8fa6b79050bb483f9a4bb816e1312c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b62285b0cfb4713530680a268a5b917"><td class="memItemLeft" align="right" valign="top"><a id="a5b62285b0cfb4713530680a268a5b917" name="a5b62285b0cfb4713530680a268a5b917"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_MIGRATE_IDX_VAL</b> {0x000000000000000B_u64}</td></tr>
<tr class="memdesc:a5b62285b0cfb4713530680a268a5b917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_migrate. <br /></td></tr>
<tr class="separator:a5b62285b0cfb4713530680a268a5b917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2de09a578879a4a86265c5146afa07"><td class="memItemLeft" align="right" valign="top"><a id="a7f2de09a578879a4a86265c5146afa07" name="a7f2de09a578879a4a86265c5146afa07"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_SET_ACTIVE_IDX_VAL</b> {0x000000000000000C_u64}</td></tr>
<tr class="memdesc:a7f2de09a578879a4a86265c5146afa07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_set_active. <br /></td></tr>
<tr class="separator:a7f2de09a578879a4a86265c5146afa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa638712363409498344d6edf2e6df9a9"><td class="memItemLeft" align="right" valign="top"><a id="aa638712363409498344d6edf2e6df9a9" name="aa638712363409498344d6edf2e6df9a9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_ADVANCE_IP_AND_SET_ACTIVE_IDX_VAL</b> {0x000000000000000D_u64}</td></tr>
<tr class="memdesc:aa638712363409498344d6edf2e6df9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_advance_ip_and_set_active. <br /></td></tr>
<tr class="separator:aa638712363409498344d6edf2e6df9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f9ce4534f4557c0f1889bad25a3f3b"><td class="memItemLeft" align="right" valign="top"><a id="a61f9ce4534f4557c0f1889bad25a3f3b" name="a61f9ce4534f4557c0f1889bad25a3f3b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_VS_OP_TLB_FLUSH_IDX_VAL</b> {0x000000000000000E_u64}</td></tr>
<tr class="memdesc:a61f9ce4534f4557c0f1889bad25a3f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_vs_op_tlb_flush. <br /></td></tr>
<tr class="separator:a61f9ce4534f4557c0f1889bad25a3f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9655e370bf306ea168526ee00355def4"><td class="memItemLeft" align="right" valign="top"><a id="a9655e370bf306ea168526ee00355def4" name="a9655e370bf306ea168526ee00355def4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_INTRINSIC_OP_RDMSR_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:a9655e370bf306ea168526ee00355def4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_intrinsic_op_rdmsr. <br /></td></tr>
<tr class="separator:a9655e370bf306ea168526ee00355def4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34a8a743ec175a2dfc4c4fc96b542e5"><td class="memItemLeft" align="right" valign="top"><a id="ae34a8a743ec175a2dfc4c4fc96b542e5" name="ae34a8a743ec175a2dfc4c4fc96b542e5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_INTRINSIC_OP_WRMSR_IDX_VAL</b> {0x0000000000000001_u64}</td></tr>
<tr class="memdesc:ae34a8a743ec175a2dfc4c4fc96b542e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_intrinsic_op_wrmsr. <br /></td></tr>
<tr class="separator:ae34a8a743ec175a2dfc4c4fc96b542e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1ea182f1fc763399b33a18044b8aa5"><td class="memItemLeft" align="right" valign="top"><a id="a7a1ea182f1fc763399b33a18044b8aa5" name="a7a1ea182f1fc763399b33a18044b8aa5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_MEM_OP_ALLOC_PAGE_IDX_VAL</b> {0x0000000000000000_u64}</td></tr>
<tr class="memdesc:a7a1ea182f1fc763399b33a18044b8aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_mem_op_alloc_page. <br /></td></tr>
<tr class="separator:a7a1ea182f1fc763399b33a18044b8aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219804d442f4ed45fe83f349e1e0c2f"><td class="memItemLeft" align="right" valign="top"><a id="ab219804d442f4ed45fe83f349e1e0c2f" name="ab219804d442f4ed45fe83f349e1e0c2f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BF_MEM_OP_ALLOC_HUGE_IDX_VAL</b> {0x0000000000000002_u64}</td></tr>
<tr class="memdesc:ab219804d442f4ed45fe83f349e1e0c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the index for bf_mem_op_alloc_huge. <br /></td></tr>
<tr class="separator:ab219804d442f4ed45fe83f349e1e0c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7725405302d12bf40633fc871c0741d"><td class="memItemLeft" align="right" valign="top"><a id="ab7725405302d12bf40633fc871c0741d" name="ab7725405302d12bf40633fc871c0741d"></a>
constexpr bsl::uint64&#160;</td><td class="memItemRight" valign="bottom"><b>BF_MAX_REG_T</b> {static_cast&lt;bsl::uint64&gt;(121)}</td></tr>
<tr class="memdesc:ab7725405302d12bf40633fc871c0741d"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the max value for a bf_reg_t <br /></td></tr>
<tr class="separator:ab7725405302d12bf40633fc871c0741d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3147225423d374d422f908cada33ee24"><td class="memItemLeft" align="right" valign="top"><a id="a3147225423d374d422f908cada33ee24" name="a3147225423d374d422f908cada33ee24"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>ANSWER16</b> {1_u16}</td></tr>
<tr class="memdesc:a3147225423d374d422f908cada33ee24"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the answer to all things (in 16 bits) <br /></td></tr>
<tr class="separator:a3147225423d374d422f908cada33ee24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01543b222f0312649d29db159ef153df"><td class="memItemLeft" align="right" valign="top"><a id="a01543b222f0312649d29db159ef153df" name="a01543b222f0312649d29db159ef153df"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>ANSWER64</b> {1_u64}</td></tr>
<tr class="memdesc:a01543b222f0312649d29db159ef153df"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the answer to all things (in 64 bits) <br /></td></tr>
<tr class="separator:a01543b222f0312649d29db159ef153df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9301e71654f1474aa66fd5fa484d6020"><td class="memItemLeft" align="right" valign="top"><a id="a9301e71654f1474aa66fd5fa484d6020" name="a9301e71654f1474aa66fd5fa484d6020"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>BAD_VERSION</b> {0x80000000_u32}</td></tr>
<tr class="memdesc:a9301e71654f1474aa66fd5fa484d6020"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores a bad version <br /></td></tr>
<tr class="separator:a9301e71654f1474aa66fd5fa484d6020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fda1ecbf0b5ca5573fc9e1b57e9340b"><td class="memItemLeft" align="right" valign="top"><a id="a4fda1ecbf0b5ca5573fc9e1b57e9340b" name="a4fda1ecbf0b5ca5573fc9e1b57e9340b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>OOR_ID</b> {0xF000_u64}</td></tr>
<tr class="memdesc:a4fda1ecbf0b5ca5573fc9e1b57e9340b"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores a bad version <br /></td></tr>
<tr class="separator:a4fda1ecbf0b5ca5573fc9e1b57e9340b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82549ff65d839571784e49b605465bb7"><td class="memItemLeft" align="right" valign="top"><a id="a82549ff65d839571784e49b605465bb7" name="a82549ff65d839571784e49b605465bb7"></a>
constinit <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>g_verify_constinit</b> {}</td></tr>
<tr class="memdesc:a82549ff65d839571784e49b605465bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">verify constinit it supported <br /></td></tr>
<tr class="separator:a82549ff65d839571784e49b605465bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2020 Assured Information Security, Inc.</dd>
<dd>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</dd>
<dd>
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</dd>
<dd>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e3c7a4f139e3d2c85be4c8b8fc90b9">&#9670;&nbsp;</a></span>bf_reg_t <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">syscall::bf_reg_t</a> : bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines which register to use for read/write. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489"></a>bf_reg_t_unsupported&#160;</td><td class="fielddoc"><p >defines an unsupported register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7"></a>bf_reg_t_rbx&#160;</td><td class="fielddoc"><p >defines the rbx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84"></a>bf_reg_t_rcx&#160;</td><td class="fielddoc"><p >defines the rcx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b"></a>bf_reg_t_rdx&#160;</td><td class="fielddoc"><p >defines the rdx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4"></a>bf_reg_t_rbp&#160;</td><td class="fielddoc"><p >defines the rbp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d"></a>bf_reg_t_rsi&#160;</td><td class="fielddoc"><p >defines the rsi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843"></a>bf_reg_t_rdi&#160;</td><td class="fielddoc"><p >defines the rdi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8"></a>bf_reg_t_r8&#160;</td><td class="fielddoc"><p >defines the r8 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a"></a>bf_reg_t_r9&#160;</td><td class="fielddoc"><p >defines the r9 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3"></a>bf_reg_t_r10&#160;</td><td class="fielddoc"><p >defines the r10 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1"></a>bf_reg_t_r11&#160;</td><td class="fielddoc"><p >defines the r11 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78"></a>bf_reg_t_r12&#160;</td><td class="fielddoc"><p >defines the r12 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc"></a>bf_reg_t_r13&#160;</td><td class="fielddoc"><p >defines the r13 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce"></a>bf_reg_t_r14&#160;</td><td class="fielddoc"><p >defines the r14 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189"></a>bf_reg_t_r15&#160;</td><td class="fielddoc"><p >defines the r15 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa97688dfecdb28ee4e53ef18d8808477" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa97688dfecdb28ee4e53ef18d8808477"></a>bf_reg_t_intercept_cr_read&#160;</td><td class="fielddoc"><p >defines the intercept_cr_read register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeecd0d0b9698727101f57eee07bfc036" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeecd0d0b9698727101f57eee07bfc036"></a>bf_reg_t_intercept_cr_write&#160;</td><td class="fielddoc"><p >defines the intercept_cr_write register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afe94dca53be1be240606b4021ef48896" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afe94dca53be1be240606b4021ef48896"></a>bf_reg_t_intercept_dr_read&#160;</td><td class="fielddoc"><p >defines the intercept_dr_read register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d23feab96fe2f710403007f59071a95" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d23feab96fe2f710403007f59071a95"></a>bf_reg_t_intercept_dr_write&#160;</td><td class="fielddoc"><p >defines the intercept_dr_write register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad6d94b9bbbded796e9764e824f1e7b23" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad6d94b9bbbded796e9764e824f1e7b23"></a>bf_reg_t_intercept_exception&#160;</td><td class="fielddoc"><p >defines the intercept_exception register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6015ab17b020f7012909b6d5c57b72a0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6015ab17b020f7012909b6d5c57b72a0"></a>bf_reg_t_intercept_instruction1&#160;</td><td class="fielddoc"><p >defines the intercept_instruction1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7e9eb25f33bb81f4972574b82c48d8be" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7e9eb25f33bb81f4972574b82c48d8be"></a>bf_reg_t_intercept_instruction2&#160;</td><td class="fielddoc"><p >defines the intercept_instruction2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a815be2536af711f608c60c31bf595ef0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a815be2536af711f608c60c31bf595ef0"></a>bf_reg_t_intercept_instruction3&#160;</td><td class="fielddoc"><p >defines the intercept_instruction3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a32ef25f9973c36148ee629222a9cfc4b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a32ef25f9973c36148ee629222a9cfc4b"></a>bf_reg_t_pause_filter_threshold&#160;</td><td class="fielddoc"><p >defines the pause_filter_threshold register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afc0ff0bd0c59831b5c56d9855a1624bc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afc0ff0bd0c59831b5c56d9855a1624bc"></a>bf_reg_t_pause_filter_count&#160;</td><td class="fielddoc"><p >defines the pause_filter_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a86d6efa2b9d4cea2b33f2b5a93b34742" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a86d6efa2b9d4cea2b33f2b5a93b34742"></a>bf_reg_t_iopm_base_pa&#160;</td><td class="fielddoc"><p >defines the iopm_base_pa register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a36cfc16dbc1524ba74f614c4df2d5c3e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a36cfc16dbc1524ba74f614c4df2d5c3e"></a>bf_reg_t_msrpm_base_pa&#160;</td><td class="fielddoc"><p >defines the msrpm_base_pa register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275"></a>bf_reg_t_tsc_offset&#160;</td><td class="fielddoc"><p >defines the tsc_offset register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a91e6cdebcb2ef2f9fdd01e5b1d332124" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a91e6cdebcb2ef2f9fdd01e5b1d332124"></a>bf_reg_t_guest_asid&#160;</td><td class="fielddoc"><p >defines the guest_asid register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae7b6abeddec279c2e24d530f69e8ea48" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae7b6abeddec279c2e24d530f69e8ea48"></a>bf_reg_t_tlb_control&#160;</td><td class="fielddoc"><p >defines the tlb_control register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7dfa7b7ad301c186418e0cd8bdcbac1b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7dfa7b7ad301c186418e0cd8bdcbac1b"></a>bf_reg_t_virtual_interrupt_a&#160;</td><td class="fielddoc"><p >defines the virtual_interrupt_a register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a152c3df283c4fc748ee125040bb86032" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a152c3df283c4fc748ee125040bb86032"></a>bf_reg_t_virtual_interrupt_b&#160;</td><td class="fielddoc"><p >defines the virtual_interrupt_b register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a584fa23b25dfc2320d0075ecfd5f5724" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a584fa23b25dfc2320d0075ecfd5f5724"></a>bf_reg_t_exitcode&#160;</td><td class="fielddoc"><p >defines the exitcode register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ace6a44bc577a2e5587df99b7dbcfac18" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ace6a44bc577a2e5587df99b7dbcfac18"></a>bf_reg_t_exitinfo1&#160;</td><td class="fielddoc"><p >defines the exitinfo1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a05731134ec34282c67f0dbe03b4e05c0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a05731134ec34282c67f0dbe03b4e05c0"></a>bf_reg_t_exitinfo2&#160;</td><td class="fielddoc"><p >defines the exitinfo2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abe41c9ebc806f09f31143848c7780224" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abe41c9ebc806f09f31143848c7780224"></a>bf_reg_t_exitininfo&#160;</td><td class="fielddoc"><p >defines the exitininfo register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a36fdc0842641d424829ccaeb99363c35" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a36fdc0842641d424829ccaeb99363c35"></a>bf_reg_t_ctls1&#160;</td><td class="fielddoc"><p >defines the ctls1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a22406fac3fb48fbe659908c2000e3f2c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a22406fac3fb48fbe659908c2000e3f2c"></a>bf_reg_t_avic_apic_bar&#160;</td><td class="fielddoc"><p >defines the avic_apic_bar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a83dbdf26d64314db84000353e578f88b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a83dbdf26d64314db84000353e578f88b"></a>bf_reg_t_guest_pa_of_ghcb&#160;</td><td class="fielddoc"><p >defines the guest_pa_of_ghcb register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3aab240be169e7d1516da9d9f7f57cbe" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3aab240be169e7d1516da9d9f7f57cbe"></a>bf_reg_t_eventinj&#160;</td><td class="fielddoc"><p >defines the eventinj register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab359ec586c93e2495766c8e9ff105565" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab359ec586c93e2495766c8e9ff105565"></a>bf_reg_t_n_cr3&#160;</td><td class="fielddoc"><p >defines the n_cr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab251cc88d1b21f7d930ce771fe44784c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab251cc88d1b21f7d930ce771fe44784c"></a>bf_reg_t_ctls2&#160;</td><td class="fielddoc"><p >defines the ctls2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9948b21fe77d40fa6dae12949473cd31" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9948b21fe77d40fa6dae12949473cd31"></a>bf_reg_t_vmcb_clean_bits&#160;</td><td class="fielddoc"><p >defines the vmcb_clean_bits register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9186b6fa41430dc0fd77d0bbe202be80" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9186b6fa41430dc0fd77d0bbe202be80"></a>bf_reg_t_nrip&#160;</td><td class="fielddoc"><p >defines the nrip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a512e65b853f75b892881a65e6a8d4d9f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a512e65b853f75b892881a65e6a8d4d9f"></a>bf_reg_t_number_of_bytes_fetched&#160;</td><td class="fielddoc"><p >defines the number_of_bytes_fetched register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a53a80576ad2a07feca3f651e6f74bc76" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a53a80576ad2a07feca3f651e6f74bc76"></a>bf_reg_t_avic_apic_backing_page_ptr&#160;</td><td class="fielddoc"><p >defines the avic_apic_backing_page_ptr register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1104bf6127ff0f030aba5ff4cc59b13a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1104bf6127ff0f030aba5ff4cc59b13a"></a>bf_reg_t_avic_logical_table_ptr&#160;</td><td class="fielddoc"><p >defines the avic_logical_table_ptr register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6d23d215b4e8e99de91ae50098d11c38" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6d23d215b4e8e99de91ae50098d11c38"></a>bf_reg_t_avic_physical_table_ptr&#160;</td><td class="fielddoc"><p >defines the avic_physical_table_ptr register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5de963101ef099e898cd5646877b2876" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5de963101ef099e898cd5646877b2876"></a>bf_reg_t_vmsa_ptr&#160;</td><td class="fielddoc"><p >defines the vmsa_ptr register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f"></a>bf_reg_t_es_selector&#160;</td><td class="fielddoc"><p >defines the es_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c"></a>bf_reg_t_es_attrib&#160;</td><td class="fielddoc"><p >defines the es_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e"></a>bf_reg_t_es_limit&#160;</td><td class="fielddoc"><p >defines the es_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8"></a>bf_reg_t_es_base&#160;</td><td class="fielddoc"><p >defines the es_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92"></a>bf_reg_t_cs_selector&#160;</td><td class="fielddoc"><p >defines the cs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0"></a>bf_reg_t_cs_attrib&#160;</td><td class="fielddoc"><p >defines the cs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d"></a>bf_reg_t_cs_limit&#160;</td><td class="fielddoc"><p >defines the cs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0"></a>bf_reg_t_cs_base&#160;</td><td class="fielddoc"><p >defines the cs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87"></a>bf_reg_t_ss_selector&#160;</td><td class="fielddoc"><p >defines the ss_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a"></a>bf_reg_t_ss_attrib&#160;</td><td class="fielddoc"><p >defines the ss_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57"></a>bf_reg_t_ss_limit&#160;</td><td class="fielddoc"><p >defines the ss_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d"></a>bf_reg_t_ss_base&#160;</td><td class="fielddoc"><p >defines the ss_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06"></a>bf_reg_t_ds_selector&#160;</td><td class="fielddoc"><p >defines the ds_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840"></a>bf_reg_t_ds_attrib&#160;</td><td class="fielddoc"><p >defines the ds_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc"></a>bf_reg_t_ds_limit&#160;</td><td class="fielddoc"><p >defines the ds_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd"></a>bf_reg_t_ds_base&#160;</td><td class="fielddoc"><p >defines the ds_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2"></a>bf_reg_t_fs_selector&#160;</td><td class="fielddoc"><p >defines the fs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99"></a>bf_reg_t_fs_attrib&#160;</td><td class="fielddoc"><p >defines the fs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4"></a>bf_reg_t_fs_limit&#160;</td><td class="fielddoc"><p >defines the fs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e"></a>bf_reg_t_fs_base&#160;</td><td class="fielddoc"><p >defines the fs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf"></a>bf_reg_t_gs_selector&#160;</td><td class="fielddoc"><p >defines the gs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9"></a>bf_reg_t_gs_attrib&#160;</td><td class="fielddoc"><p >defines the gs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6"></a>bf_reg_t_gs_limit&#160;</td><td class="fielddoc"><p >defines the gs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8"></a>bf_reg_t_gs_base&#160;</td><td class="fielddoc"><p >defines the gs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aaf1e1ce886840d9f11363f34d1b22154" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aaf1e1ce886840d9f11363f34d1b22154"></a>bf_reg_t_gdtr_selector&#160;</td><td class="fielddoc"><p >defines the gdtr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1108342645405b79f8a789cbdfd0f3f6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1108342645405b79f8a789cbdfd0f3f6"></a>bf_reg_t_gdtr_attrib&#160;</td><td class="fielddoc"><p >defines the gdtr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9"></a>bf_reg_t_gdtr_limit&#160;</td><td class="fielddoc"><p >defines the gdtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee"></a>bf_reg_t_gdtr_base&#160;</td><td class="fielddoc"><p >defines the gdtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2"></a>bf_reg_t_ldtr_selector&#160;</td><td class="fielddoc"><p >defines the ldtr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476"></a>bf_reg_t_ldtr_attrib&#160;</td><td class="fielddoc"><p >defines the ldtr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1"></a>bf_reg_t_ldtr_limit&#160;</td><td class="fielddoc"><p >defines the ldtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69"></a>bf_reg_t_ldtr_base&#160;</td><td class="fielddoc"><p >defines the ldtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0f1e234d6f188d085527f18e2c7820cc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0f1e234d6f188d085527f18e2c7820cc"></a>bf_reg_t_idtr_selector&#160;</td><td class="fielddoc"><p >defines the idtr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a799920a72530f595381969074967a2b4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a799920a72530f595381969074967a2b4"></a>bf_reg_t_idtr_attrib&#160;</td><td class="fielddoc"><p >defines the idtr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7"></a>bf_reg_t_idtr_limit&#160;</td><td class="fielddoc"><p >defines the idtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0"></a>bf_reg_t_idtr_base&#160;</td><td class="fielddoc"><p >defines the idtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4"></a>bf_reg_t_tr_selector&#160;</td><td class="fielddoc"><p >defines the tr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5"></a>bf_reg_t_tr_attrib&#160;</td><td class="fielddoc"><p >defines the tr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4"></a>bf_reg_t_tr_limit&#160;</td><td class="fielddoc"><p >defines the tr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86"></a>bf_reg_t_tr_base&#160;</td><td class="fielddoc"><p >defines the tr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c28258484949c7a52c50e25cdecc6db" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c28258484949c7a52c50e25cdecc6db"></a>bf_reg_t_cpl&#160;</td><td class="fielddoc"><p >defines the cpl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877"></a>bf_reg_t_efer&#160;</td><td class="fielddoc"><p >defines the efer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1"></a>bf_reg_t_cr4&#160;</td><td class="fielddoc"><p >defines the cr4 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c"></a>bf_reg_t_cr3&#160;</td><td class="fielddoc"><p >defines the cr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1"></a>bf_reg_t_cr0&#160;</td><td class="fielddoc"><p >defines the cr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99"></a>bf_reg_t_dr7&#160;</td><td class="fielddoc"><p >defines the dr7 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4"></a>bf_reg_t_dr6&#160;</td><td class="fielddoc"><p >defines the dr6 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9"></a>bf_reg_t_rflags&#160;</td><td class="fielddoc"><p >defines the rflags register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355"></a>bf_reg_t_rip&#160;</td><td class="fielddoc"><p >defines the rip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0"></a>bf_reg_t_rsp&#160;</td><td class="fielddoc"><p >defines the rsp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78"></a>bf_reg_t_rax&#160;</td><td class="fielddoc"><p >defines the rax register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6"></a>bf_reg_t_star&#160;</td><td class="fielddoc"><p >defines the star register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac"></a>bf_reg_t_lstar&#160;</td><td class="fielddoc"><p >defines the lstar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b"></a>bf_reg_t_cstar&#160;</td><td class="fielddoc"><p >defines the cstar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47"></a>bf_reg_t_fmask&#160;</td><td class="fielddoc"><p >defines the fmask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf"></a>bf_reg_t_kernel_gs_base&#160;</td><td class="fielddoc"><p >defines the kernel_gs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0"></a>bf_reg_t_sysenter_cs&#160;</td><td class="fielddoc"><p >defines the sysenter_cs register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2"></a>bf_reg_t_sysenter_esp&#160;</td><td class="fielddoc"><p >defines the sysenter_esp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1"></a>bf_reg_t_sysenter_eip&#160;</td><td class="fielddoc"><p >defines the sysenter_eip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2"></a>bf_reg_t_cr2&#160;</td><td class="fielddoc"><p >defines the cr2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3"></a>bf_reg_t_pat&#160;</td><td class="fielddoc"><p >defines the pat register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acecd07371de6e931e2ef143973846761" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acecd07371de6e931e2ef143973846761"></a>bf_reg_t_dbgctl&#160;</td><td class="fielddoc"><p >defines the dbgctl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa48147b7094cd91eaa3ca9e8b358dcc5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa48147b7094cd91eaa3ca9e8b358dcc5"></a>bf_reg_t_br_from&#160;</td><td class="fielddoc"><p >defines the br_from register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad455c48f5f0e764b7080affcb11ac466" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad455c48f5f0e764b7080affcb11ac466"></a>bf_reg_t_br_to&#160;</td><td class="fielddoc"><p >defines the br_to register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7c1d99263f002aed282eee3007f243d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7c1d99263f002aed282eee3007f243d"></a>bf_reg_t_lastexcpfrom&#160;</td><td class="fielddoc"><p >defines the lastexcpfrom register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a61093d9ca5c58a5fd5d1a2ae9783d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a61093d9ca5c58a5fd5d1a2ae9783d"></a>bf_reg_t_lastexcpto&#160;</td><td class="fielddoc"><p >defines the lastexcpto register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c"></a>bf_reg_t_cr8&#160;</td><td class="fielddoc"><p >defines the cr8 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20"></a>bf_reg_t_dr0&#160;</td><td class="fielddoc"><p >defines the dr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d"></a>bf_reg_t_dr1&#160;</td><td class="fielddoc"><p >defines the dr1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244"></a>bf_reg_t_dr2&#160;</td><td class="fielddoc"><p >defines the dr2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d"></a>bf_reg_t_dr3&#160;</td><td class="fielddoc"><p >defines the dr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc"></a>bf_reg_t_xcr0&#160;</td><td class="fielddoc"><p >defines the xcr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7"></a>bf_reg_t_invalid&#160;</td><td class="fielddoc"><p >defines an invalid bf_reg_t </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489"></a>bf_reg_t_unsupported&#160;</td><td class="fielddoc"><p >defines an unsupported register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78"></a>bf_reg_t_rax&#160;</td><td class="fielddoc"><p >defines the rax register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7"></a>bf_reg_t_rbx&#160;</td><td class="fielddoc"><p >defines the rbx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84"></a>bf_reg_t_rcx&#160;</td><td class="fielddoc"><p >defines the rcx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b"></a>bf_reg_t_rdx&#160;</td><td class="fielddoc"><p >defines the rdx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4"></a>bf_reg_t_rbp&#160;</td><td class="fielddoc"><p >defines the rbp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d"></a>bf_reg_t_rsi&#160;</td><td class="fielddoc"><p >defines the rsi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843"></a>bf_reg_t_rdi&#160;</td><td class="fielddoc"><p >defines the rdi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8"></a>bf_reg_t_r8&#160;</td><td class="fielddoc"><p >defines the r8 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a"></a>bf_reg_t_r9&#160;</td><td class="fielddoc"><p >defines the r9 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3"></a>bf_reg_t_r10&#160;</td><td class="fielddoc"><p >defines the r10 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1"></a>bf_reg_t_r11&#160;</td><td class="fielddoc"><p >defines the r11 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78"></a>bf_reg_t_r12&#160;</td><td class="fielddoc"><p >defines the r12 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc"></a>bf_reg_t_r13&#160;</td><td class="fielddoc"><p >defines the r13 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce"></a>bf_reg_t_r14&#160;</td><td class="fielddoc"><p >defines the r14 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189"></a>bf_reg_t_r15&#160;</td><td class="fielddoc"><p >defines the r15 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2"></a>bf_reg_t_cr2&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_cr2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4"></a>bf_reg_t_dr6&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_dr6 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6"></a>bf_reg_t_star&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_star register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac"></a>bf_reg_t_lstar&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_lstar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b"></a>bf_reg_t_cstar&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_cstar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47"></a>bf_reg_t_fmask&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_fmask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf"></a>bf_reg_t_kernel_gs_base&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_kernel_gs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae2ee757d6545401e81e471df273bc12e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae2ee757d6545401e81e471df273bc12e"></a>bf_reg_t_virtual_processor_identifier&#160;</td><td class="fielddoc"><p >defines the virtual_processor_identifier register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a376d209b416dc268d0fdf0e92d9a5aca" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a376d209b416dc268d0fdf0e92d9a5aca"></a>bf_reg_t_posted_interrupt_notification_vector&#160;</td><td class="fielddoc"><p >defines the posted_interrupt_notification_vector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7562877f0136cfa3728a5ea45b7ccfe8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7562877f0136cfa3728a5ea45b7ccfe8"></a>bf_reg_t_eptp_index&#160;</td><td class="fielddoc"><p >defines the eptp_index register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f"></a>bf_reg_t_es_selector&#160;</td><td class="fielddoc"><p >defines the guest_es_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92"></a>bf_reg_t_cs_selector&#160;</td><td class="fielddoc"><p >defines the guest_cs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87"></a>bf_reg_t_ss_selector&#160;</td><td class="fielddoc"><p >defines the guest_ss_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06"></a>bf_reg_t_ds_selector&#160;</td><td class="fielddoc"><p >defines the guest_ds_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2"></a>bf_reg_t_fs_selector&#160;</td><td class="fielddoc"><p >defines the guest_fs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf"></a>bf_reg_t_gs_selector&#160;</td><td class="fielddoc"><p >defines the guest_gs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2"></a>bf_reg_t_ldtr_selector&#160;</td><td class="fielddoc"><p >defines the guest_ldtr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4"></a>bf_reg_t_tr_selector&#160;</td><td class="fielddoc"><p >defines the guest_tr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad72c489acff86e4b43c58bb5b2c9c19f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad72c489acff86e4b43c58bb5b2c9c19f"></a>bf_reg_t_interrupt_status&#160;</td><td class="fielddoc"><p >defines the guest_interrupt_status register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a67e16357b1825afa1184f37a660cc877" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a67e16357b1825afa1184f37a660cc877"></a>bf_reg_t_pml_index&#160;</td><td class="fielddoc"><p >defines the pml_index register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab04fa0d4e272efa9d892cdb5fb3260d9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab04fa0d4e272efa9d892cdb5fb3260d9"></a>bf_reg_t_address_of_io_bitmap_a&#160;</td><td class="fielddoc"><p >defines the address_of_io_bitmap_a register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4058487ce76a53c19a93c580047229a2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4058487ce76a53c19a93c580047229a2"></a>bf_reg_t_address_of_io_bitmap_b&#160;</td><td class="fielddoc"><p >defines the address_of_io_bitmap_b register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c9b31b39da68c647528be7252b938a8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c9b31b39da68c647528be7252b938a8"></a>bf_reg_t_address_of_msr_bitmaps&#160;</td><td class="fielddoc"><p >defines the address_of_msr_bitmaps register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6639f6b9cc541e0a91d21c4908bd465b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6639f6b9cc541e0a91d21c4908bd465b"></a>bf_reg_t_vmexit_msr_store_address&#160;</td><td class="fielddoc"><p >defines the vmexit_msr_store_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8fa9bafd16887cd3df30de6203baf2ae" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8fa9bafd16887cd3df30de6203baf2ae"></a>bf_reg_t_vmexit_msr_load_address&#160;</td><td class="fielddoc"><p >defines the vmexit_msr_load_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ade8a5405c910ad767f36d901f8ea3280" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ade8a5405c910ad767f36d901f8ea3280"></a>bf_reg_t_vmentry_msr_load_address&#160;</td><td class="fielddoc"><p >defines the vmentry_msr_load_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3bf1a5071b7759172f1e5502e1b3590d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3bf1a5071b7759172f1e5502e1b3590d"></a>bf_reg_t_executive_vmcs_pointer&#160;</td><td class="fielddoc"><p >defines the executive_vmcs_pointer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a10724f307aa18918e468fbc79bea17e6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a10724f307aa18918e468fbc79bea17e6"></a>bf_reg_t_pml_address&#160;</td><td class="fielddoc"><p >defines the pml_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275"></a>bf_reg_t_tsc_offset&#160;</td><td class="fielddoc"><p >defines the tsc_offset register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a63c87771bc870f498a93b8e80e0a93ef" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a63c87771bc870f498a93b8e80e0a93ef"></a>bf_reg_t_virtual_apic_address&#160;</td><td class="fielddoc"><p >defines the virtual_apic_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a966c1b2544188f5d43c179d3def40871" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a966c1b2544188f5d43c179d3def40871"></a>bf_reg_t_apic_access_address&#160;</td><td class="fielddoc"><p >defines the apic_access_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afbfb415d455265bfe83031365d2c5a7c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afbfb415d455265bfe83031365d2c5a7c"></a>bf_reg_t_posted_interrupt_descriptor_address&#160;</td><td class="fielddoc"><p >defines the posted_interrupt_descriptor_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab12c998989de32608b28854d44ae755c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab12c998989de32608b28854d44ae755c"></a>bf_reg_t_vm_function_controls&#160;</td><td class="fielddoc"><p >defines the vm_function_controls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae327819d46c934e0624864733958f4fb" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae327819d46c934e0624864733958f4fb"></a>bf_reg_t_ept_pointer&#160;</td><td class="fielddoc"><p >defines the ept_pointer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7c9db134b2fda34b67400adf6ff2a4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7c9db134b2fda34b67400adf6ff2a4"></a>bf_reg_t_eoi_exit_bitmap0&#160;</td><td class="fielddoc"><p >defines the eoi_exit_bitmap0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e8db285cae84a2142f2c2f0309285ac" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e8db285cae84a2142f2c2f0309285ac"></a>bf_reg_t_eoi_exit_bitmap1&#160;</td><td class="fielddoc"><p >defines the eoi_exit_bitmap1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae86a9e219278b2558a92d312ec7b9c73" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae86a9e219278b2558a92d312ec7b9c73"></a>bf_reg_t_eoi_exit_bitmap2&#160;</td><td class="fielddoc"><p >defines the eoi_exit_bitmap2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a07b5329a7129e074ec7b63d897cfa647" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a07b5329a7129e074ec7b63d897cfa647"></a>bf_reg_t_eoi_exit_bitmap3&#160;</td><td class="fielddoc"><p >defines the eoi_exit_bitmap3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d26e54db9374a1ea6f2310e919ee01f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d26e54db9374a1ea6f2310e919ee01f"></a>bf_reg_t_eptp_list_address&#160;</td><td class="fielddoc"><p >defines the eptp_list_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8faf367a52935d68159b86b65a30ecc1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8faf367a52935d68159b86b65a30ecc1"></a>bf_reg_t_vmread_bitmap_address&#160;</td><td class="fielddoc"><p >defines the vmread_bitmap_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae8235a3cbbc35d3d711aa55278e6579e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae8235a3cbbc35d3d711aa55278e6579e"></a>bf_reg_t_vmwrite_bitmap_address&#160;</td><td class="fielddoc"><p >defines the vmwrite_bitmap_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a03172213b8e9a43fa4402b4b6251f929" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a03172213b8e9a43fa4402b4b6251f929"></a>bf_reg_t_virt_exception_information_address&#160;</td><td class="fielddoc"><p >defines the virt_exception_information_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9af8d9f8a0c4896cbde3f0f0b3b0b30ddf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9af8d9f8a0c4896cbde3f0f0b3b0b30ddf"></a>bf_reg_t_xss_exiting_bitmap&#160;</td><td class="fielddoc"><p >defines the xss_exiting_bitmap register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a64ff356e11f75f7b5deffade8f02a7f3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a64ff356e11f75f7b5deffade8f02a7f3"></a>bf_reg_t_encls_exiting_bitmap&#160;</td><td class="fielddoc"><p >defines the encls_exiting_bitmap register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d69874113d71ac0abecf18aaa2b9e5d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d69874113d71ac0abecf18aaa2b9e5d"></a>bf_reg_t_sub_page_permission_table_pointer&#160;</td><td class="fielddoc"><p >defines the sub_page_permission_table_pointer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a77196c5f659935fae634a24f52df8804" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a77196c5f659935fae634a24f52df8804"></a>bf_reg_t_tsc_multiplier&#160;</td><td class="fielddoc"><p >defines the tsc_multiplier register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a19bf109c88f09256ce9ee9264b0cca49" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a19bf109c88f09256ce9ee9264b0cca49"></a>bf_reg_t_physical_address&#160;</td><td class="fielddoc"><p >defines the guest_physical_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c53c95f1e531b13fc305081b9b0a9c1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c53c95f1e531b13fc305081b9b0a9c1"></a>bf_reg_t_vmcs_link_pointer&#160;</td><td class="fielddoc"><p >defines the vmcs_link_pointer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8f67abd5cfee66d4787d414f9f795165" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8f67abd5cfee66d4787d414f9f795165"></a>bf_reg_t_debugctl&#160;</td><td class="fielddoc"><p >defines the guest_debugctl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3"></a>bf_reg_t_pat&#160;</td><td class="fielddoc"><p >defines the guest_pat register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877"></a>bf_reg_t_efer&#160;</td><td class="fielddoc"><p >defines the guest_efer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a194026a8b44306ece714579df44932ed" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a194026a8b44306ece714579df44932ed"></a>bf_reg_t_perf_global_ctrl&#160;</td><td class="fielddoc"><p >defines the guest_perf_global_ctrl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa629195bfa0cf8dbf568ccfbc695f4b7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa629195bfa0cf8dbf568ccfbc695f4b7"></a>bf_reg_t_pdpte0&#160;</td><td class="fielddoc"><p >defines the guest_pdpte0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5069897fe894add51d8d3d3a8da15c57" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5069897fe894add51d8d3d3a8da15c57"></a>bf_reg_t_pdpte1&#160;</td><td class="fielddoc"><p >defines the guest_pdpte1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7240b6fb184dba08764a9f2ccc1b89" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7240b6fb184dba08764a9f2ccc1b89"></a>bf_reg_t_pdpte2&#160;</td><td class="fielddoc"><p >defines the guest_pdpte2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a48c769218410f03f1af9c581d4259f1d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a48c769218410f03f1af9c581d4259f1d"></a>bf_reg_t_pdpte3&#160;</td><td class="fielddoc"><p >defines the guest_pdpte3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0d78bc979ee1fd49456b39693f81707c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0d78bc979ee1fd49456b39693f81707c"></a>bf_reg_t_bndcfgs&#160;</td><td class="fielddoc"><p >defines the guest_bndcfgs register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac086afef52de3a12706c55de1d207275" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac086afef52de3a12706c55de1d207275"></a>bf_reg_t_rtit_ctl&#160;</td><td class="fielddoc"><p >defines the guest_rtit_ctl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab955fd5ba8285dd649a1c3cec1285f6d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab955fd5ba8285dd649a1c3cec1285f6d"></a>bf_reg_t_pin_based_vm_execution_ctls&#160;</td><td class="fielddoc"><p >defines the pin_based_vm_execution_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a11301f3f015aae253172a85d976f5829" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a11301f3f015aae253172a85d976f5829"></a>bf_reg_t_primary_proc_based_vm_execution_ctls&#160;</td><td class="fielddoc"><p >defines the primary_proc_based_vm_execution_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a10a249a01e4a8409e44ae97397d23866" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a10a249a01e4a8409e44ae97397d23866"></a>bf_reg_t_exception_bitmap&#160;</td><td class="fielddoc"><p >defines the exception_bitmap register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab02da89523643d3c6fb1b2520772de08" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab02da89523643d3c6fb1b2520772de08"></a>bf_reg_t_page_fault_error_code_mask&#160;</td><td class="fielddoc"><p >defines the page_fault_error_code_mask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abd20bddc030820399d7fb942f0384d6c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abd20bddc030820399d7fb942f0384d6c"></a>bf_reg_t_page_fault_error_code_match&#160;</td><td class="fielddoc"><p >defines the page_fault_error_code_match register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aaa62782cf540d9e5a0b784061e2ce21b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aaa62782cf540d9e5a0b784061e2ce21b"></a>bf_reg_t_cr3_target_count&#160;</td><td class="fielddoc"><p >defines the cr3_target_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4263b9a5148a151548a1bde220cb104b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4263b9a5148a151548a1bde220cb104b"></a>bf_reg_t_vmexit_ctls&#160;</td><td class="fielddoc"><p >defines the vmexit_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3eec7378e3f238cab999ab6b15110d4a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3eec7378e3f238cab999ab6b15110d4a"></a>bf_reg_t_vmexit_msr_store_count&#160;</td><td class="fielddoc"><p >defines the vmexit_msr_store_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a896905954a40faa22ae0585c7619e8b6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a896905954a40faa22ae0585c7619e8b6"></a>bf_reg_t_vmexit_msr_load_count&#160;</td><td class="fielddoc"><p >defines the vmexit_msr_load_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac7ab067ca2e1740ef032db483a86c068" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac7ab067ca2e1740ef032db483a86c068"></a>bf_reg_t_vmentry_ctls&#160;</td><td class="fielddoc"><p >defines the vmentry_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3622da1719bcb20cd0d10d26bfabd795" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3622da1719bcb20cd0d10d26bfabd795"></a>bf_reg_t_vmentry_msr_load_count&#160;</td><td class="fielddoc"><p >defines the vmentry_msr_load_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a135680a2db2eb680246c4f4333eda778" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a135680a2db2eb680246c4f4333eda778"></a>bf_reg_t_vmentry_interrupt_information_field&#160;</td><td class="fielddoc"><p >defines the vmentry_interrupt_information_field register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab3f8b4524e5446839d5df83ccc4fa39a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab3f8b4524e5446839d5df83ccc4fa39a"></a>bf_reg_t_vmentry_exception_error_code&#160;</td><td class="fielddoc"><p >defines the vmentry_exception_error_code register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0af3822dff2d01f6eee05009ed2a164" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0af3822dff2d01f6eee05009ed2a164"></a>bf_reg_t_vmentry_instruction_length&#160;</td><td class="fielddoc"><p >defines the vmentry_instruction_length register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88f56a31b18fbfaec0f76689c223411f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88f56a31b18fbfaec0f76689c223411f"></a>bf_reg_t_tpr_threshold&#160;</td><td class="fielddoc"><p >defines the tpr_threshold register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae1e0be868bac167644d4897de6a21a20" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae1e0be868bac167644d4897de6a21a20"></a>bf_reg_t_secondary_proc_based_vm_execution_ctls&#160;</td><td class="fielddoc"><p >defines the secondary_proc_based_vm_execution_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a876dccb0536d91f345dd094482d705f4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a876dccb0536d91f345dd094482d705f4"></a>bf_reg_t_ple_gap&#160;</td><td class="fielddoc"><p >defines the ple_gap register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa36dfb0f98fdba579ffc202e0df323c5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa36dfb0f98fdba579ffc202e0df323c5"></a>bf_reg_t_ple_window&#160;</td><td class="fielddoc"><p >defines the ple_window register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a57de1a34a282f1c1b0740ebecfee98ec" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a57de1a34a282f1c1b0740ebecfee98ec"></a>bf_reg_t_vm_instruction_error&#160;</td><td class="fielddoc"><p >defines the vm_instruction_error register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a91061562226ec47b8bd4571215f4c72f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a91061562226ec47b8bd4571215f4c72f"></a>bf_reg_t_exit_reason&#160;</td><td class="fielddoc"><p >defines the exit_reason register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e4f1d94e2509e8f53d6c2fcbed60f17" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e4f1d94e2509e8f53d6c2fcbed60f17"></a>bf_reg_t_vmexit_interruption_information&#160;</td><td class="fielddoc"><p >defines the vmexit_interruption_information register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2ef995fa65ef86fdb6e96309fcc3c8a5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2ef995fa65ef86fdb6e96309fcc3c8a5"></a>bf_reg_t_vmexit_interruption_error_code&#160;</td><td class="fielddoc"><p >defines the vmexit_interruption_error_code register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a11a67f6ac06911c3dfe8a10bc80ea461" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a11a67f6ac06911c3dfe8a10bc80ea461"></a>bf_reg_t_idt_vectoring_information_field&#160;</td><td class="fielddoc"><p >defines the idt_vectoring_information_field register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26dbaf904e1edb4074c87d436806805c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26dbaf904e1edb4074c87d436806805c"></a>bf_reg_t_idt_vectoring_error_code&#160;</td><td class="fielddoc"><p >defines the idt_vectoring_error_code register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c376159d0d70b0b4047b69e03f73727" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c376159d0d70b0b4047b69e03f73727"></a>bf_reg_t_vmexit_instruction_length&#160;</td><td class="fielddoc"><p >defines the vmexit_instruction_length register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5d23abe220f824162359e9707c1f5eaf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5d23abe220f824162359e9707c1f5eaf"></a>bf_reg_t_vmexit_instruction_information&#160;</td><td class="fielddoc"><p >defines the vmexit_instruction_information register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e"></a>bf_reg_t_es_limit&#160;</td><td class="fielddoc"><p >defines the guest_es_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d"></a>bf_reg_t_cs_limit&#160;</td><td class="fielddoc"><p >defines the guest_cs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57"></a>bf_reg_t_ss_limit&#160;</td><td class="fielddoc"><p >defines the guest_ss_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc"></a>bf_reg_t_ds_limit&#160;</td><td class="fielddoc"><p >defines the guest_ds_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4"></a>bf_reg_t_fs_limit&#160;</td><td class="fielddoc"><p >defines the guest_fs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6"></a>bf_reg_t_gs_limit&#160;</td><td class="fielddoc"><p >defines the guest_gs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1"></a>bf_reg_t_ldtr_limit&#160;</td><td class="fielddoc"><p >defines the guest_ldtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4"></a>bf_reg_t_tr_limit&#160;</td><td class="fielddoc"><p >defines the guest_tr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9"></a>bf_reg_t_gdtr_limit&#160;</td><td class="fielddoc"><p >defines the guest_gdtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7"></a>bf_reg_t_idtr_limit&#160;</td><td class="fielddoc"><p >defines the guest_idtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c"></a>bf_reg_t_es_attrib&#160;</td><td class="fielddoc"><p >defines the guest_es_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0"></a>bf_reg_t_cs_attrib&#160;</td><td class="fielddoc"><p >defines the guest_cs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a"></a>bf_reg_t_ss_attrib&#160;</td><td class="fielddoc"><p >defines the guest_ss_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840"></a>bf_reg_t_ds_attrib&#160;</td><td class="fielddoc"><p >defines the guest_ds_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99"></a>bf_reg_t_fs_attrib&#160;</td><td class="fielddoc"><p >defines the guest_fs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9"></a>bf_reg_t_gs_attrib&#160;</td><td class="fielddoc"><p >defines the guest_gs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476"></a>bf_reg_t_ldtr_attrib&#160;</td><td class="fielddoc"><p >defines the guest_ldtr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5"></a>bf_reg_t_tr_attrib&#160;</td><td class="fielddoc"><p >defines the guest_tr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0ecff748f6e482bf8b46524615ee0c44" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0ecff748f6e482bf8b46524615ee0c44"></a>bf_reg_t_interruptibility_state&#160;</td><td class="fielddoc"><p >defines the guest_interruptibility_state register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a190ada235f06637d33f5d2d7a00869f2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a190ada235f06637d33f5d2d7a00869f2"></a>bf_reg_t_activity_state&#160;</td><td class="fielddoc"><p >defines the guest_activity_state register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7de1bd0395025dd7abef30fe70e0d67" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7de1bd0395025dd7abef30fe70e0d67"></a>bf_reg_t_smbase&#160;</td><td class="fielddoc"><p >defines the guest_smbase register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0"></a>bf_reg_t_sysenter_cs&#160;</td><td class="fielddoc"><p >defines the guest_sysenter_cs register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a24579f38e622082a14459aa44363ce84" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a24579f38e622082a14459aa44363ce84"></a>bf_reg_t_vmx_preemption_timer_value&#160;</td><td class="fielddoc"><p >defines the vmx_preemption_timer_value register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9af72c2c12ac14130fb76771305da2db42" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9af72c2c12ac14130fb76771305da2db42"></a>bf_reg_t_cr0_guest_host_mask&#160;</td><td class="fielddoc"><p >defines the cr0_guest_host_mask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e72419c9ce8e5096d20a816492d488e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e72419c9ce8e5096d20a816492d488e"></a>bf_reg_t_cr4_guest_host_mask&#160;</td><td class="fielddoc"><p >defines the cr4_guest_host_mask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee9ea84cbcd2f277f9bde6e3c9a0770c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee9ea84cbcd2f277f9bde6e3c9a0770c"></a>bf_reg_t_cr0_read_shadow&#160;</td><td class="fielddoc"><p >defines the cr0_read_shadow register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac73f9b8bddbffc31f141741d1d901559" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac73f9b8bddbffc31f141741d1d901559"></a>bf_reg_t_cr4_read_shadow&#160;</td><td class="fielddoc"><p >defines the cr4_read_shadow register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e635957fbb132be4a6dabb6ce86be94" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e635957fbb132be4a6dabb6ce86be94"></a>bf_reg_t_cr3_target_value0&#160;</td><td class="fielddoc"><p >defines the cr3_target_value0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a59f94320271476fc04523a3aa321f846" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a59f94320271476fc04523a3aa321f846"></a>bf_reg_t_cr3_target_value1&#160;</td><td class="fielddoc"><p >defines the cr3_target_value1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac6bdd033b73352cda1f4401a9a01f1dd" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac6bdd033b73352cda1f4401a9a01f1dd"></a>bf_reg_t_cr3_target_value2&#160;</td><td class="fielddoc"><p >defines the cr3_target_value2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c85dd5e2641b8627c1ada1f7e96e913" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c85dd5e2641b8627c1ada1f7e96e913"></a>bf_reg_t_cr3_target_value3&#160;</td><td class="fielddoc"><p >defines the cr3_target_value3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f5d7dd1a0554024507b213c5aaacae2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f5d7dd1a0554024507b213c5aaacae2"></a>bf_reg_t_exit_qualification&#160;</td><td class="fielddoc"><p >defines the exit_qualification register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae65fe71a1c71a67d0a45f826cedfcf27" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae65fe71a1c71a67d0a45f826cedfcf27"></a>bf_reg_t_io_rcx&#160;</td><td class="fielddoc"><p >defines the io_rcx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a4b8d5c31723f05be3eacdfeae654b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a4b8d5c31723f05be3eacdfeae654b"></a>bf_reg_t_io_rsi&#160;</td><td class="fielddoc"><p >defines the io_rsi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9e9092b7e0b5a56e6fb157b7e638c615" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9e9092b7e0b5a56e6fb157b7e638c615"></a>bf_reg_t_io_rdi&#160;</td><td class="fielddoc"><p >defines the io_rdi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f2f9731ad0cf8a8a4d01b0d59ab951a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f2f9731ad0cf8a8a4d01b0d59ab951a"></a>bf_reg_t_io_rip&#160;</td><td class="fielddoc"><p >defines the io_rip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2aa41076fe5d64027ffb7fc35691755d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2aa41076fe5d64027ffb7fc35691755d"></a>bf_reg_t_linear_address&#160;</td><td class="fielddoc"><p >defines the guest_linear_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1"></a>bf_reg_t_cr0&#160;</td><td class="fielddoc"><p >defines the guest_cr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c"></a>bf_reg_t_cr3&#160;</td><td class="fielddoc"><p >defines the guest_cr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1"></a>bf_reg_t_cr4&#160;</td><td class="fielddoc"><p >defines the guest_cr4 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8"></a>bf_reg_t_es_base&#160;</td><td class="fielddoc"><p >defines the guest_es_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0"></a>bf_reg_t_cs_base&#160;</td><td class="fielddoc"><p >defines the guest_cs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d"></a>bf_reg_t_ss_base&#160;</td><td class="fielddoc"><p >defines the guest_ss_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd"></a>bf_reg_t_ds_base&#160;</td><td class="fielddoc"><p >defines the guest_ds_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e"></a>bf_reg_t_fs_base&#160;</td><td class="fielddoc"><p >defines the guest_fs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8"></a>bf_reg_t_gs_base&#160;</td><td class="fielddoc"><p >defines the guest_gs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69"></a>bf_reg_t_ldtr_base&#160;</td><td class="fielddoc"><p >defines the guest_ldtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86"></a>bf_reg_t_tr_base&#160;</td><td class="fielddoc"><p >defines the guest_tr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee"></a>bf_reg_t_gdtr_base&#160;</td><td class="fielddoc"><p >defines the guest_gdtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0"></a>bf_reg_t_idtr_base&#160;</td><td class="fielddoc"><p >defines the guest_idtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99"></a>bf_reg_t_dr7&#160;</td><td class="fielddoc"><p >defines the guest_dr7 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0"></a>bf_reg_t_rsp&#160;</td><td class="fielddoc"><p >defines the guest_rsp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355"></a>bf_reg_t_rip&#160;</td><td class="fielddoc"><p >defines the guest_rip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9"></a>bf_reg_t_rflags&#160;</td><td class="fielddoc"><p >defines the guest_rflags register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9add6e5a94ed55a7010d5df32eba2ed22e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9add6e5a94ed55a7010d5df32eba2ed22e"></a>bf_reg_t_pending_debug_exceptions&#160;</td><td class="fielddoc"><p >defines the guest_pending_debug_exceptions register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2"></a>bf_reg_t_sysenter_esp&#160;</td><td class="fielddoc"><p >defines the guest_sysenter_esp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1"></a>bf_reg_t_sysenter_eip&#160;</td><td class="fielddoc"><p >defines the guest_sysenter_eip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c"></a>bf_reg_t_cr8&#160;</td><td class="fielddoc"><p >defines the cr8 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20"></a>bf_reg_t_dr0&#160;</td><td class="fielddoc"><p >defines the dr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d"></a>bf_reg_t_dr1&#160;</td><td class="fielddoc"><p >defines the dr1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244"></a>bf_reg_t_dr2&#160;</td><td class="fielddoc"><p >defines the dr2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d"></a>bf_reg_t_dr3&#160;</td><td class="fielddoc"><p >defines the dr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc"></a>bf_reg_t_xcr0&#160;</td><td class="fielddoc"><p >defines the xcr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7"></a>bf_reg_t_invalid&#160;</td><td class="fielddoc"><p >defines an invalid bf_reg_t </p>
</td></tr>
</table>

</div>
</div>
<a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e3c7a4f139e3d2c85be4c8b8fc90b9">&#9670;&nbsp;</a></span>bf_reg_t <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">syscall::bf_reg_t</a> : bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines which register is being requested by certain syscalls. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489"></a>bf_reg_t_unsupported&#160;</td><td class="fielddoc"><p >defines an unsupported register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7"></a>bf_reg_t_rbx&#160;</td><td class="fielddoc"><p >defines the rbx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84"></a>bf_reg_t_rcx&#160;</td><td class="fielddoc"><p >defines the rcx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b"></a>bf_reg_t_rdx&#160;</td><td class="fielddoc"><p >defines the rdx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4"></a>bf_reg_t_rbp&#160;</td><td class="fielddoc"><p >defines the rbp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d"></a>bf_reg_t_rsi&#160;</td><td class="fielddoc"><p >defines the rsi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843"></a>bf_reg_t_rdi&#160;</td><td class="fielddoc"><p >defines the rdi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8"></a>bf_reg_t_r8&#160;</td><td class="fielddoc"><p >defines the r8 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a"></a>bf_reg_t_r9&#160;</td><td class="fielddoc"><p >defines the r9 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3"></a>bf_reg_t_r10&#160;</td><td class="fielddoc"><p >defines the r10 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1"></a>bf_reg_t_r11&#160;</td><td class="fielddoc"><p >defines the r11 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78"></a>bf_reg_t_r12&#160;</td><td class="fielddoc"><p >defines the r12 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc"></a>bf_reg_t_r13&#160;</td><td class="fielddoc"><p >defines the r13 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce"></a>bf_reg_t_r14&#160;</td><td class="fielddoc"><p >defines the r14 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189"></a>bf_reg_t_r15&#160;</td><td class="fielddoc"><p >defines the r15 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa97688dfecdb28ee4e53ef18d8808477" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa97688dfecdb28ee4e53ef18d8808477"></a>bf_reg_t_intercept_cr_read&#160;</td><td class="fielddoc"><p >defines the intercept_cr_read register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeecd0d0b9698727101f57eee07bfc036" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeecd0d0b9698727101f57eee07bfc036"></a>bf_reg_t_intercept_cr_write&#160;</td><td class="fielddoc"><p >defines the intercept_cr_write register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afe94dca53be1be240606b4021ef48896" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afe94dca53be1be240606b4021ef48896"></a>bf_reg_t_intercept_dr_read&#160;</td><td class="fielddoc"><p >defines the intercept_dr_read register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d23feab96fe2f710403007f59071a95" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d23feab96fe2f710403007f59071a95"></a>bf_reg_t_intercept_dr_write&#160;</td><td class="fielddoc"><p >defines the intercept_dr_write register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad6d94b9bbbded796e9764e824f1e7b23" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad6d94b9bbbded796e9764e824f1e7b23"></a>bf_reg_t_intercept_exception&#160;</td><td class="fielddoc"><p >defines the intercept_exception register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6015ab17b020f7012909b6d5c57b72a0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6015ab17b020f7012909b6d5c57b72a0"></a>bf_reg_t_intercept_instruction1&#160;</td><td class="fielddoc"><p >defines the intercept_instruction1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7e9eb25f33bb81f4972574b82c48d8be" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7e9eb25f33bb81f4972574b82c48d8be"></a>bf_reg_t_intercept_instruction2&#160;</td><td class="fielddoc"><p >defines the intercept_instruction2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a815be2536af711f608c60c31bf595ef0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a815be2536af711f608c60c31bf595ef0"></a>bf_reg_t_intercept_instruction3&#160;</td><td class="fielddoc"><p >defines the intercept_instruction3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a32ef25f9973c36148ee629222a9cfc4b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a32ef25f9973c36148ee629222a9cfc4b"></a>bf_reg_t_pause_filter_threshold&#160;</td><td class="fielddoc"><p >defines the pause_filter_threshold register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afc0ff0bd0c59831b5c56d9855a1624bc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afc0ff0bd0c59831b5c56d9855a1624bc"></a>bf_reg_t_pause_filter_count&#160;</td><td class="fielddoc"><p >defines the pause_filter_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a86d6efa2b9d4cea2b33f2b5a93b34742" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a86d6efa2b9d4cea2b33f2b5a93b34742"></a>bf_reg_t_iopm_base_pa&#160;</td><td class="fielddoc"><p >defines the iopm_base_pa register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a36cfc16dbc1524ba74f614c4df2d5c3e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a36cfc16dbc1524ba74f614c4df2d5c3e"></a>bf_reg_t_msrpm_base_pa&#160;</td><td class="fielddoc"><p >defines the msrpm_base_pa register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275"></a>bf_reg_t_tsc_offset&#160;</td><td class="fielddoc"><p >defines the tsc_offset register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a91e6cdebcb2ef2f9fdd01e5b1d332124" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a91e6cdebcb2ef2f9fdd01e5b1d332124"></a>bf_reg_t_guest_asid&#160;</td><td class="fielddoc"><p >defines the guest_asid register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae7b6abeddec279c2e24d530f69e8ea48" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae7b6abeddec279c2e24d530f69e8ea48"></a>bf_reg_t_tlb_control&#160;</td><td class="fielddoc"><p >defines the tlb_control register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7dfa7b7ad301c186418e0cd8bdcbac1b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7dfa7b7ad301c186418e0cd8bdcbac1b"></a>bf_reg_t_virtual_interrupt_a&#160;</td><td class="fielddoc"><p >defines the virtual_interrupt_a register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a152c3df283c4fc748ee125040bb86032" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a152c3df283c4fc748ee125040bb86032"></a>bf_reg_t_virtual_interrupt_b&#160;</td><td class="fielddoc"><p >defines the virtual_interrupt_b register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a584fa23b25dfc2320d0075ecfd5f5724" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a584fa23b25dfc2320d0075ecfd5f5724"></a>bf_reg_t_exitcode&#160;</td><td class="fielddoc"><p >defines the exitcode register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ace6a44bc577a2e5587df99b7dbcfac18" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ace6a44bc577a2e5587df99b7dbcfac18"></a>bf_reg_t_exitinfo1&#160;</td><td class="fielddoc"><p >defines the exitinfo1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a05731134ec34282c67f0dbe03b4e05c0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a05731134ec34282c67f0dbe03b4e05c0"></a>bf_reg_t_exitinfo2&#160;</td><td class="fielddoc"><p >defines the exitinfo2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abe41c9ebc806f09f31143848c7780224" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abe41c9ebc806f09f31143848c7780224"></a>bf_reg_t_exitininfo&#160;</td><td class="fielddoc"><p >defines the exitininfo register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a36fdc0842641d424829ccaeb99363c35" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a36fdc0842641d424829ccaeb99363c35"></a>bf_reg_t_ctls1&#160;</td><td class="fielddoc"><p >defines the ctls1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a22406fac3fb48fbe659908c2000e3f2c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a22406fac3fb48fbe659908c2000e3f2c"></a>bf_reg_t_avic_apic_bar&#160;</td><td class="fielddoc"><p >defines the avic_apic_bar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a83dbdf26d64314db84000353e578f88b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a83dbdf26d64314db84000353e578f88b"></a>bf_reg_t_guest_pa_of_ghcb&#160;</td><td class="fielddoc"><p >defines the guest_pa_of_ghcb register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3aab240be169e7d1516da9d9f7f57cbe" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3aab240be169e7d1516da9d9f7f57cbe"></a>bf_reg_t_eventinj&#160;</td><td class="fielddoc"><p >defines the eventinj register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab359ec586c93e2495766c8e9ff105565" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab359ec586c93e2495766c8e9ff105565"></a>bf_reg_t_n_cr3&#160;</td><td class="fielddoc"><p >defines the n_cr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab251cc88d1b21f7d930ce771fe44784c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab251cc88d1b21f7d930ce771fe44784c"></a>bf_reg_t_ctls2&#160;</td><td class="fielddoc"><p >defines the ctls2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9948b21fe77d40fa6dae12949473cd31" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9948b21fe77d40fa6dae12949473cd31"></a>bf_reg_t_vmcb_clean_bits&#160;</td><td class="fielddoc"><p >defines the vmcb_clean_bits register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9186b6fa41430dc0fd77d0bbe202be80" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9186b6fa41430dc0fd77d0bbe202be80"></a>bf_reg_t_nrip&#160;</td><td class="fielddoc"><p >defines the nrip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a512e65b853f75b892881a65e6a8d4d9f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a512e65b853f75b892881a65e6a8d4d9f"></a>bf_reg_t_number_of_bytes_fetched&#160;</td><td class="fielddoc"><p >defines the number_of_bytes_fetched register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a53a80576ad2a07feca3f651e6f74bc76" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a53a80576ad2a07feca3f651e6f74bc76"></a>bf_reg_t_avic_apic_backing_page_ptr&#160;</td><td class="fielddoc"><p >defines the avic_apic_backing_page_ptr register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1104bf6127ff0f030aba5ff4cc59b13a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1104bf6127ff0f030aba5ff4cc59b13a"></a>bf_reg_t_avic_logical_table_ptr&#160;</td><td class="fielddoc"><p >defines the avic_logical_table_ptr register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6d23d215b4e8e99de91ae50098d11c38" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6d23d215b4e8e99de91ae50098d11c38"></a>bf_reg_t_avic_physical_table_ptr&#160;</td><td class="fielddoc"><p >defines the avic_physical_table_ptr register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5de963101ef099e898cd5646877b2876" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5de963101ef099e898cd5646877b2876"></a>bf_reg_t_vmsa_ptr&#160;</td><td class="fielddoc"><p >defines the vmsa_ptr register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f"></a>bf_reg_t_es_selector&#160;</td><td class="fielddoc"><p >defines the es_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c"></a>bf_reg_t_es_attrib&#160;</td><td class="fielddoc"><p >defines the es_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e"></a>bf_reg_t_es_limit&#160;</td><td class="fielddoc"><p >defines the es_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8"></a>bf_reg_t_es_base&#160;</td><td class="fielddoc"><p >defines the es_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92"></a>bf_reg_t_cs_selector&#160;</td><td class="fielddoc"><p >defines the cs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0"></a>bf_reg_t_cs_attrib&#160;</td><td class="fielddoc"><p >defines the cs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d"></a>bf_reg_t_cs_limit&#160;</td><td class="fielddoc"><p >defines the cs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0"></a>bf_reg_t_cs_base&#160;</td><td class="fielddoc"><p >defines the cs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87"></a>bf_reg_t_ss_selector&#160;</td><td class="fielddoc"><p >defines the ss_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a"></a>bf_reg_t_ss_attrib&#160;</td><td class="fielddoc"><p >defines the ss_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57"></a>bf_reg_t_ss_limit&#160;</td><td class="fielddoc"><p >defines the ss_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d"></a>bf_reg_t_ss_base&#160;</td><td class="fielddoc"><p >defines the ss_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06"></a>bf_reg_t_ds_selector&#160;</td><td class="fielddoc"><p >defines the ds_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840"></a>bf_reg_t_ds_attrib&#160;</td><td class="fielddoc"><p >defines the ds_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc"></a>bf_reg_t_ds_limit&#160;</td><td class="fielddoc"><p >defines the ds_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd"></a>bf_reg_t_ds_base&#160;</td><td class="fielddoc"><p >defines the ds_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2"></a>bf_reg_t_fs_selector&#160;</td><td class="fielddoc"><p >defines the fs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99"></a>bf_reg_t_fs_attrib&#160;</td><td class="fielddoc"><p >defines the fs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4"></a>bf_reg_t_fs_limit&#160;</td><td class="fielddoc"><p >defines the fs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e"></a>bf_reg_t_fs_base&#160;</td><td class="fielddoc"><p >defines the fs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf"></a>bf_reg_t_gs_selector&#160;</td><td class="fielddoc"><p >defines the gs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9"></a>bf_reg_t_gs_attrib&#160;</td><td class="fielddoc"><p >defines the gs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6"></a>bf_reg_t_gs_limit&#160;</td><td class="fielddoc"><p >defines the gs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8"></a>bf_reg_t_gs_base&#160;</td><td class="fielddoc"><p >defines the gs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aaf1e1ce886840d9f11363f34d1b22154" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aaf1e1ce886840d9f11363f34d1b22154"></a>bf_reg_t_gdtr_selector&#160;</td><td class="fielddoc"><p >defines the gdtr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1108342645405b79f8a789cbdfd0f3f6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1108342645405b79f8a789cbdfd0f3f6"></a>bf_reg_t_gdtr_attrib&#160;</td><td class="fielddoc"><p >defines the gdtr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9"></a>bf_reg_t_gdtr_limit&#160;</td><td class="fielddoc"><p >defines the gdtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee"></a>bf_reg_t_gdtr_base&#160;</td><td class="fielddoc"><p >defines the gdtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2"></a>bf_reg_t_ldtr_selector&#160;</td><td class="fielddoc"><p >defines the ldtr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476"></a>bf_reg_t_ldtr_attrib&#160;</td><td class="fielddoc"><p >defines the ldtr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1"></a>bf_reg_t_ldtr_limit&#160;</td><td class="fielddoc"><p >defines the ldtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69"></a>bf_reg_t_ldtr_base&#160;</td><td class="fielddoc"><p >defines the ldtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0f1e234d6f188d085527f18e2c7820cc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0f1e234d6f188d085527f18e2c7820cc"></a>bf_reg_t_idtr_selector&#160;</td><td class="fielddoc"><p >defines the idtr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a799920a72530f595381969074967a2b4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a799920a72530f595381969074967a2b4"></a>bf_reg_t_idtr_attrib&#160;</td><td class="fielddoc"><p >defines the idtr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7"></a>bf_reg_t_idtr_limit&#160;</td><td class="fielddoc"><p >defines the idtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0"></a>bf_reg_t_idtr_base&#160;</td><td class="fielddoc"><p >defines the idtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4"></a>bf_reg_t_tr_selector&#160;</td><td class="fielddoc"><p >defines the tr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5"></a>bf_reg_t_tr_attrib&#160;</td><td class="fielddoc"><p >defines the tr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4"></a>bf_reg_t_tr_limit&#160;</td><td class="fielddoc"><p >defines the tr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86"></a>bf_reg_t_tr_base&#160;</td><td class="fielddoc"><p >defines the tr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c28258484949c7a52c50e25cdecc6db" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c28258484949c7a52c50e25cdecc6db"></a>bf_reg_t_cpl&#160;</td><td class="fielddoc"><p >defines the cpl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877"></a>bf_reg_t_efer&#160;</td><td class="fielddoc"><p >defines the efer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1"></a>bf_reg_t_cr4&#160;</td><td class="fielddoc"><p >defines the cr4 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c"></a>bf_reg_t_cr3&#160;</td><td class="fielddoc"><p >defines the cr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1"></a>bf_reg_t_cr0&#160;</td><td class="fielddoc"><p >defines the cr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99"></a>bf_reg_t_dr7&#160;</td><td class="fielddoc"><p >defines the dr7 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4"></a>bf_reg_t_dr6&#160;</td><td class="fielddoc"><p >defines the dr6 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9"></a>bf_reg_t_rflags&#160;</td><td class="fielddoc"><p >defines the rflags register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355"></a>bf_reg_t_rip&#160;</td><td class="fielddoc"><p >defines the rip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0"></a>bf_reg_t_rsp&#160;</td><td class="fielddoc"><p >defines the rsp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78"></a>bf_reg_t_rax&#160;</td><td class="fielddoc"><p >defines the rax register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6"></a>bf_reg_t_star&#160;</td><td class="fielddoc"><p >defines the star register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac"></a>bf_reg_t_lstar&#160;</td><td class="fielddoc"><p >defines the lstar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b"></a>bf_reg_t_cstar&#160;</td><td class="fielddoc"><p >defines the cstar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47"></a>bf_reg_t_fmask&#160;</td><td class="fielddoc"><p >defines the fmask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf"></a>bf_reg_t_kernel_gs_base&#160;</td><td class="fielddoc"><p >defines the kernel_gs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0"></a>bf_reg_t_sysenter_cs&#160;</td><td class="fielddoc"><p >defines the sysenter_cs register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2"></a>bf_reg_t_sysenter_esp&#160;</td><td class="fielddoc"><p >defines the sysenter_esp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1"></a>bf_reg_t_sysenter_eip&#160;</td><td class="fielddoc"><p >defines the sysenter_eip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2"></a>bf_reg_t_cr2&#160;</td><td class="fielddoc"><p >defines the cr2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3"></a>bf_reg_t_pat&#160;</td><td class="fielddoc"><p >defines the pat register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acecd07371de6e931e2ef143973846761" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acecd07371de6e931e2ef143973846761"></a>bf_reg_t_dbgctl&#160;</td><td class="fielddoc"><p >defines the dbgctl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa48147b7094cd91eaa3ca9e8b358dcc5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa48147b7094cd91eaa3ca9e8b358dcc5"></a>bf_reg_t_br_from&#160;</td><td class="fielddoc"><p >defines the br_from register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad455c48f5f0e764b7080affcb11ac466" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad455c48f5f0e764b7080affcb11ac466"></a>bf_reg_t_br_to&#160;</td><td class="fielddoc"><p >defines the br_to register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7c1d99263f002aed282eee3007f243d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7c1d99263f002aed282eee3007f243d"></a>bf_reg_t_lastexcpfrom&#160;</td><td class="fielddoc"><p >defines the lastexcpfrom register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a61093d9ca5c58a5fd5d1a2ae9783d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a61093d9ca5c58a5fd5d1a2ae9783d"></a>bf_reg_t_lastexcpto&#160;</td><td class="fielddoc"><p >defines the lastexcpto register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c"></a>bf_reg_t_cr8&#160;</td><td class="fielddoc"><p >defines the cr8 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20"></a>bf_reg_t_dr0&#160;</td><td class="fielddoc"><p >defines the dr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d"></a>bf_reg_t_dr1&#160;</td><td class="fielddoc"><p >defines the dr1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244"></a>bf_reg_t_dr2&#160;</td><td class="fielddoc"><p >defines the dr2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d"></a>bf_reg_t_dr3&#160;</td><td class="fielddoc"><p >defines the dr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc"></a>bf_reg_t_xcr0&#160;</td><td class="fielddoc"><p >defines the xcr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7"></a>bf_reg_t_invalid&#160;</td><td class="fielddoc"><p >defines an invalid bf_reg_t </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa98bea5a4fc1b7d11b9f297511d55489"></a>bf_reg_t_unsupported&#160;</td><td class="fielddoc"><p >defines an unsupported register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a727bab52f65c70efff0d6178a1c8dd78"></a>bf_reg_t_rax&#160;</td><td class="fielddoc"><p >defines the rax register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88a57a9c763b555985c498dbff88e9c7"></a>bf_reg_t_rbx&#160;</td><td class="fielddoc"><p >defines the rbx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a99ff765675f93ad86e5a15989688ad84"></a>bf_reg_t_rcx&#160;</td><td class="fielddoc"><p >defines the rcx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab0abfe051fcceac3b3ed43514fd0687b"></a>bf_reg_t_rdx&#160;</td><td class="fielddoc"><p >defines the rdx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9af19ecae3b3641ad4a1b3f51f03db1da4"></a>bf_reg_t_rbp&#160;</td><td class="fielddoc"><p >defines the rbp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a415f0e7fff65c205bf498b4cbbb57e2d"></a>bf_reg_t_rsi&#160;</td><td class="fielddoc"><p >defines the rsi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac02e3db22c16e864ddf4b22332b3b843"></a>bf_reg_t_rdi&#160;</td><td class="fielddoc"><p >defines the rdi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a75952688096534f50bbae9415f6018e8"></a>bf_reg_t_r8&#160;</td><td class="fielddoc"><p >defines the r8 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a257b400a3a3dc9fd95e187f46f145a0a"></a>bf_reg_t_r9&#160;</td><td class="fielddoc"><p >defines the r9 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9d6ea200428db851a1df8a026de81ba3"></a>bf_reg_t_r10&#160;</td><td class="fielddoc"><p >defines the r10 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a303204b4a410e72774368f57be8fe3d1"></a>bf_reg_t_r11&#160;</td><td class="fielddoc"><p >defines the r11 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a30e4ff64e14ec5635fdcf97f3d944d78"></a>bf_reg_t_r12&#160;</td><td class="fielddoc"><p >defines the r12 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a50188cb510cdf12c94c229d4b9e1c8bc"></a>bf_reg_t_r13&#160;</td><td class="fielddoc"><p >defines the r13 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6782c017bacf25bcb729fc5e7da419ce"></a>bf_reg_t_r14&#160;</td><td class="fielddoc"><p >defines the r14 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed69720a6e6e2304db9ba8ae8c647189"></a>bf_reg_t_r15&#160;</td><td class="fielddoc"><p >defines the r15 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab5af64a8ae84178803a75acaf3343ec2"></a>bf_reg_t_cr2&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_cr2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f7d24323831a2612ec5557ad3e69fd4"></a>bf_reg_t_dr6&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_dr6 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa676ef470cc7c82d3072449b4d82bdb6"></a>bf_reg_t_star&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_star register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26325e81524a6c58a406a8c1f265faac"></a>bf_reg_t_lstar&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_lstar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c3baebbe687b5ba1b69df1aa716132b"></a>bf_reg_t_cstar&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_cstar register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1a90488428bfea5aedc3b8b2cbdbab47"></a>bf_reg_t_fmask&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_fmask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0b067b7167e54dfa901c959e46166bf"></a>bf_reg_t_kernel_gs_base&#160;</td><td class="fielddoc"><p >defines the bf_reg_t_kernel_gs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae2ee757d6545401e81e471df273bc12e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae2ee757d6545401e81e471df273bc12e"></a>bf_reg_t_virtual_processor_identifier&#160;</td><td class="fielddoc"><p >defines the virtual_processor_identifier register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a376d209b416dc268d0fdf0e92d9a5aca" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a376d209b416dc268d0fdf0e92d9a5aca"></a>bf_reg_t_posted_interrupt_notification_vector&#160;</td><td class="fielddoc"><p >defines the posted_interrupt_notification_vector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7562877f0136cfa3728a5ea45b7ccfe8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7562877f0136cfa3728a5ea45b7ccfe8"></a>bf_reg_t_eptp_index&#160;</td><td class="fielddoc"><p >defines the eptp_index register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a816319856bbde1a24d51f6329eee523f"></a>bf_reg_t_es_selector&#160;</td><td class="fielddoc"><p >defines the guest_es_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a667b4b00f31fcfc8960ed95c1e50ee92"></a>bf_reg_t_cs_selector&#160;</td><td class="fielddoc"><p >defines the guest_cs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a01ff8c2d8e3e89f5a5f39d6edd427a87"></a>bf_reg_t_ss_selector&#160;</td><td class="fielddoc"><p >defines the guest_ss_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2a6360cd7d9a61c4fc54d1ed6f665c06"></a>bf_reg_t_ds_selector&#160;</td><td class="fielddoc"><p >defines the guest_ds_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1d46016dcd4a95f92fb99b67c0f134a2"></a>bf_reg_t_fs_selector&#160;</td><td class="fielddoc"><p >defines the guest_fs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5efdfcfaa3b1f6d8433d53c617a175bf"></a>bf_reg_t_gs_selector&#160;</td><td class="fielddoc"><p >defines the guest_gs_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aeb1ab37e08243d3d27f25e6c1e0354d2"></a>bf_reg_t_ldtr_selector&#160;</td><td class="fielddoc"><p >defines the guest_ldtr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aed41cf893440b09c7d7657d4e4af3ca4"></a>bf_reg_t_tr_selector&#160;</td><td class="fielddoc"><p >defines the guest_tr_selector register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad72c489acff86e4b43c58bb5b2c9c19f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad72c489acff86e4b43c58bb5b2c9c19f"></a>bf_reg_t_interrupt_status&#160;</td><td class="fielddoc"><p >defines the guest_interrupt_status register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a67e16357b1825afa1184f37a660cc877" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a67e16357b1825afa1184f37a660cc877"></a>bf_reg_t_pml_index&#160;</td><td class="fielddoc"><p >defines the pml_index register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab04fa0d4e272efa9d892cdb5fb3260d9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab04fa0d4e272efa9d892cdb5fb3260d9"></a>bf_reg_t_address_of_io_bitmap_a&#160;</td><td class="fielddoc"><p >defines the address_of_io_bitmap_a register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4058487ce76a53c19a93c580047229a2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4058487ce76a53c19a93c580047229a2"></a>bf_reg_t_address_of_io_bitmap_b&#160;</td><td class="fielddoc"><p >defines the address_of_io_bitmap_b register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c9b31b39da68c647528be7252b938a8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c9b31b39da68c647528be7252b938a8"></a>bf_reg_t_address_of_msr_bitmaps&#160;</td><td class="fielddoc"><p >defines the address_of_msr_bitmaps register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6639f6b9cc541e0a91d21c4908bd465b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6639f6b9cc541e0a91d21c4908bd465b"></a>bf_reg_t_vmexit_msr_store_address&#160;</td><td class="fielddoc"><p >defines the vmexit_msr_store_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8fa9bafd16887cd3df30de6203baf2ae" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8fa9bafd16887cd3df30de6203baf2ae"></a>bf_reg_t_vmexit_msr_load_address&#160;</td><td class="fielddoc"><p >defines the vmexit_msr_load_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ade8a5405c910ad767f36d901f8ea3280" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ade8a5405c910ad767f36d901f8ea3280"></a>bf_reg_t_vmentry_msr_load_address&#160;</td><td class="fielddoc"><p >defines the vmentry_msr_load_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3bf1a5071b7759172f1e5502e1b3590d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3bf1a5071b7759172f1e5502e1b3590d"></a>bf_reg_t_executive_vmcs_pointer&#160;</td><td class="fielddoc"><p >defines the executive_vmcs_pointer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a10724f307aa18918e468fbc79bea17e6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a10724f307aa18918e468fbc79bea17e6"></a>bf_reg_t_pml_address&#160;</td><td class="fielddoc"><p >defines the pml_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8c2290df63cb48e348bb74d778585275"></a>bf_reg_t_tsc_offset&#160;</td><td class="fielddoc"><p >defines the tsc_offset register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a63c87771bc870f498a93b8e80e0a93ef" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a63c87771bc870f498a93b8e80e0a93ef"></a>bf_reg_t_virtual_apic_address&#160;</td><td class="fielddoc"><p >defines the virtual_apic_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a966c1b2544188f5d43c179d3def40871" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a966c1b2544188f5d43c179d3def40871"></a>bf_reg_t_apic_access_address&#160;</td><td class="fielddoc"><p >defines the apic_access_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afbfb415d455265bfe83031365d2c5a7c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afbfb415d455265bfe83031365d2c5a7c"></a>bf_reg_t_posted_interrupt_descriptor_address&#160;</td><td class="fielddoc"><p >defines the posted_interrupt_descriptor_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab12c998989de32608b28854d44ae755c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab12c998989de32608b28854d44ae755c"></a>bf_reg_t_vm_function_controls&#160;</td><td class="fielddoc"><p >defines the vm_function_controls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae327819d46c934e0624864733958f4fb" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae327819d46c934e0624864733958f4fb"></a>bf_reg_t_ept_pointer&#160;</td><td class="fielddoc"><p >defines the ept_pointer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7c9db134b2fda34b67400adf6ff2a4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7c9db134b2fda34b67400adf6ff2a4"></a>bf_reg_t_eoi_exit_bitmap0&#160;</td><td class="fielddoc"><p >defines the eoi_exit_bitmap0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e8db285cae84a2142f2c2f0309285ac" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e8db285cae84a2142f2c2f0309285ac"></a>bf_reg_t_eoi_exit_bitmap1&#160;</td><td class="fielddoc"><p >defines the eoi_exit_bitmap1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae86a9e219278b2558a92d312ec7b9c73" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae86a9e219278b2558a92d312ec7b9c73"></a>bf_reg_t_eoi_exit_bitmap2&#160;</td><td class="fielddoc"><p >defines the eoi_exit_bitmap2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a07b5329a7129e074ec7b63d897cfa647" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a07b5329a7129e074ec7b63d897cfa647"></a>bf_reg_t_eoi_exit_bitmap3&#160;</td><td class="fielddoc"><p >defines the eoi_exit_bitmap3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d26e54db9374a1ea6f2310e919ee01f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d26e54db9374a1ea6f2310e919ee01f"></a>bf_reg_t_eptp_list_address&#160;</td><td class="fielddoc"><p >defines the eptp_list_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8faf367a52935d68159b86b65a30ecc1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8faf367a52935d68159b86b65a30ecc1"></a>bf_reg_t_vmread_bitmap_address&#160;</td><td class="fielddoc"><p >defines the vmread_bitmap_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae8235a3cbbc35d3d711aa55278e6579e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae8235a3cbbc35d3d711aa55278e6579e"></a>bf_reg_t_vmwrite_bitmap_address&#160;</td><td class="fielddoc"><p >defines the vmwrite_bitmap_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a03172213b8e9a43fa4402b4b6251f929" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a03172213b8e9a43fa4402b4b6251f929"></a>bf_reg_t_virt_exception_information_address&#160;</td><td class="fielddoc"><p >defines the virt_exception_information_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9af8d9f8a0c4896cbde3f0f0b3b0b30ddf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9af8d9f8a0c4896cbde3f0f0b3b0b30ddf"></a>bf_reg_t_xss_exiting_bitmap&#160;</td><td class="fielddoc"><p >defines the xss_exiting_bitmap register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a64ff356e11f75f7b5deffade8f02a7f3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a64ff356e11f75f7b5deffade8f02a7f3"></a>bf_reg_t_encls_exiting_bitmap&#160;</td><td class="fielddoc"><p >defines the encls_exiting_bitmap register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d69874113d71ac0abecf18aaa2b9e5d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d69874113d71ac0abecf18aaa2b9e5d"></a>bf_reg_t_sub_page_permission_table_pointer&#160;</td><td class="fielddoc"><p >defines the sub_page_permission_table_pointer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a77196c5f659935fae634a24f52df8804" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a77196c5f659935fae634a24f52df8804"></a>bf_reg_t_tsc_multiplier&#160;</td><td class="fielddoc"><p >defines the tsc_multiplier register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a19bf109c88f09256ce9ee9264b0cca49" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a19bf109c88f09256ce9ee9264b0cca49"></a>bf_reg_t_physical_address&#160;</td><td class="fielddoc"><p >defines the guest_physical_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c53c95f1e531b13fc305081b9b0a9c1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c53c95f1e531b13fc305081b9b0a9c1"></a>bf_reg_t_vmcs_link_pointer&#160;</td><td class="fielddoc"><p >defines the vmcs_link_pointer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8f67abd5cfee66d4787d414f9f795165" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8f67abd5cfee66d4787d414f9f795165"></a>bf_reg_t_debugctl&#160;</td><td class="fielddoc"><p >defines the guest_debugctl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aca19e1faa65aa6e3e82a6802201a92f3"></a>bf_reg_t_pat&#160;</td><td class="fielddoc"><p >defines the guest_pat register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee588b0c4bf4ffe00d6bbaeb2fe00877"></a>bf_reg_t_efer&#160;</td><td class="fielddoc"><p >defines the guest_efer register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a194026a8b44306ece714579df44932ed" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a194026a8b44306ece714579df44932ed"></a>bf_reg_t_perf_global_ctrl&#160;</td><td class="fielddoc"><p >defines the guest_perf_global_ctrl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa629195bfa0cf8dbf568ccfbc695f4b7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa629195bfa0cf8dbf568ccfbc695f4b7"></a>bf_reg_t_pdpte0&#160;</td><td class="fielddoc"><p >defines the guest_pdpte0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5069897fe894add51d8d3d3a8da15c57" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5069897fe894add51d8d3d3a8da15c57"></a>bf_reg_t_pdpte1&#160;</td><td class="fielddoc"><p >defines the guest_pdpte1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7240b6fb184dba08764a9f2ccc1b89" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c7240b6fb184dba08764a9f2ccc1b89"></a>bf_reg_t_pdpte2&#160;</td><td class="fielddoc"><p >defines the guest_pdpte2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a48c769218410f03f1af9c581d4259f1d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a48c769218410f03f1af9c581d4259f1d"></a>bf_reg_t_pdpte3&#160;</td><td class="fielddoc"><p >defines the guest_pdpte3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0d78bc979ee1fd49456b39693f81707c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0d78bc979ee1fd49456b39693f81707c"></a>bf_reg_t_bndcfgs&#160;</td><td class="fielddoc"><p >defines the guest_bndcfgs register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac086afef52de3a12706c55de1d207275" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac086afef52de3a12706c55de1d207275"></a>bf_reg_t_rtit_ctl&#160;</td><td class="fielddoc"><p >defines the guest_rtit_ctl register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab955fd5ba8285dd649a1c3cec1285f6d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab955fd5ba8285dd649a1c3cec1285f6d"></a>bf_reg_t_pin_based_vm_execution_ctls&#160;</td><td class="fielddoc"><p >defines the pin_based_vm_execution_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a11301f3f015aae253172a85d976f5829" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a11301f3f015aae253172a85d976f5829"></a>bf_reg_t_primary_proc_based_vm_execution_ctls&#160;</td><td class="fielddoc"><p >defines the primary_proc_based_vm_execution_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a10a249a01e4a8409e44ae97397d23866" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a10a249a01e4a8409e44ae97397d23866"></a>bf_reg_t_exception_bitmap&#160;</td><td class="fielddoc"><p >defines the exception_bitmap register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab02da89523643d3c6fb1b2520772de08" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab02da89523643d3c6fb1b2520772de08"></a>bf_reg_t_page_fault_error_code_mask&#160;</td><td class="fielddoc"><p >defines the page_fault_error_code_mask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abd20bddc030820399d7fb942f0384d6c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abd20bddc030820399d7fb942f0384d6c"></a>bf_reg_t_page_fault_error_code_match&#160;</td><td class="fielddoc"><p >defines the page_fault_error_code_match register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aaa62782cf540d9e5a0b784061e2ce21b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aaa62782cf540d9e5a0b784061e2ce21b"></a>bf_reg_t_cr3_target_count&#160;</td><td class="fielddoc"><p >defines the cr3_target_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4263b9a5148a151548a1bde220cb104b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4263b9a5148a151548a1bde220cb104b"></a>bf_reg_t_vmexit_ctls&#160;</td><td class="fielddoc"><p >defines the vmexit_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3eec7378e3f238cab999ab6b15110d4a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3eec7378e3f238cab999ab6b15110d4a"></a>bf_reg_t_vmexit_msr_store_count&#160;</td><td class="fielddoc"><p >defines the vmexit_msr_store_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a896905954a40faa22ae0585c7619e8b6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a896905954a40faa22ae0585c7619e8b6"></a>bf_reg_t_vmexit_msr_load_count&#160;</td><td class="fielddoc"><p >defines the vmexit_msr_load_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac7ab067ca2e1740ef032db483a86c068" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac7ab067ca2e1740ef032db483a86c068"></a>bf_reg_t_vmentry_ctls&#160;</td><td class="fielddoc"><p >defines the vmentry_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3622da1719bcb20cd0d10d26bfabd795" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3622da1719bcb20cd0d10d26bfabd795"></a>bf_reg_t_vmentry_msr_load_count&#160;</td><td class="fielddoc"><p >defines the vmentry_msr_load_count register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a135680a2db2eb680246c4f4333eda778" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a135680a2db2eb680246c4f4333eda778"></a>bf_reg_t_vmentry_interrupt_information_field&#160;</td><td class="fielddoc"><p >defines the vmentry_interrupt_information_field register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab3f8b4524e5446839d5df83ccc4fa39a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab3f8b4524e5446839d5df83ccc4fa39a"></a>bf_reg_t_vmentry_exception_error_code&#160;</td><td class="fielddoc"><p >defines the vmentry_exception_error_code register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0af3822dff2d01f6eee05009ed2a164" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad0af3822dff2d01f6eee05009ed2a164"></a>bf_reg_t_vmentry_instruction_length&#160;</td><td class="fielddoc"><p >defines the vmentry_instruction_length register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88f56a31b18fbfaec0f76689c223411f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a88f56a31b18fbfaec0f76689c223411f"></a>bf_reg_t_tpr_threshold&#160;</td><td class="fielddoc"><p >defines the tpr_threshold register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae1e0be868bac167644d4897de6a21a20" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae1e0be868bac167644d4897de6a21a20"></a>bf_reg_t_secondary_proc_based_vm_execution_ctls&#160;</td><td class="fielddoc"><p >defines the secondary_proc_based_vm_execution_ctls register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a876dccb0536d91f345dd094482d705f4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a876dccb0536d91f345dd094482d705f4"></a>bf_reg_t_ple_gap&#160;</td><td class="fielddoc"><p >defines the ple_gap register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa36dfb0f98fdba579ffc202e0df323c5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa36dfb0f98fdba579ffc202e0df323c5"></a>bf_reg_t_ple_window&#160;</td><td class="fielddoc"><p >defines the ple_window register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a57de1a34a282f1c1b0740ebecfee98ec" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a57de1a34a282f1c1b0740ebecfee98ec"></a>bf_reg_t_vm_instruction_error&#160;</td><td class="fielddoc"><p >defines the vm_instruction_error register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a91061562226ec47b8bd4571215f4c72f" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a91061562226ec47b8bd4571215f4c72f"></a>bf_reg_t_exit_reason&#160;</td><td class="fielddoc"><p >defines the exit_reason register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e4f1d94e2509e8f53d6c2fcbed60f17" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e4f1d94e2509e8f53d6c2fcbed60f17"></a>bf_reg_t_vmexit_interruption_information&#160;</td><td class="fielddoc"><p >defines the vmexit_interruption_information register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2ef995fa65ef86fdb6e96309fcc3c8a5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2ef995fa65ef86fdb6e96309fcc3c8a5"></a>bf_reg_t_vmexit_interruption_error_code&#160;</td><td class="fielddoc"><p >defines the vmexit_interruption_error_code register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a11a67f6ac06911c3dfe8a10bc80ea461" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a11a67f6ac06911c3dfe8a10bc80ea461"></a>bf_reg_t_idt_vectoring_information_field&#160;</td><td class="fielddoc"><p >defines the idt_vectoring_information_field register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26dbaf904e1edb4074c87d436806805c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a26dbaf904e1edb4074c87d436806805c"></a>bf_reg_t_idt_vectoring_error_code&#160;</td><td class="fielddoc"><p >defines the idt_vectoring_error_code register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c376159d0d70b0b4047b69e03f73727" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9c376159d0d70b0b4047b69e03f73727"></a>bf_reg_t_vmexit_instruction_length&#160;</td><td class="fielddoc"><p >defines the vmexit_instruction_length register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5d23abe220f824162359e9707c1f5eaf" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5d23abe220f824162359e9707c1f5eaf"></a>bf_reg_t_vmexit_instruction_information&#160;</td><td class="fielddoc"><p >defines the vmexit_instruction_information register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a586daf1f46d840c84774e44e75c0578e"></a>bf_reg_t_es_limit&#160;</td><td class="fielddoc"><p >defines the guest_es_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac80c46c35492e5a8fbe2b8ad886c118d"></a>bf_reg_t_cs_limit&#160;</td><td class="fielddoc"><p >defines the guest_cs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3d805e73ee05888d48661e1840148c57"></a>bf_reg_t_ss_limit&#160;</td><td class="fielddoc"><p >defines the guest_ss_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f6046775b9ca3d56a5912b5cf6e7bcc"></a>bf_reg_t_ds_limit&#160;</td><td class="fielddoc"><p >defines the guest_ds_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aad68373a33595e606cf7da9baeac71b4"></a>bf_reg_t_fs_limit&#160;</td><td class="fielddoc"><p >defines the guest_fs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0e6344815c28431b06e4ce937df5e4f6"></a>bf_reg_t_gs_limit&#160;</td><td class="fielddoc"><p >defines the guest_gs_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a562b46c0835a2bea182224f633d92bd1"></a>bf_reg_t_ldtr_limit&#160;</td><td class="fielddoc"><p >defines the guest_ldtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ada68d0a9814e383a1b406fef492488d4"></a>bf_reg_t_tr_limit&#160;</td><td class="fielddoc"><p >defines the guest_tr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a875a1188826314239c126109d1feafe9"></a>bf_reg_t_gdtr_limit&#160;</td><td class="fielddoc"><p >defines the guest_gdtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6ed09d09e24e3f71b7278c32ce6de0e7"></a>bf_reg_t_idtr_limit&#160;</td><td class="fielddoc"><p >defines the guest_idtr_limit register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abdd140d9cdf163514484ebaad1c3b15c"></a>bf_reg_t_es_attrib&#160;</td><td class="fielddoc"><p >defines the guest_es_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1be382680128698d773d806c1959f9e0"></a>bf_reg_t_cs_attrib&#160;</td><td class="fielddoc"><p >defines the guest_cs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a54f942a6b4a44bdda24cfed45414616a"></a>bf_reg_t_ss_attrib&#160;</td><td class="fielddoc"><p >defines the guest_ss_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a00aadedf53befddd99f7fd30226a6840"></a>bf_reg_t_ds_attrib&#160;</td><td class="fielddoc"><p >defines the guest_ds_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac837c7bcfaf8381320a6d3c584fbdf99"></a>bf_reg_t_fs_attrib&#160;</td><td class="fielddoc"><p >defines the guest_fs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a324a0d6ad36593848f5068bb122e0fa9"></a>bf_reg_t_gs_attrib&#160;</td><td class="fielddoc"><p >defines the guest_gs_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab4b1b86e07df4bb523a96e5276429476"></a>bf_reg_t_ldtr_attrib&#160;</td><td class="fielddoc"><p >defines the guest_ldtr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a87cbb05da832e40a755e048e31f657d5"></a>bf_reg_t_tr_attrib&#160;</td><td class="fielddoc"><p >defines the guest_tr_attrib register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0ecff748f6e482bf8b46524615ee0c44" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a0ecff748f6e482bf8b46524615ee0c44"></a>bf_reg_t_interruptibility_state&#160;</td><td class="fielddoc"><p >defines the guest_interruptibility_state register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a190ada235f06637d33f5d2d7a00869f2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a190ada235f06637d33f5d2d7a00869f2"></a>bf_reg_t_activity_state&#160;</td><td class="fielddoc"><p >defines the guest_activity_state register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7de1bd0395025dd7abef30fe70e0d67" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ad7de1bd0395025dd7abef30fe70e0d67"></a>bf_reg_t_smbase&#160;</td><td class="fielddoc"><p >defines the guest_smbase register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3212289f3207f8423dcf22de469c47c0"></a>bf_reg_t_sysenter_cs&#160;</td><td class="fielddoc"><p >defines the guest_sysenter_cs register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a24579f38e622082a14459aa44363ce84" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a24579f38e622082a14459aa44363ce84"></a>bf_reg_t_vmx_preemption_timer_value&#160;</td><td class="fielddoc"><p >defines the vmx_preemption_timer_value register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9af72c2c12ac14130fb76771305da2db42" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9af72c2c12ac14130fb76771305da2db42"></a>bf_reg_t_cr0_guest_host_mask&#160;</td><td class="fielddoc"><p >defines the cr0_guest_host_mask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e72419c9ce8e5096d20a816492d488e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e72419c9ce8e5096d20a816492d488e"></a>bf_reg_t_cr4_guest_host_mask&#160;</td><td class="fielddoc"><p >defines the cr4_guest_host_mask register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee9ea84cbcd2f277f9bde6e3c9a0770c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aee9ea84cbcd2f277f9bde6e3c9a0770c"></a>bf_reg_t_cr0_read_shadow&#160;</td><td class="fielddoc"><p >defines the cr0_read_shadow register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac73f9b8bddbffc31f141741d1d901559" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac73f9b8bddbffc31f141741d1d901559"></a>bf_reg_t_cr4_read_shadow&#160;</td><td class="fielddoc"><p >defines the cr4_read_shadow register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e635957fbb132be4a6dabb6ce86be94" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2e635957fbb132be4a6dabb6ce86be94"></a>bf_reg_t_cr3_target_value0&#160;</td><td class="fielddoc"><p >defines the cr3_target_value0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a59f94320271476fc04523a3aa321f846" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a59f94320271476fc04523a3aa321f846"></a>bf_reg_t_cr3_target_value1&#160;</td><td class="fielddoc"><p >defines the cr3_target_value1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac6bdd033b73352cda1f4401a9a01f1dd" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ac6bdd033b73352cda1f4401a9a01f1dd"></a>bf_reg_t_cr3_target_value2&#160;</td><td class="fielddoc"><p >defines the cr3_target_value2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c85dd5e2641b8627c1ada1f7e96e913" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6c85dd5e2641b8627c1ada1f7e96e913"></a>bf_reg_t_cr3_target_value3&#160;</td><td class="fielddoc"><p >defines the cr3_target_value3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f5d7dd1a0554024507b213c5aaacae2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a3f5d7dd1a0554024507b213c5aaacae2"></a>bf_reg_t_exit_qualification&#160;</td><td class="fielddoc"><p >defines the exit_qualification register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae65fe71a1c71a67d0a45f826cedfcf27" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae65fe71a1c71a67d0a45f826cedfcf27"></a>bf_reg_t_io_rcx&#160;</td><td class="fielddoc"><p >defines the io_rcx register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a4b8d5c31723f05be3eacdfeae654b" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa4a4b8d5c31723f05be3eacdfeae654b"></a>bf_reg_t_io_rsi&#160;</td><td class="fielddoc"><p >defines the io_rsi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9e9092b7e0b5a56e6fb157b7e638c615" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a9e9092b7e0b5a56e6fb157b7e638c615"></a>bf_reg_t_io_rdi&#160;</td><td class="fielddoc"><p >defines the io_rdi register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f2f9731ad0cf8a8a4d01b0d59ab951a" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5f2f9731ad0cf8a8a4d01b0d59ab951a"></a>bf_reg_t_io_rip&#160;</td><td class="fielddoc"><p >defines the io_rip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2aa41076fe5d64027ffb7fc35691755d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2aa41076fe5d64027ffb7fc35691755d"></a>bf_reg_t_linear_address&#160;</td><td class="fielddoc"><p >defines the guest_linear_address register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4a71b324da4b7b4253e8057c05b4a1c1"></a>bf_reg_t_cr0&#160;</td><td class="fielddoc"><p >defines the guest_cr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ae23661a12b4a030e06732de48258500c"></a>bf_reg_t_cr3&#160;</td><td class="fielddoc"><p >defines the guest_cr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9aa89ec2d62d52c4478b486522755ab4b1"></a>bf_reg_t_cr4&#160;</td><td class="fielddoc"><p >defines the guest_cr4 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a2d9d225a44625cf1a89821cdc3c8fcc8"></a>bf_reg_t_es_base&#160;</td><td class="fielddoc"><p >defines the guest_es_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a90241b5b6f37e028f6b99b70e1148cf0"></a>bf_reg_t_cs_base&#160;</td><td class="fielddoc"><p >defines the guest_cs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8667f4324f64037d4fe90f7d943cc08d"></a>bf_reg_t_ss_base&#160;</td><td class="fielddoc"><p >defines the guest_ss_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acde737f6b12cde85e91ee22c370248bd"></a>bf_reg_t_ds_base&#160;</td><td class="fielddoc"><p >defines the guest_ds_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a61eaedfa0b3c1bfec2f0bc3cd8d8bb0e"></a>bf_reg_t_fs_base&#160;</td><td class="fielddoc"><p >defines the guest_fs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5c44a47aeb6bd00057fea81967cfaca8"></a>bf_reg_t_gs_base&#160;</td><td class="fielddoc"><p >defines the guest_gs_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a68773efb765ed653ec469958166d9f69"></a>bf_reg_t_ldtr_base&#160;</td><td class="fielddoc"><p >defines the guest_ldtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a123ad014a67e75af1fee3d0a47b76b86"></a>bf_reg_t_tr_base&#160;</td><td class="fielddoc"><p >defines the guest_tr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a33355dd7e73aedfcaf78c0514d378bee"></a>bf_reg_t_gdtr_base&#160;</td><td class="fielddoc"><p >defines the guest_gdtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1e923cbd99fd3c2ac74a3814b2d9bed0"></a>bf_reg_t_idtr_base&#160;</td><td class="fielddoc"><p >defines the guest_idtr_base register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a8d7ff7f9e0e53fe14b5854885b7a5c99"></a>bf_reg_t_dr7&#160;</td><td class="fielddoc"><p >defines the guest_dr7 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9acaa4653b18c18053b60a9086420452a0"></a>bf_reg_t_rsp&#160;</td><td class="fielddoc"><p >defines the guest_rsp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a6cb0c96692ee98524c11337e50ad2355"></a>bf_reg_t_rip&#160;</td><td class="fielddoc"><p >defines the guest_rip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a44bd9185b8f892f769d694062b4b64f9"></a>bf_reg_t_rflags&#160;</td><td class="fielddoc"><p >defines the guest_rflags register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9add6e5a94ed55a7010d5df32eba2ed22e" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9add6e5a94ed55a7010d5df32eba2ed22e"></a>bf_reg_t_pending_debug_exceptions&#160;</td><td class="fielddoc"><p >defines the guest_pending_debug_exceptions register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab1a7bfa2de2036351a6d67f0fb0703b2"></a>bf_reg_t_sysenter_esp&#160;</td><td class="fielddoc"><p >defines the guest_sysenter_esp register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9abbb35e2a5775d13e0033df7edfb942f1"></a>bf_reg_t_sysenter_eip&#160;</td><td class="fielddoc"><p >defines the guest_sysenter_eip register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a1cb8907360296e4318f7449b4a58c26c"></a>bf_reg_t_cr8&#160;</td><td class="fielddoc"><p >defines the cr8 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9ab8432945925c5b0cfaaf8cf27bb50c20"></a>bf_reg_t_dr0&#160;</td><td class="fielddoc"><p >defines the dr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a7c3882a8c1c720609f3d74bffda3b56d"></a>bf_reg_t_dr1&#160;</td><td class="fielddoc"><p >defines the dr1 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9adfc26c91d4a10c9ea0a21a0b30472244"></a>bf_reg_t_dr2&#160;</td><td class="fielddoc"><p >defines the dr2 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9afdbf0b842ee96c09181b304f0d35e21d"></a>bf_reg_t_dr3&#160;</td><td class="fielddoc"><p >defines the dr3 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a5898320bd3168beadc4d00dbe46a75fc"></a>bf_reg_t_xcr0&#160;</td><td class="fielddoc"><p >defines the xcr0 register </p>
</td></tr>
<tr><td class="fieldname"><a id="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7" name="a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7"></a>bf_reg_t_invalid&#160;</td><td class="fielddoc"><p >defines an invalid bf_reg_t </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a707f2093b716a114cb8b90618ceffaff" name="a707f2093b716a114cb8b90618ceffaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707f2093b716a114cb8b90618ceffaff">&#9670;&nbsp;</a></span>bootstrap_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bootstrap_entry </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16::value_type const&#160;</td>
          <td class="paramname"><em>ppid0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bootstrap entry function. This function is called on each PP while the hypervisor is being bootstrapped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppid0</td><td>the physical process to bootstrap </td></tr>
  </table>
  </dd>
</dl>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >TODO:</p><ul>
<li>We need to have a whitelist of MSRs that an extension is allowed to actually read and limit it to that whitelist.</li>
</ul>
<p >TODO:</p><ul>
<li>We need to have a whitelist of MSRs that an extension is allowed to actually read and limit it to that whitelist.</li>
</ul>
<p >TODO:</p><ul>
<li>Need to add a check for a phys mapped to HYPERVISOR_MK_STACK_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_MK_CODE_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_MK_PAGE_POOL_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_MK_HUGE_POOL_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_DIRECT_MAP_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_STACK_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_FAIL_STACK_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_CODE_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_TLS_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_PAGE_POOL_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_HUGE_POOL_ADDR</li>
</ul>
<p >The best way to handle these is that once we have a single physically contiguous buffer from UEFI to map everything, we can simply check to see if this phys is in that buffer which is not too bad since these values can be a CMake variable. See the Security.md for more details.</p>
<p >NOTE:</p><ul>
<li>The kernel uses set_active to implement all of the run ABIs. The only difference with run is that it executes return_to_mk which makes it really difficult to integration test (not impossible, but a very small ROI for sure).</li>
<li>For this reason, please see the set_active integration test as this is able to test a much larger number of situations, all of which apply to all of the run ABIs as well.</li>
</ul>
<p >NOTE:</p><ul>
<li>The kernel uses set_active to implement all of the run ABIs. The only difference with run is that it executes return_to_mk which makes it really difficult to integration test (not impossible, but a very small ROI for sure).</li>
<li>For this reason, please see the set_active integration test as this is able to test a much larger number of situations, all of which apply to all of the run ABIs as well.</li>
</ul>
<p >This is tested by the example code, so no need to do it here as it would take a lot of code to implement, and since it is already done somewhere else, no need to do it twice.</p>
<p >NOTE:</p><ul>
<li>The kernel uses set_active to implement all of the run ABIs. The only difference with run is that it executes return_to_mk which makes it really difficult to integration test (not impossible, but a very small ROI for sure).</li>
<li>For this reason, please see the set_active integration test as this is able to test a much larger number of situations, all of which apply to all of the run ABIs as well.</li>
</ul>
<p >NOTE:</p><ul>
<li>The kernel uses set_active to implement all of the run ABIs. The only difference with run is that it executes return_to_mk which makes it really difficult to integration test (not impossible, but a very small ROI for sure).</li>
<li>For this reason, please see the set_active integration test as this is able to test a much larger number of situations, all of which apply to all of the run ABIs as well.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >TODO:</p><ul>
<li>We need to have a whitelist of MSRs that an extension is allowed to actually read and limit it to that whitelist.</li>
</ul>
<p >TODO:</p><ul>
<li>We need to have a whitelist of MSRs that an extension is allowed to actually read and limit it to that whitelist.</li>
</ul>
<p >TODO:</p><ul>
<li>Need to add a check for a phys mapped to HYPERVISOR_MK_STACK_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_MK_CODE_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_MK_PAGE_POOL_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_MK_HUGE_POOL_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_DIRECT_MAP_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_STACK_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_FAIL_STACK_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_CODE_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_TLS_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_PAGE_POOL_ADDR</li>
<li>Need to add a check for a phys mapped to HYPERVISOR_EXT_HUGE_POOL_ADDR</li>
</ul>
<p >The best way to handle these is that once we have a single physically contiguous buffer from UEFI to map everything, we can simply check to see if this phys is in that buffer which is not too bad since these values can be a CMake variable. See the Security.md for more details.</p>
<p >NOTE:</p><ul>
<li>The kernel uses set_active to implement all of the run ABIs. The only difference with run is that it executes return_to_mk which makes it really difficult to integration test (not impossible, but a very small ROI for sure).</li>
<li>For this reason, please see the set_active integration test as this is able to test a much larger number of situations, all of which apply to all of the run ABIs as well.</li>
</ul>
<p >NOTE:</p><ul>
<li>The kernel uses set_active to implement all of the run ABIs. The only difference with run is that it executes return_to_mk which makes it really difficult to integration test (not impossible, but a very small ROI for sure).</li>
<li>For this reason, please see the set_active integration test as this is able to test a much larger number of situations, all of which apply to all of the run ABIs as well.</li>
</ul>
<p >This is tested by the example code, so no need to do it here as it would take a lot of code to implement, and since it is already done somewhere else, no need to do it twice.</p>
<p >NOTE:</p><ul>
<li>The kernel uses set_active to implement all of the run ABIs. The only difference with run is that it executes return_to_mk which makes it really difficult to integration test (not impossible, but a very small ROI for sure).</li>
<li>For this reason, please see the set_active integration test as this is able to test a much larger number of situations, all of which apply to all of the run ABIs as well.</li>
</ul>
<p >NOTE:</p><ul>
<li>The kernel uses set_active to implement all of the run ABIs. The only difference with run is that it executes return_to_mk which makes it really difficult to integration test (not impossible, but a very small ROI for sure).</li>
<li>For this reason, please see the set_active integration test as this is able to test a much larger number of situations, all of which apply to all of the run ABIs as well.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the bootstrap handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The bootstrap handler should always call one of the "run" ABIs to return back to the microkernel when a bootstrap is finished. If this is called, it is because the bootstrap handler returned with an error.</li>
</ul>

</div>
</div>
<a id="a46c15871007d0563a77b217d88c420b6" name="a46c15871007d0563a77b217d88c420b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c15871007d0563a77b217d88c420b6">&#9670;&nbsp;</a></span>fail_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::fail_entry </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64::value_type const&#160;</td>
          <td class="paramname"><em>errc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64::value_type const&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the fast fail entry function. This is registered by the main function to execute whenever a fast fail occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errc</td><td>the reason for the failure, which is CPU specific. On x86, this is a combination of the exception vector and error code. </td></tr>
    <tr><td class="paramname">addr</td><td>contains a faulting address if the fail reason is associated with an error that involves a faulting address ( for example like a page fault). Otherwise, the value of this input is undefined. </td></tr>
  </table>
  </dd>
</dl>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the fast fail handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The fast fail handler should always call one of the "run" ABIs to return back to the microkernel when a fast fail is finished. If this is called, it is because the fast fail handler returned with an error.</li>
</ul>

</div>
</div>
<a id="ac3a093cf4e16e3e438b1154d0b52522d" name="ac3a093cf4e16e3e438b1154d0b52522d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a093cf4e16e3e438b1154d0b52522d">&#9670;&nbsp;</a></span>vmexit_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::vmexit_entry </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16::value_type const&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64::value_type const&#160;</td>
          <td class="paramname"><em>exit_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the VMExit entry function. This is registered by the main function to execute whenever a VMExit occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>the ID of the VS that generated the VMExit </td></tr>
    <tr><td class="paramname">exit_reason</td><td>the exit reason associated with the VMExit </td></tr>
  </table>
  </dd>
</dl>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>
<p >NOTE:</p><ul>
<li>Call into the vmexit handler. This entry point serves as a trampoline between C and C++. Specifically, the microkernel cannot call a member function directly, and can only call a C style function.</li>
</ul>
<p >NOTE:</p><ul>
<li>This code should never be reached. The VMExit handler should always call one of the "run" ABIs to return back to the microkernel when a VMExit is finished. If this is called, it is because the VMExit handler returned with an error.</li>
</ul>

</div>
</div>
<a id="a03f2f3d774b6a9ba0c8aa9d716c673a7" name="a03f2f3d774b6a9ba0c8aa9d716c673a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f2f3d774b6a9ba0c8aa9d716c673a7">&#9670;&nbsp;</a></span>ext_main_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::ext_main_entry </td>
          <td>(</td>
          <td class="paramtype">bsl::uint32 const&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the main entry function for this example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>the version of the spec implemented by the microkernel. This can be used to ensure the extension and the microkernel speak the same ABI. </td></tr>
  </table>
  </dd>
</dl>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a>. This will validate the ABI version, open a handle to the microkernel and register the required callbacks. If this fails, we call bf_control_op_exit, which is similar to exit() from POSIX, except that the return value is always the same.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vp__t.html" title="Defines the extension&#39;s notion of a VP.">vp_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Initialize the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a>. This will give all of our <a class="el" href="classsyscall_1_1vs__t.html" title="Defines the extension&#39;s notion of a VS.">vs_t</a>'s their IDs so that they can be allocated.</li>
</ul>
<p >NOTE:</p><ul>
<li>Wait for callbacks. Note that this function does not return. The next time the extension is executed, it will be the bootstrap callback that was just previously registered, which will be called on each PP that is online. Failure to call this function leads to undefined behaviour (likely a page fault).</li>
<li>This is similar to the wait() function from POSIX after having just started some processes, with the difference being that this will never return, so there is no need to pass in status as there is nothing to process after this call.</li>
</ul>

</div>
</div>
<a id="a7e408c172d4f703f7dc76f85bf2f760c" name="a7e408c172d4f703f7dc76f85bf2f760c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e408c172d4f703f7dc76f85bf2f760c">&#9670;&nbsp;</a></span>dispatch_bootstrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::dispatch_bootstrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bootstrap process as needed. Note that the bootstrap callback is only called when starting the hypervisor on root VPs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">mut_tls</td><td>the <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> to use </td></tr>
    <tr><td class="paramname">mut_sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">ppid</td><td>the ID of the PP to bootstrap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>
<p >NOTE:</p><ul>
<li>In order to execcute bf_vs_op_run, which is what executes the hypervisor, we must have a VM, VP and VS.</li>
<li>The root VM is already created for us, so we don't need to create this ourselves. You only need to create VM's if you plan to add guest support with your extensions.</li>
</ul>
<p >NOTE:</p><ul>
<li>The VP in this simple example does nothing, but we still need to create one. The VP is used when you have more than one VS per VP (e.g., if you are implementing HyperV's VSM, or nested virtualization support). Otherwise, you will always have one VS for each VP, and they will appear as the same thing.</li>
<li>The VS is what stores the state associated with the VS. It is the thing that does most of the work, including storing the VMCS/VMCB and other CPU register state that is needed.</li>
</ul>
<p >NOTE:</p><ul>
<li>Run the newly created VP on behalf of the root VM using the newly created and initialized VS. Note that this version of the run function should only be used when starting the hypervisor, or switching the VM, VP or VS as it is slow.</li>
</ul>

</div>
</div>
<a id="a777d105758a8fbd2486be5e1db2e92e6" name="a777d105758a8fbd2486be5e1db2e92e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777d105758a8fbd2486be5e1db2e92e6">&#9670;&nbsp;</a></span>dispatch_fail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::dispatch_fail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">syscall::bf_syscall_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>errc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the fail as needed, or returns an error so that the microkernel can halt the PP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">tls</td><td>the <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> to use </td></tr>
    <tr><td class="paramname">sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">errc</td><td>the reason for the failure, which is CPU specific. On x86, this is a combination of the exception vector and error code. </td></tr>
    <tr><td class="paramname">addr</td><td>contains a faulting address if the fail reason is associated with an error that involves a faulting address ( for example like a page fault). Otherwise, the value of this input is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>
<p >NOTE:</p><ul>
<li>Tells the microkernel that we didn't handle the fast fail. When this occurs, the microkernel will halt this PP. In most cases, there are only two options for how to handle a fail:<ul>
<li>Do the following, and report an error and halt.</li>
<li>Return to a parent VS and continue execution from there, which is typically only possible if you are implementing more than one VP/VS per PP (e.g., when implementing guest support, VSM support or nested virtualization support).</li>
</ul>
</li>
<li>Another use case is integration testing. We can also use this to generate faults that we can recover from to ensure the fault system works properly during testing.</li>
</ul>

</div>
</div>
<a id="a9c601348fb90b5eacaaf5da37c2b6291" name="a9c601348fb90b5eacaaf5da37c2b6291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c601348fb90b5eacaaf5da37c2b6291">&#9670;&nbsp;</a></span>dispatch_vmexit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::dispatch_vmexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>exit_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the VMExit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">tls</td><td>the <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> to use </td></tr>
    <tr><td class="paramname">mut_sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS that generated the VMExit </td></tr>
    <tr><td class="paramname">exit_reason</td><td>the exit reason associated with the VMExit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a4a4d1a825e37273b8a383684cb0520a0" name="a4a4d1a825e37273b8a383684cb0520a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4d1a825e37273b8a383684cb0520a0">&#9670;&nbsp;</a></span>gs_initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::gs_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the Global Storage (GS). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="abd7473dc81e4f78dd0e0816b5742ac34" name="abd7473dc81e4f78dd0e0816b5742ac34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7473dc81e4f78dd0e0816b5742ac34">&#9670;&nbsp;</a></span>tls_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::tls_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the Thread Local Storage (TLS). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> to use </td></tr>
    <tr><td class="paramname">sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a313bb4626c4abdf92e7269d9529c6065" name="a313bb4626c4abdf92e7269d9529c6065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313bb4626c4abdf92e7269d9529c6065">&#9670;&nbsp;</a></span>dispatch_vmexit_cpuid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::dispatch_vmexit_cpuid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the CPUID VMexit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">tls</td><td>the <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> to use </td></tr>
    <tr><td class="paramname">mut_sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS that generated the VMExit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>
<p >NOTE:</p><ul>
<li>Before we execute CPUID, we need to check to see if we have received a CPUID command. If we have, we need to handle this CPUID differently. These are defined in the loader.</li>
</ul>
<p >NOTE:</p><ul>
<li>If this is the first PP to stop (which is the last PP in the list as we stop in reverse order), print out how much memory was used by the hypervisor. This is optional of course.</li>
</ul>
<p >NOTE:</p><ul>
<li>The following is another optional debug feature that will show a log of the most recent VMExits that have occurred.</li>
</ul>
<p >NOTE:</p><ul>
<li>Report that the root OS is no longer in a VM for this specific PP. Note that you can do whatever you want here, this is just the default behavior. To report success on promotion after promotion takes place would require that the loader reports success, which we do not do as we are not sure what the extension wants, so the message here should state that we are "about to", and not that it is "done", because it might fail.</li>
</ul>
<p >NOTE:</p><ul>
<li>The promote ABI will load the microkernel by replacing the CPU's state withthe VP state associated with the provided VSID. If all goes well, bf_vs_op_promote will not return, and the system will continue executing with the hypervisor turned off.</li>
</ul>
<p >NOTE:</p><ul>
<li>Report that the root OS is now in a VM for this specific PP.</li>
</ul>
<p >NOTE:</p><ul>
<li>There is nothing to do here as we report off right before promotion takes place.</li>
</ul>

</div>
</div>
<a id="a9c601348fb90b5eacaaf5da37c2b6291" name="a9c601348fb90b5eacaaf5da37c2b6291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c601348fb90b5eacaaf5da37c2b6291">&#9670;&nbsp;</a></span>dispatch_vmexit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::dispatch_vmexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>exit_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the VMExit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">tls</td><td>the <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> to use </td></tr>
    <tr><td class="paramname">mut_sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classsyscall_1_1vp__pool__t.html" title="Defines the extension&#39;s VP pool.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classsyscall_1_1vs__pool__t.html" title="Defines the extension&#39;s VS pool.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS that generated the VMExit </td></tr>
    <tr><td class="paramname">exit_reason</td><td>the exit reason associated with the VMExit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="a9f3598f22234decde7b6f75f2e9bc4cb" name="a9f3598f22234decde7b6f75f2e9bc4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3598f22234decde7b6f75f2e9bc4cb">&#9670;&nbsp;</a></span>dispatch_vmexit_nmi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::dispatch_vmexit_nmi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle NMIs. This is required by Intel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">tls</td><td>the <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> to use </td></tr>
    <tr><td class="paramname">mut_sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS that generated the VMExit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>
<p >NOTE:</p><ul>
<li>If we caught an NMI, we need to inject it into the VM. To do this, all we do is enable the NMI window, which will tell us when we can safely inject the NMI.</li>
<li>Note that the microkernel will do the same thing. If an NMI fires while the hypevisor is running, it will enable the NMI window, which the extension will see as a VMExit, and must from there, inject the NMI into the appropriate VS.</li>
</ul>

</div>
</div>
<a id="aceef7b9d56cda14fa44cf8328fabe6b6" name="aceef7b9d56cda14fa44cf8328fabe6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceef7b9d56cda14fa44cf8328fabe6b6">&#9670;&nbsp;</a></span>dispatch_vmexit_nmi_window()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::dispatch_vmexit_nmi_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle NMIs Windows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">tls</td><td>the <a class="el" href="structsyscall_1_1tls__t.html" title="Defines the extension&#39;s Thread Local Storage (TLS). Extensions can use this to store data specific to...">tls_t</a> to use </td></tr>
    <tr><td class="paramname">mut_sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS that generated the VMExit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>
<p >NOTE:</p><ul>
<li>If we see this exit, it is because an NMI fired. There are two situations where this could occur, either while the hypervisor is running, or the VS is running. In either case, we need to clear the NMI window and inject the NMI into the appropriate VS so that it can be handled. Note that Intel requires that we handle NMIs, and they actually happen a lot with Linux based on what hardware you are using (e.g., a laptop).</li>
</ul>
<p >NOTE:</p><ul>
<li>Inject an NMI. If the NMI window was enabled, it is because we need to inject a NMI. Note that the NMI window can be enabled both by this extension, as well as by the microkernel itself, so we are required to implement it on Intel.</li>
</ul>

</div>
</div>
<a id="a6b221af3c62ca2c8a5d1ff45aa7b9915" name="a6b221af3c62ca2c8a5d1ff45aa7b9915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b221af3c62ca2c8a5d1ff45aa7b9915">&#9670;&nbsp;</a></span>gs_initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::gs_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyscall_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the Global Storage (GS). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_gs</td><td>the <a class="el" href="structsyscall_1_1gs__t.html" title="Defines the extension&#39;s Global Storage (GS). Extensions can use this to store global variables as nee...">gs_t</a> to use </td></tr>
    <tr><td class="paramname">mut_sys</td><td>the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classsyscall_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure and friends otherwise </dd></dl>

</div>
</div>
<a id="aa27da9bf1217e3a1dfc8fba7ed688249" name="aa27da9bf1217e3a1dfc8fba7ed688249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27da9bf1217e3a1dfc8fba7ed688249">&#9670;&nbsp;</a></span>ctls_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::ctls_mask </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; bsl::safe_u64
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the masked version of the VMCS control fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value of the control fields read from the MSRs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The masked version of the control fields. </dd></dl>

</div>
</div>
<a id="af3d809420c90180c9ed61fcaf2671272" name="af3d809420c90180c9ed61fcaf2671272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d809420c90180c9ed61fcaf2671272">&#9670;&nbsp;</a></span>intrinsic_cpuid_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::intrinsic_cpuid_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyscall_1_1gs__t.html">gs_t</a> const *const&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_rax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_rbx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_rcx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_rdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the CPUID instruction given the provided EAX and ECX and returns the results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gs</td><td>ignored </td></tr>
    <tr><td class="paramname">pmut_rax</td><td>the index used by CPUID, returns resulting rax </td></tr>
    <tr><td class="paramname">pmut_rbx</td><td>returns resulting rbx </td></tr>
    <tr><td class="paramname">pmut_rcx</td><td>the subindex used by CPUID, returns the resulting rcx </td></tr>
    <tr><td class="paramname">pmut_rdx</td><td>returns resulting rdx </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d1429c7888cde3b43234ce79bcafab3" name="a5d1429c7888cde3b43234ce79bcafab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1429c7888cde3b43234ce79bcafab3">&#9670;&nbsp;</a></span>bf_debug_op_write_c_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_debug_op_write_c_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::char_type const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_debug_op_write_c. </p>
<p >NOTE:</p><ul>
<li>We provide these prototypes ourselves instead of including the header files because the debugging portion of the runtime for both the microkernel, and for extensions provides the foundation for everything, including asserts. These are needed to implement even the basics for safe integrals, so you end up with circular dependencies.</li>
<li>The impl prototypes also do not bring these headers in, but the mocks do, because they really need to provide the mocked version of this code, and having access to more of the BSL helps with that, so providing the prototypes here ensures that there are no issues no matter what happens.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a</td></tr>
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae56b557d471fdec839ee3db8a832d1d8" name="ae56b557d471fdec839ee3db8a832d1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56b557d471fdec839ee3db8a832d1d8">&#9670;&nbsp;</a></span>bf_debug_op_write_str_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_debug_op_write_str_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::char_type const *const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uintmx const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_debug_op_write_str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8902b1641cfb10c26b0dd3cca709fbf2" name="a8902b1641cfb10c26b0dd3cca709fbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8902b1641cfb10c26b0dd3cca709fbf2">&#9670;&nbsp;</a></span>bf_is_page_aligned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_is_page_aligned </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided address is 4k page aligned, returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the address to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided address is 4k page aligned, returns false otherwise. </dd></dl>

</div>
</div>
<a id="acce4996d13c91cbe1d4ff513825259d0" name="acce4996d13c91cbe1d4ff513825259d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce4996d13c91cbe1d4ff513825259d0">&#9670;&nbsp;</a></span>bf_page_aligned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto syscall::bf_page_aligned </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> -&gt; bsl::safe_umx
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the page aligned version of the addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the address to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the page aligned version of the addr </dd></dl>

</div>
</div>
<a id="aef10bcd3b4c711f61158b99f87cb9767" name="aef10bcd3b4c711f61158b99f87cb9767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef10bcd3b4c711f61158b99f87cb9767">&#9670;&nbsp;</a></span>bf_syscall_sig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_sig </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const &amp;&#160;</td>
          <td class="paramname"><em>rax</em></td><td>)</td>
          <td> -&gt; bsl::safe_u64
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>n/a </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rax</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aa5dfae2295a25b28b9f857edd09559a6" name="aa5dfae2295a25b28b9f857edd09559a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dfae2295a25b28b9f857edd09559a6">&#9670;&nbsp;</a></span>bf_syscall_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_flags </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const &amp;&#160;</td>
          <td class="paramname"><em>rax</em></td><td>)</td>
          <td> -&gt; bsl::safe_u64
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>n/a </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rax</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a3fe2ca295edfa1eb15f67d759a29773a" name="a3fe2ca295edfa1eb15f67d759a29773a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe2ca295edfa1eb15f67d759a29773a">&#9670;&nbsp;</a></span>bf_syscall_opcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_opcode </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const &amp;&#160;</td>
          <td class="paramname"><em>rax</em></td><td>)</td>
          <td> -&gt; bsl::safe_u64
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>n/a </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rax</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a1e8f4c9caf8c2e1af3ee5bc575a6bc24" name="a1e8f4c9caf8c2e1af3ee5bc575a6bc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8f4c9caf8c2e1af3ee5bc575a6bc24">&#9670;&nbsp;</a></span>bf_syscall_opcode_nosig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_opcode_nosig </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const &amp;&#160;</td>
          <td class="paramname"><em>rax</em></td><td>)</td>
          <td> -&gt; bsl::safe_u64
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>n/a </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rax</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a9199d36f01cc32ec37529db2bd3d6132" name="a9199d36f01cc32ec37529db2bd3d6132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9199d36f01cc32ec37529db2bd3d6132">&#9670;&nbsp;</a></span>bf_syscall_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_syscall_index </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const &amp;&#160;</td>
          <td class="paramname"><em>rax</em></td><td>)</td>
          <td> -&gt; bsl::safe_u64
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>n/a </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rax</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ad9de2ccc5b2057fc2349dd625382cc23" name="ad9de2ccc5b2057fc2349dd625382cc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9de2ccc5b2057fc2349dd625382cc23">&#9670;&nbsp;</a></span>bf_is_spec1_supported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::bf_is_spec1_supported </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u32 const &amp;&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>n/a </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a19f95b5fa9595f5ebf41e72467062d77" name="a19f95b5fa9595f5ebf41e72467062d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f95b5fa9595f5ebf41e72467062d77">&#9670;&nbsp;</a></span>bf_debug_op_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_debug_op_out </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to output reg0 and reg1 to the console device the microkernel is currently using for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>The first value to output to the microkernel's console </td></tr>
    <tr><td class="paramname">val2</td><td>The second value to output to the microkernel's console </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb54c9251cd14af0ac10afeaa01901fe" name="abb54c9251cd14af0ac10afeaa01901fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb54c9251cd14af0ac10afeaa01901fe">&#9670;&nbsp;</a></span>bf_debug_op_dump_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_debug_op_dump_vm </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to output the state of a VM to the console device the microkernel is currently using for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmid</td><td>The ID of the VM whose state is to be outputted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c27c77909a2ee1319b45ddea97d7f9e" name="a9c27c77909a2ee1319b45ddea97d7f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c27c77909a2ee1319b45ddea97d7f9e">&#9670;&nbsp;</a></span>bf_debug_op_dump_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_debug_op_dump_vp </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to output the state of a VP to the console device the microkernel is currently using for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpid</td><td>The ID of the VP whose state is to be outputted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94d3d55db4fea5d801d6cc57b35d0087" name="a94d3d55db4fea5d801d6cc57b35d0087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d3d55db4fea5d801d6cc57b35d0087">&#9670;&nbsp;</a></span>bf_debug_op_dump_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_debug_op_dump_vs </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to output the state of a VS to the console device the microkernel is currently using for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsid</td><td>The ID of the VS whose state is to be outputted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e89a633c35b09d0369622260e52556d" name="a6e89a633c35b09d0369622260e52556d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89a633c35b09d0369622260e52556d">&#9670;&nbsp;</a></span>bf_debug_op_dump_vmexit_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_debug_op_dump_vmexit_log </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>ppid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to output the VMExit log. The VMExit log is a chronological log of the "X" number of exits that have occurred on a specific physical processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppid</td><td>The PPID of the PP to dump the log from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3f7b9589e3252f5451dcfed41ec5409" name="ab3f7b9589e3252f5451dcfed41ec5409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f7b9589e3252f5451dcfed41ec5409">&#9670;&nbsp;</a></span>bf_debug_op_write_c()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_debug_op_write_c </td>
          <td>(</td>
          <td class="paramtype">bsl::char_type const&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to output a provided character to the microkernel's console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7921e6139c4ce39571d78c373d9efa8f" name="a7921e6139c4ce39571d78c373d9efa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7921e6139c4ce39571d78c373d9efa8f">&#9670;&nbsp;</a></span>bf_debug_op_write_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_debug_op_write_str </td>
          <td>(</td>
          <td class="paramtype">bsl::cstr_type const&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uintmx const&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to output a provided string to the microkernel's console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The virtual address of a null terminated string to output </td></tr>
    <tr><td class="paramname">len</td><td>the total number of bytes to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabd0a56efd39f21d4303b96876833b8f" name="aabd0a56efd39f21d4303b96876833b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd0a56efd39f21d4303b96876833b8f">&#9670;&nbsp;</a></span>bf_debug_op_dump_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void syscall::bf_debug_op_dump_ext </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>extid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This syscall tells the microkernel to output an extension's state to the console device the microkernel is currently using for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extid</td><td>The EXTID of the extensions's state to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2c5cbf03e54b1f1cdfb321a3491bf6e" name="ab2c5cbf03e54b1f1cdfb321a3491bf6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c5cbf03e54b1f1cdfb321a3491bf6e">&#9670;&nbsp;</a></span>bf_tls_rax_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_rax_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_rax. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ad25caa49fe12448c113fb881a26cad8c" name="ad25caa49fe12448c113fb881a26cad8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25caa49fe12448c113fb881a26cad8c">&#9670;&nbsp;</a></span>bf_tls_set_rax_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_rax_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_rax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a353692e40a5527d244be7b719df23d28" name="a353692e40a5527d244be7b719df23d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353692e40a5527d244be7b719df23d28">&#9670;&nbsp;</a></span>bf_tls_rbx_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_rbx_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_rbx. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a089a641e2b3c92178e648c8c36189d67" name="a089a641e2b3c92178e648c8c36189d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089a641e2b3c92178e648c8c36189d67">&#9670;&nbsp;</a></span>bf_tls_set_rbx_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_rbx_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_rbx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ff4446081d794c983a8ffff1505c1ad" name="a6ff4446081d794c983a8ffff1505c1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff4446081d794c983a8ffff1505c1ad">&#9670;&nbsp;</a></span>bf_tls_rcx_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_rcx_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_rcx. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aaab3fe34be47ef7acb606900ca2dd96f" name="aaab3fe34be47ef7acb606900ca2dd96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab3fe34be47ef7acb606900ca2dd96f">&#9670;&nbsp;</a></span>bf_tls_set_rcx_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_rcx_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_rcx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a7f9ab2dc2d815651e5cc03cecd543c" name="a3a7f9ab2dc2d815651e5cc03cecd543c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7f9ab2dc2d815651e5cc03cecd543c">&#9670;&nbsp;</a></span>bf_tls_rdx_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_rdx_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_rdx. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a28d2b1acf7e3c1204c749eb51ab25bf1" name="a28d2b1acf7e3c1204c749eb51ab25bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d2b1acf7e3c1204c749eb51ab25bf1">&#9670;&nbsp;</a></span>bf_tls_set_rdx_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_rdx_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_rdx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b66063b3797a733270bb602e0455d6c" name="a5b66063b3797a733270bb602e0455d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b66063b3797a733270bb602e0455d6c">&#9670;&nbsp;</a></span>bf_tls_rbp_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_rbp_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_rbp. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a08a1a235ab778ca775160aa43dbb369e" name="a08a1a235ab778ca775160aa43dbb369e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a1a235ab778ca775160aa43dbb369e">&#9670;&nbsp;</a></span>bf_tls_set_rbp_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_rbp_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_rbp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4a0a3a7352c1ace47f684786c65ecea" name="af4a0a3a7352c1ace47f684786c65ecea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a0a3a7352c1ace47f684786c65ecea">&#9670;&nbsp;</a></span>bf_tls_rsi_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_rsi_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_rsi. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a1ee15d7f07ab09fa77e769e8b2ba89c4" name="a1ee15d7f07ab09fa77e769e8b2ba89c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee15d7f07ab09fa77e769e8b2ba89c4">&#9670;&nbsp;</a></span>bf_tls_set_rsi_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_rsi_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_rsi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae46595d057d7f94eabb75a28199c3128" name="ae46595d057d7f94eabb75a28199c3128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46595d057d7f94eabb75a28199c3128">&#9670;&nbsp;</a></span>bf_tls_rdi_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_rdi_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_rdi. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="afd937235379bbdd943d36087d78dd3e7" name="afd937235379bbdd943d36087d78dd3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd937235379bbdd943d36087d78dd3e7">&#9670;&nbsp;</a></span>bf_tls_set_rdi_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_rdi_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_rdi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef909ea7e108faf9f7974066d6ad7517" name="aef909ea7e108faf9f7974066d6ad7517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef909ea7e108faf9f7974066d6ad7517">&#9670;&nbsp;</a></span>bf_tls_r8_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_r8_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_r8. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a2c6f07259e4fcb139f63fd7ff1cdb9a2" name="a2c6f07259e4fcb139f63fd7ff1cdb9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6f07259e4fcb139f63fd7ff1cdb9a2">&#9670;&nbsp;</a></span>bf_tls_set_r8_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_r8_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_r8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67101c478625caa85cb674c9a8d344df" name="a67101c478625caa85cb674c9a8d344df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67101c478625caa85cb674c9a8d344df">&#9670;&nbsp;</a></span>bf_tls_r9_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_r9_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_r9. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a5ea7b4c0b2739a46bf8b8019dbe09795" name="a5ea7b4c0b2739a46bf8b8019dbe09795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea7b4c0b2739a46bf8b8019dbe09795">&#9670;&nbsp;</a></span>bf_tls_set_r9_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_r9_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_r9. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afee9d1aa0f263fac5f32032e61850ff3" name="afee9d1aa0f263fac5f32032e61850ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee9d1aa0f263fac5f32032e61850ff3">&#9670;&nbsp;</a></span>bf_tls_r10_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_r10_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_r10. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a05b0387b79d06bce8ec03517e341d1e7" name="a05b0387b79d06bce8ec03517e341d1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b0387b79d06bce8ec03517e341d1e7">&#9670;&nbsp;</a></span>bf_tls_set_r10_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_r10_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_r10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56a4865a75bf208d5e73902c09d2067d" name="a56a4865a75bf208d5e73902c09d2067d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a4865a75bf208d5e73902c09d2067d">&#9670;&nbsp;</a></span>bf_tls_r11_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_r11_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_r11. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a9ab922b95f098c43eac17ad421d51721" name="a9ab922b95f098c43eac17ad421d51721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab922b95f098c43eac17ad421d51721">&#9670;&nbsp;</a></span>bf_tls_set_r11_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_r11_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_r11. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8355ed161bb0a7da6e19a9c3352d7330" name="a8355ed161bb0a7da6e19a9c3352d7330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8355ed161bb0a7da6e19a9c3352d7330">&#9670;&nbsp;</a></span>bf_tls_r12_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_r12_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_r12. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a82857b970e5e13434b8adbb14b809717" name="a82857b970e5e13434b8adbb14b809717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82857b970e5e13434b8adbb14b809717">&#9670;&nbsp;</a></span>bf_tls_set_r12_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_r12_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_r12. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac99c862dd5e45328612d2b284e37c004" name="ac99c862dd5e45328612d2b284e37c004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99c862dd5e45328612d2b284e37c004">&#9670;&nbsp;</a></span>bf_tls_r13_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_r13_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_r13. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a58a25c8931b84d7406dae8af976ba563" name="a58a25c8931b84d7406dae8af976ba563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a25c8931b84d7406dae8af976ba563">&#9670;&nbsp;</a></span>bf_tls_set_r13_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_r13_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_r13. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a308165fa871eb1f85e13208e2734d613" name="a308165fa871eb1f85e13208e2734d613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308165fa871eb1f85e13208e2734d613">&#9670;&nbsp;</a></span>bf_tls_r14_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_r14_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_r14. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a2b92a1aed1619cb9c1b4fb016dd727d7" name="a2b92a1aed1619cb9c1b4fb016dd727d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b92a1aed1619cb9c1b4fb016dd727d7">&#9670;&nbsp;</a></span>bf_tls_set_r14_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_r14_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_r14. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7d615e1a5046e226912b3573bd9b71a" name="ae7d615e1a5046e226912b3573bd9b71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d615e1a5046e226912b3573bd9b71a">&#9670;&nbsp;</a></span>bf_tls_r15_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_r15_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_r15. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ada3d45786ca0223c9c3f1c128ef64f4b" name="ada3d45786ca0223c9c3f1c128ef64f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3d45786ca0223c9c3f1c128ef64f4b">&#9670;&nbsp;</a></span>bf_tls_set_r15_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_tls_set_r15_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_set_r15. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a936341cbd448d690db392d469eee28a9" name="a936341cbd448d690db392d469eee28a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936341cbd448d690db392d469eee28a9">&#9670;&nbsp;</a></span>bf_tls_extid_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_extid_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_extid. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a4a388401bb280940c6234359f3fc9fef" name="a4a388401bb280940c6234359f3fc9fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a388401bb280940c6234359f3fc9fef">&#9670;&nbsp;</a></span>bf_tls_vmid_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_vmid_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_vmid. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ab2d7369406fe8fe7df0dd03c794920f0" name="ab2d7369406fe8fe7df0dd03c794920f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d7369406fe8fe7df0dd03c794920f0">&#9670;&nbsp;</a></span>bf_tls_vpid_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_vpid_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_vpid. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a641bcd4938f126304761434f4ae57f0c" name="a641bcd4938f126304761434f4ae57f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641bcd4938f126304761434f4ae57f0c">&#9670;&nbsp;</a></span>bf_tls_vsid_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_vsid_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_vsid. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a2c41a89a67679a0733505f95ed9a4b94" name="a2c41a89a67679a0733505f95ed9a4b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c41a89a67679a0733505f95ed9a4b94">&#9670;&nbsp;</a></span>bf_tls_ppid_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_ppid_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_ppid. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ab4d0af168228b553d5647b8045eb3f27" name="ab4d0af168228b553d5647b8045eb3f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d0af168228b553d5647b8045eb3f27">&#9670;&nbsp;</a></span>bf_tls_online_pps_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_tls_online_pps_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_tls_online_pps. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a0618ee9ec570e50a3d187dbe9ae35dfc" name="a0618ee9ec570e50a3d187dbe9ae35dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0618ee9ec570e50a3d187dbe9ae35dfc">&#9670;&nbsp;</a></span>bf_handle_op_open_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_handle_op_open_handle_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint32 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_handle_op_open_handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a528b81780ce39b81600064d7eb83ce8e" name="a528b81780ce39b81600064d7eb83ce8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528b81780ce39b81600064d7eb83ce8e">&#9670;&nbsp;</a></span>bf_handle_op_close_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_handle_op_close_handle_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_handle_op_close_handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ae3496bf02a0f98f746c68a2705f06c99" name="ae3496bf02a0f98f746c68a2705f06c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3496bf02a0f98f746c68a2705f06c99">&#9670;&nbsp;</a></span>bf_debug_op_out_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_debug_op_out_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_debug_op_out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e59b1622f9d76092adf0f7d20b1b392" name="a6e59b1622f9d76092adf0f7d20b1b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e59b1622f9d76092adf0f7d20b1b392">&#9670;&nbsp;</a></span>bf_debug_op_dump_vm_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_debug_op_dump_vm_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_debug_op_dump_vm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84075996ccc30dd8188bd2af2ef41612" name="a84075996ccc30dd8188bd2af2ef41612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84075996ccc30dd8188bd2af2ef41612">&#9670;&nbsp;</a></span>bf_debug_op_dump_vp_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_debug_op_dump_vp_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_debug_op_dump_vp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8966783eb7c2a14142dd93560a870bd" name="ab8966783eb7c2a14142dd93560a870bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8966783eb7c2a14142dd93560a870bd">&#9670;&nbsp;</a></span>bf_debug_op_dump_vs_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_debug_op_dump_vs_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_debug_op_dump_vs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50fa594d0f8c83352f1f2155f5da1da" name="ab50fa594d0f8c83352f1f2155f5da1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50fa594d0f8c83352f1f2155f5da1da">&#9670;&nbsp;</a></span>bf_debug_op_dump_vmexit_log_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_debug_op_dump_vmexit_log_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_debug_op_dump_vmexit_log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a653e7dda4b032c4c0c787c00a4d1159a" name="a653e7dda4b032c4c0c787c00a4d1159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653e7dda4b032c4c0c787c00a4d1159a">&#9670;&nbsp;</a></span>bf_debug_op_dump_ext_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syscall::bf_debug_op_dump_ext_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_debug_op_dump_ext. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f5f0e8964484f8f6c75875589011eb3" name="a3f5f0e8964484f8f6c75875589011eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5f0e8964484f8f6c75875589011eb3">&#9670;&nbsp;</a></span>bf_callback_op_register_bootstrap_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_callback_op_register_bootstrap_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#ade5384db1d6d8a0b23754219e5ab09af">bf_callback_handler_bootstrap_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_callback_op_register_bootstrap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aa4151657acbaacf84630c7fbeef54b71" name="aa4151657acbaacf84630c7fbeef54b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4151657acbaacf84630c7fbeef54b71">&#9670;&nbsp;</a></span>bf_callback_op_register_vmexit_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_callback_op_register_vmexit_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a6e24a9c2a154fcf5ac59d3f0164b567b">bf_callback_handler_vmexit_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_callback_op_register_vmexit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="afdeceda3a65c5d4f7f7726465b0a9fa1" name="afdeceda3a65c5d4f7f7726465b0a9fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdeceda3a65c5d4f7f7726465b0a9fa1">&#9670;&nbsp;</a></span>bf_callback_op_register_fail_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_callback_op_register_fail_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a8d84fbe0f1de9ccdb58661d7850fac82">bf_callback_handler_fail_t</a> const&#160;</td>
          <td class="paramname"><em>pmut_reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_callback_op_register_fail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a3261df20a4d54976b5f1dccfa44e5e85" name="a3261df20a4d54976b5f1dccfa44e5e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3261df20a4d54976b5f1dccfa44e5e85">&#9670;&nbsp;</a></span>bf_vm_op_create_vm_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vm_op_create_vm_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 *const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vm_op_create_vm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a69aaac5d2583b2faa3520b24c9f5c525" name="a69aaac5d2583b2faa3520b24c9f5c525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69aaac5d2583b2faa3520b24c9f5c525">&#9670;&nbsp;</a></span>bf_vm_op_destroy_vm_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vm_op_destroy_vm_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vm_op_destroy_vm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a2771ffe6395939f0808f53852ea3ec04" name="a2771ffe6395939f0808f53852ea3ec04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2771ffe6395939f0808f53852ea3ec04">&#9670;&nbsp;</a></span>bf_vm_op_map_direct_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vm_op_map_direct_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vm_op_map_direct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="afd8d800aed20722b66cfd65965670f4a" name="afd8d800aed20722b66cfd65965670f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8d800aed20722b66cfd65965670f4a">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vm_op_unmap_direct_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vm_op_unmap_direct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="abf0c908fcdea0a0ae1627e2e7f2559c2" name="abf0c908fcdea0a0ae1627e2e7f2559c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0c908fcdea0a0ae1627e2e7f2559c2">&#9670;&nbsp;</a></span>bf_vm_op_unmap_direct_broadcast_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vm_op_unmap_direct_broadcast_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vm_op_unmap_direct_broadcast. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ab0ac540bbcee1cdbfc942b91177e6862" name="ab0ac540bbcee1cdbfc942b91177e6862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ac540bbcee1cdbfc942b91177e6862">&#9670;&nbsp;</a></span>bf_vm_op_tlb_flush_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vm_op_tlb_flush_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vm_op_tlb_flush. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ad806a27848b38ac4b8cd838194193aa5" name="ad806a27848b38ac4b8cd838194193aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad806a27848b38ac4b8cd838194193aa5">&#9670;&nbsp;</a></span>bf_vp_op_create_vp_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vp_op_create_vp_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 *const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vp_op_create_vp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ac6b7ea4b4c5f98c827ebeea9904362a4" name="ac6b7ea4b4c5f98c827ebeea9904362a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b7ea4b4c5f98c827ebeea9904362a4">&#9670;&nbsp;</a></span>bf_vp_op_destroy_vp_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vp_op_destroy_vp_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vp_op_destroy_vp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aec2d40394add6513c9a0e50b81529851" name="aec2d40394add6513c9a0e50b81529851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2d40394add6513c9a0e50b81529851">&#9670;&nbsp;</a></span>bf_vs_op_create_vs_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_create_vs_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 *const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_create_vs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ae91c527f400b7f0c74c9259e38db83fe" name="ae91c527f400b7f0c74c9259e38db83fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91c527f400b7f0c74c9259e38db83fe">&#9670;&nbsp;</a></span>bf_vs_op_destroy_vs_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_destroy_vs_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_destroy_vs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="abf0bf0380a516a218a29d8877f386b6c" name="abf0bf0380a516a218a29d8877f386b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0bf0380a516a218a29d8877f386b6c">&#9670;&nbsp;</a></span>bf_vs_op_init_as_root_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_init_as_root_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_init_as_root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ae4910a95386b04d2a0f3e1ea67dddf74" name="ae4910a95386b04d2a0f3e1ea67dddf74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4910a95386b04d2a0f3e1ea67dddf74">&#9670;&nbsp;</a></span>bf_vs_op_read_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_read_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_read_impl. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a92a10dd549ac91eee775b12e160adb4d" name="a92a10dd549ac91eee775b12e160adb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a10dd549ac91eee775b12e160adb4d">&#9670;&nbsp;</a></span>bf_vs_op_write_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_write_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">bf_reg_t</a> const&#160;</td>
          <td class="paramname"><em>reg2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg3_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg3_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aae6db25af36629d7b39ff8806d39d692" name="aae6db25af36629d7b39ff8806d39d692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6db25af36629d7b39ff8806d39d692">&#9670;&nbsp;</a></span>bf_vs_op_run_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_run_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg3_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg3_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a93e0dd82459854c95df9e131988f7441" name="a93e0dd82459854c95df9e131988f7441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e0dd82459854c95df9e131988f7441">&#9670;&nbsp;</a></span>bf_vs_op_run_current_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_run_current_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_run_current. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a5dcc6d95425bbcc4cf8552c4100d63a2" name="a5dcc6d95425bbcc4cf8552c4100d63a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcc6d95425bbcc4cf8552c4100d63a2">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_advance_ip_and_run_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg3_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_advance_ip_and_run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg3_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a1ace049cf912a7ab3e181122e40ba862" name="a1ace049cf912a7ab3e181122e40ba862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ace049cf912a7ab3e181122e40ba862">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_run_current_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_advance_ip_and_run_current_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_advance_ip_and_run_current. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a7d44c838edbf31b256a6168938a9f84d" name="a7d44c838edbf31b256a6168938a9f84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d44c838edbf31b256a6168938a9f84d">&#9670;&nbsp;</a></span>bf_vs_op_promote_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_promote_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_promote. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a14daee9335a09588fd1d7d2e75982def" name="a14daee9335a09588fd1d7d2e75982def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14daee9335a09588fd1d7d2e75982def">&#9670;&nbsp;</a></span>bf_vs_op_clear_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_clear_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a13e9eb432e30d33387a42494b299ea96" name="a13e9eb432e30d33387a42494b299ea96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e9eb432e30d33387a42494b299ea96">&#9670;&nbsp;</a></span>bf_vs_op_migrate_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_migrate_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_migrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ac773030711f307200b38d41fc1f70ba1" name="ac773030711f307200b38d41fc1f70ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac773030711f307200b38d41fc1f70ba1">&#9670;&nbsp;</a></span>bf_vs_op_set_active_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_set_active_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg3_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_set_active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg3_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a784d530de84afca81be9e51c3e41e04d" name="a784d530de84afca81be9e51c3e41e04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784d530de84afca81be9e51c3e41e04d">&#9670;&nbsp;</a></span>bf_vs_op_advance_ip_and_set_active_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_advance_ip_and_set_active_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg3_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_advance_ip_and_set_active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg3_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a0b36f6f7ce8a6bbc71d24da19c4aadbc" name="a0b36f6f7ce8a6bbc71d24da19c4aadbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b36f6f7ce8a6bbc71d24da19c4aadbc">&#9670;&nbsp;</a></span>bf_vs_op_tlb_flush_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_vs_op_tlb_flush_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_vs_op_tlb_flush. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a5bbe87a47b65a6fca3237de3e27662d6" name="a5bbe87a47b65a6fca3237de3e27662d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbe87a47b65a6fca3237de3e27662d6">&#9670;&nbsp;</a></span>bf_intrinsic_op_rdmsr_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_intrinsic_op_rdmsr_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint32 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_intrinsic_op_rdmsr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a191508923b165cccff17a5712be6aa83" name="a191508923b165cccff17a5712be6aa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191508923b165cccff17a5712be6aa83">&#9670;&nbsp;</a></span>bf_intrinsic_op_wrmsr_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_intrinsic_op_wrmsr_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint32 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg2_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_intrinsic_op_wrmsr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg2_in</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a95140d85764d7238b5edddd178f4b32c" name="a95140d85764d7238b5edddd178f4b32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95140d85764d7238b5edddd178f4b32c">&#9670;&nbsp;</a></span>bf_mem_op_alloc_page_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_mem_op_alloc_page_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_reg1_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_mem_op_alloc_page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg1_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a29824212e26bb606943ab3c27599d569" name="a29824212e26bb606943ab3c27599d569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29824212e26bb606943ab3c27599d569">&#9670;&nbsp;</a></span>bf_mem_op_alloc_huge_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto syscall::bf_mem_op_alloc_huge_impl </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg0_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>pmut_reg0_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_reg1_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the ABI for bf_mem_op_alloc_huge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg0_in</td><td>n/a </td></tr>
    <tr><td class="paramname">reg1_in</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg0_out</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_reg1_out</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ab4b7f86ee984d3aa0524f9e20ab91479" name="ab4b7f86ee984d3aa0524f9e20ab91479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b7f86ee984d3aa0524f9e20ab91479">&#9670;&nbsp;</a></span>tests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto syscall::tests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::exit_code
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to execute the actual checks. We put the checks in this function so that we can validate the tests both at compile-time and at run-time. If a bsl::ut_check fails, the tests will either fail fast at run-time, or will produce a compile-time error. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns bsl::exit_success. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abb84aa125213fd601fad43c9cec583f1" name="abb84aa125213fd601fad43c9cec583f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb84aa125213fd601fad43c9cec583f1">&#9670;&nbsp;</a></span>g_mut_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constinit <a class="el" href="classsyscall_1_1bf__syscall__t.html">bf_syscall_t</a> syscall::g_mut_sys {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stores the <a class="el" href="classsyscall_1_1bf__syscall__t.html" title="Provides an API wrapper around all of the microkernel ABIs. For more information about these APIs,...">bf_syscall_t</a> that this code will use </p>
<p >NOTE:</p><ul>
<li>This is where we store all of our global and thread local variables. All of the variables are marked as static to ensure they are not visable to the rest of the code.</li>
<li>All global and thread local variables must be passed around from function to function as needed. This ensures that constexpr unit tests work properly as the rest of the code never relies on global variables. In addition, it dramatically simplifies unit testing, so enforcing this coding style, although annoying for the function signatures, makes working with the rest of the code a lot easier.</li>
<li>We use constinit here, which works around a specific AUTOSAR rule that does not allow global constructors/destructors. By using constinit, we are sure that runtime global constructors are not used. Bareflank does not attempt to run any init/fini sections of the ELF binary, so if you use accidentally forget constinit, the code will likely not execute and fail as a reminder. Instead, use the initialization/release pattern that this example provides.</li>
<li>From a unit testing point of view, each of these will have dummy versions that are used for testing. When the code is compiled, each source file and head file is compiled in isolation, meaning they are not given include folder access to all of the code. This means that each of these must be mocked, and the unit tests are given include access to the MOCK. This prevents the need for templates, and instead, all mock injection is done using the build system, greatly simplifying both the code and branch analysis during unit tests as the removal of templates also removes issues with branches being counted for each instantiaion of a template type.</li>
<li>Finally, some of these are not really needed for this simple example, but we added them for completness so that it is easier to get started with your own extension as more complicated code will likely need most of these if not all. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesyscall.html">syscall</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
