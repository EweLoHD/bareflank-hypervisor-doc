<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank Hypervisor: mk Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bareflank Hypervisor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacemk.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">mk Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the microkernel's extension pool.  <a href="classmk_1_1ext__pool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1ext__t.html">ext_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an extension WRT to the microkernel. Whenever an executes, it must go through this class to do so. This class also maintains all of the resources given to an extension, as well as the extension's memory map, ELF file, stack, TLS blocks, and all of it's memory map functions.  <a href="classmk_1_1ext__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1ext__tcb__t.html">ext_tcb_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread is a PP, meaning each PP represents a thread. Each extension is given two pages of TLS storage per thread. The first page contains the TLS data, which is created by thread_local. This is just a page that is allocated, so we don't add it here. After the TLS data, the ELF TLS spec requires us to define "tp". This is a pointer to itself and is used by the asm code the compiler generates for thread_local. The rest of the space we can use for whatever we want. Currently, we use this for variables defined in the ABI. For example, we store the general purpose registers and ID information here so that the extension can quickly get access to this information.  <a href="structmk_1_1ext__tcb__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1general__purpose__regs__t.html">general_purpose_regs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the state of the general purpose registers. Note that this storage is only used when swapping from one VS to another. Otherwise, an extension's TLS block is used instead to access the general purpose registers as they are faster.  <a href="structmk_1_1general__purpose__regs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The huge pool provides access to physically contiguous memory. The amount of memory that is available is really, really small (likely no more than 1 MB), but some is needed for different architectures that require it like AMD. This memory is only needed by the extensions, and we currently do not support the ability to free memory, so there is no need to over complicate how this allocator works. We simply use a cursor that is always increasing. Once you allocate all of the memory, that is it.  <a href="classmk_1_1huge__pool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a means for the rest of the kernel to mock the intrinsics when needed during unit testing.  <a href="classmk_1_1intrinsic__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1invept__descriptor__t.html">invept_descriptor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information needed to execute invept.  <a href="structmk_1_1invept__descriptor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1invvpid__descriptor__t.html">invvpid_descriptor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information needed to execute invvpid.  <a href="structmk_1_1invvpid__descriptor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1l0t__t.html">l0t_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of a level-0 table (L0T).  <a href="structmk_1_1l0t__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1l0te__t.html">l0te_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of a level-0 table entry (L0TE).  <a href="structmk_1_1l0te__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1l1t__t.html">l1t_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of a level-1 table (L1T).  <a href="structmk_1_1l1t__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1l1te__t.html">l1te_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of a level-1 table entry (L1TE).  <a href="structmk_1_1l1te__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1l2t__t.html">l2t_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of a level-2 table (L2T).  <a href="structmk_1_1l2t__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1l2te__t.html">l2te_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of a level-2 table entry (L2TE).  <a href="structmk_1_1l2te__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1l3t__t.html">l3t_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of a level-3 table (L3T).  <a href="structmk_1_1l3t__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1l3te__t.html">l3te_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of a level-3 table entry (L3TE).  <a href="structmk_1_1l3te__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1missing__registers__t.html">missing_registers_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the state for the VS that the VMCB/VMCS cannot like the general purpose registers, debug registers, control registers, some MSRs, etc...  <a href="structmk_1_1missing__registers__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1mk__main__t.html">mk_main_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the main entry point for the microkernel. The microkernel actually starts in the _start function, and immediately creates this class and calls its <a class="el" href="classmk_1_1mk__main__t.html#af4f1d9ce209ce8a7e82881f80469859e" title="Process the mk_args_t provided by the loader. If the user provided command succeeds,...">process()</a> function to boot the microkernel, start the extensions and eventually demote the CPU. Like the other main classes, this class serves to encapsulate the entry logic into something that can be easily tested with no dependencies on global resources.  <a href="classmk_1_1mk__main__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1page__aligned__bytes__t.html">page_aligned_bytes_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to return page aligned bytes as well as the total number of pages.  <a href="structmk_1_1page__aligned__bytes__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1tls__t.html">tls_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the layout of the microkernel's TLS block. This should not be confused with the TLS blocks given to an extension, for which there are two, the TLS block for thread_local and the TLS block provided by the microkernel's ABI.  <a href="structmk_1_1tls__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the microkernel's <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a>.  <a href="classmk_1_1vm__pool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1vm__t.html">vm_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the microkernel's notion of a VM.  <a href="classmk_1_1vm__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1vmcb__t.html">vmcb_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following defines the structure of the VMCB used by AMD's hypervisor extensions.  <a href="structmk_1_1vmcb__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1vmcs__t.html">vmcs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following defines the structure of the VMCS used by Intel's hypervisor extensions.  <a href="structmk_1_1vmcs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1vmexit__log__pp__t.html">vmexit_log_pp_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information about each VMExit per PP.  <a href="structmk_1_1vmexit__log__pp__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmk_1_1vmexit__log__record__t.html">vmexit_log_record_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information about each VMExit.  <a href="structmk_1_1vmexit__log__record__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1vmexit__log__t.html">vmexit_log_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a log of all VMExits that occur. Each PP has one log that is shared between all of the VSs so that you get a consistent view of what actually happened during execution, which is more important when implementing guest support as VSs can swap between execution on the same PP as the hypervisor is moving between VMs.  <a href="classmk_1_1vmexit__log__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the microkernel's <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a>.  <a href="classmk_1_1vp__pool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1vp__t.html">vp_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the microkernel's notion of a VP.  <a href="classmk_1_1vp__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the microkernel's <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a>.  <a href="classmk_1_1vs__pool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1vs__t.html">vs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the microkernel's notion of a VS.  <a href="classmk_1_1vs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2f376bdcbeef8c221143eb4b09529328"><td class="memItemLeft" align="right" valign="top"><a id="a2f376bdcbeef8c221143eb4b09529328" name="a2f376bdcbeef8c221143eb4b09529328"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_huge_t</b> = lib::basic_alloc_huge_t</td></tr>
<tr class="memdesc:a2f376bdcbeef8c221143eb4b09529328"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the alloc_huge_t used by the microkernel <br /></td></tr>
<tr class="separator:a2f376bdcbeef8c221143eb4b09529328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc2043a0267976ad3e3c5e1a56fd7ea"><td class="memItemLeft" align="right" valign="top"><a id="a8fc2043a0267976ad3e3c5e1a56fd7ea" name="a8fc2043a0267976ad3e3c5e1a56fd7ea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_page_t</b> = lib::basic_alloc_page_t</td></tr>
<tr class="memdesc:a8fc2043a0267976ad3e3c5e1a56fd7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the alloc_page_t used by the microkernel <br /></td></tr>
<tr class="separator:a8fc2043a0267976ad3e3c5e1a56fd7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aabdd4bcb58ae953aaac01eb921f7fa"><td class="memItemLeft" align="right" valign="top"><a id="a7aabdd4bcb58ae953aaac01eb921f7fa" name="a7aabdd4bcb58ae953aaac01eb921f7fa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocated_status_t</b> = lib::basic_allocated_status_t</td></tr>
<tr class="memdesc:a7aabdd4bcb58ae953aaac01eb921f7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the allocated_status_t used by the microkernel <br /></td></tr>
<tr class="separator:a7aabdd4bcb58ae953aaac01eb921f7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cba738bd1691370b489f0ffb4187b9"><td class="memItemLeft" align="right" valign="top"><a id="a24cba738bd1691370b489f0ffb4187b9" name="a24cba738bd1691370b489f0ffb4187b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>page_4k_t</b> = lib::basic_page_4k_t</td></tr>
<tr class="memdesc:a24cba738bd1691370b489f0ffb4187b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the page_4k_t used by the microkernel <br /></td></tr>
<tr class="separator:a24cba738bd1691370b489f0ffb4187b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669a87971386008bd60c1bfb7cf70f58"><td class="memItemLeft" align="right" valign="top"><a id="a669a87971386008bd60c1bfb7cf70f58" name="a669a87971386008bd60c1bfb7cf70f58"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>lock_guard_t</b> = lib::basic_lock_guard_t&lt; lib::basic_spinlock_t &gt;</td></tr>
<tr class="memdesc:a669a87971386008bd60c1bfb7cf70f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the lock_guard_t used by the microkernel <br /></td></tr>
<tr class="separator:a669a87971386008bd60c1bfb7cf70f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac368255bdd961fd8997f08099b0f0947"><td class="memItemLeft" align="right" valign="top"><a id="ac368255bdd961fd8997f08099b0f0947" name="ac368255bdd961fd8997f08099b0f0947"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>page_pool_t</b> = lib::basic_page_pool_t&lt; <a class="el" href="structmk_1_1tls__t.html">tls_t</a>, bsl::dontcare_t, HYPERVISOR_MK_DIRECT_MAP_ADDR.get(), HYPERVISOR_MK_DIRECT_MAP_SIZE.get()&gt;</td></tr>
<tr class="memdesc:ac368255bdd961fd8997f08099b0f0947"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the page_pool_t used by the microkernel <br /></td></tr>
<tr class="separator:ac368255bdd961fd8997f08099b0f0947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb130b521649a4ca56bb0f9902a2ce9"><td class="memItemLeft" align="right" valign="top"><a id="a6eb130b521649a4ca56bb0f9902a2ce9" name="a6eb130b521649a4ca56bb0f9902a2ce9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>root_page_table_t</b> = lib::basic_root_page_table_t&lt; <a class="el" href="structmk_1_1tls__t.html">tls_t</a>, bsl::dontcare_t, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a>, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a>, <a class="el" href="structlib_1_1l3e__t.html">lib::l3e_t</a>, <a class="el" href="structlib_1_1l2e__t.html">lib::l2e_t</a>, <a class="el" href="structlib_1_1l1e__t.html">lib::l1e_t</a>, <a class="el" href="structlib_1_1l0e__t.html">lib::l0e_t</a> &gt;</td></tr>
<tr class="memdesc:a6eb130b521649a4ca56bb0f9902a2ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the root_page_table_t used by the microkernel <br /></td></tr>
<tr class="separator:a6eb130b521649a4ca56bb0f9902a2ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eabd1e5c60070d373ca85cf1d78cf10"><td class="memItemLeft" align="right" valign="top"><a id="a2eabd1e5c60070d373ca85cf1d78cf10" name="a2eabd1e5c60070d373ca85cf1d78cf10"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>spinlock_t</b> = lib::basic_spinlock_t</td></tr>
<tr class="memdesc:a2eabd1e5c60070d373ca85cf1d78cf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the spinlock_t used by the microkernel <br /></td></tr>
<tr class="separator:a2eabd1e5c60070d373ca85cf1d78cf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1875b10bf8f00d422a0e4e6f59515d2e"><td class="memItemLeft" align="right" valign="top"><a id="a1875b10bf8f00d422a0e4e6f59515d2e" name="a1875b10bf8f00d422a0e4e6f59515d2e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>phdr_table_t</b> = bsl::array&lt; <a class="el" href="structbfelf_1_1elf64__phdr__t.html">bfelf::elf64_phdr_t</a>, PHNUM.get()&gt;</td></tr>
<tr class="memdesc:a1875b10bf8f00d422a0e4e6f59515d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the program header table type <br /></td></tr>
<tr class="separator:a1875b10bf8f00d422a0e4e6f59515d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f89a2fab3b6f7ca6c1829b7a32e35ad"><td class="memItemLeft" align="right" valign="top"><a id="a5f89a2fab3b6f7ca6c1829b7a32e35ad" name="a5f89a2fab3b6f7ca6c1829b7a32e35ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>elf_file_buf_t</b> = bsl::span&lt; bsl::uint8 const  &gt;</td></tr>
<tr class="memdesc:a5f89a2fab3b6f7ca6c1829b7a32e35ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines type used to store the actual bits for an ELF file <br /></td></tr>
<tr class="separator:a5f89a2fab3b6f7ca6c1829b7a32e35ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae65709df4ff7de439f99d4d60f00e461"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ae65709df4ff7de439f99d4d60f00e461">dispatch_esr</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;tls, <a class="el" href="classmk_1_1ext__t.html">ext_t</a> *const ext, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ae65709df4ff7de439f99d4d60f00e461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the main entry point for all exceptions. This function will dispatch exceptions as needed.  <a href="namespacemk.html#ae65709df4ff7de439f99d4d60f00e461">More...</a><br /></td></tr>
<tr class="separator:ae65709df4ff7de439f99d4d60f00e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4fe9f2dabf4bb568703d552a45bf46"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aae4fe9f2dabf4bb568703d552a45bf46">dispatch_syscall_intrinsic_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;tls, <a class="el" href="classmk_1_1ext__t.html">ext_t</a> const &amp;ext, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;intrinsic) -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aae4fe9f2dabf4bb568703d552a45bf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_intrinsic_op syscalls.  <a href="namespacemk.html#aae4fe9f2dabf4bb568703d552a45bf46">More...</a><br /></td></tr>
<tr class="separator:aae4fe9f2dabf4bb568703d552a45bf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ae775746568d20d82e81eeaf1ca1de"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a84ae775746568d20d82e81eeaf1ca1de">call_ext</a> (bsl::uint64 const ip, bsl::uint64 const sp, bsl::uint64 const arg0, bsl::uint64 const arg1) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a84ae775746568d20d82e81eeaf1ca1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls an extension. This can be used to execute an extension's entry point, or it can be used to call an extension's callback that was registered using the entry point. It should be noted that once this function is called, it is likely that the extension will execute syscalls. When this happens, the extension will call back into the microkernel before this function has completed it's execution.  <a href="namespacemk.html#a84ae775746568d20d82e81eeaf1ca1de">More...</a><br /></td></tr>
<tr class="separator:a84ae775746568d20d82e81eeaf1ca1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26d8c959ab4ef899aa1aacd865125cb"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ad26d8c959ab4ef899aa1aacd865125cb">debug_ring_write</a> (<a class="el" href="structloader_1_1debug__ring__t.html">loader::debug_ring_t</a> &amp;mut_ring, bsl::char_type const c) noexcept</td></tr>
<tr class="memdesc:ad26d8c959ab4ef899aa1aacd865125cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a character to the serial port.  <a href="namespacemk.html#ad26d8c959ab4ef899aa1aacd865125cb">More...</a><br /></td></tr>
<tr class="separator:ad26d8c959ab4ef899aa1aacd865125cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa54b3ebcbb7d2912209b1d49ea465e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a8fa54b3ebcbb7d2912209b1d49ea465e">debug_ring_write</a> (<a class="el" href="structloader_1_1debug__ring__t.html">loader::debug_ring_t</a> &amp;mut_ring, bsl::cstr_type const str, bsl::uintmx const len) noexcept</td></tr>
<tr class="memdesc:a8fa54b3ebcbb7d2912209b1d49ea465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a string to the serial port.  <a href="namespacemk.html#a8fa54b3ebcbb7d2912209b1d49ea465e">More...</a><br /></td></tr>
<tr class="separator:a8fa54b3ebcbb7d2912209b1d49ea465e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e0f67879c50db1247bbbdfdb58f212"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a15e0f67879c50db1247bbbdfdb58f212">dispatch_syscall</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;mut_huge_pool, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool, <a class="el" href="classmk_1_1vmexit__log__t.html">vmexit_log_t</a> &amp;mut_log) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a15e0f67879c50db1247bbbdfdb58f212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the main entry point for all syscalls. This function will dispatch syscalls as needed.  <a href="namespacemk.html#a15e0f67879c50db1247bbbdfdb58f212">More...</a><br /></td></tr>
<tr class="separator:a15e0f67879c50db1247bbbdfdb58f212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24800aba21a8559ecbd7ef285a47431a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a24800aba21a8559ecbd7ef285a47431a">syscall_bf_callback_op_register_bootstrap</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a24800aba21a8559ecbd7ef285a47431a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_callback_op_register_bootstrap syscall.  <a href="namespacemk.html#a24800aba21a8559ecbd7ef285a47431a">More...</a><br /></td></tr>
<tr class="separator:a24800aba21a8559ecbd7ef285a47431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0214a050557fb168b6f5eecc231a03"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a8b0214a050557fb168b6f5eecc231a03">syscall_bf_callback_op_register_vmexit</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a8b0214a050557fb168b6f5eecc231a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_callback_op_register_vmexit syscall.  <a href="namespacemk.html#a8b0214a050557fb168b6f5eecc231a03">More...</a><br /></td></tr>
<tr class="separator:a8b0214a050557fb168b6f5eecc231a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19e7ef4800e9c4bfc9da8d13734e17f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa19e7ef4800e9c4bfc9da8d13734e17f">syscall_bf_callback_op_register_fail</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:aa19e7ef4800e9c4bfc9da8d13734e17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_callback_op_register_fail syscall.  <a href="namespacemk.html#aa19e7ef4800e9c4bfc9da8d13734e17f">More...</a><br /></td></tr>
<tr class="separator:aa19e7ef4800e9c4bfc9da8d13734e17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9523188a1f0f03fa2fe443d89714fb6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#af9523188a1f0f03fa2fe443d89714fb6">dispatch_syscall_bf_callback_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:af9523188a1f0f03fa2fe443d89714fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_callback_op syscalls.  <a href="namespacemk.html#af9523188a1f0f03fa2fe443d89714fb6">More...</a><br /></td></tr>
<tr class="separator:af9523188a1f0f03fa2fe443d89714fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6478ca586a0561b7ff7e6e6293f3140a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a6478ca586a0561b7ff7e6e6293f3140a">dispatch_syscall_bf_control_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a6478ca586a0561b7ff7e6e6293f3140a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_callback_op syscalls.  <a href="namespacemk.html#a6478ca586a0561b7ff7e6e6293f3140a">More...</a><br /></td></tr>
<tr class="separator:a6478ca586a0561b7ff7e6e6293f3140a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47afdababe6e10dd2e7bb6d427a08d3b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a47afdababe6e10dd2e7bb6d427a08d3b">dispatch_syscall_bf_debug_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;page_pool, <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> const &amp;huge_pool, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> const &amp;ext_pool, <a class="el" href="classmk_1_1vmexit__log__t.html">vmexit_log_t</a> const &amp;log) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a47afdababe6e10dd2e7bb6d427a08d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_debug_op syscalls.  <a href="namespacemk.html#a47afdababe6e10dd2e7bb6d427a08d3b">More...</a><br /></td></tr>
<tr class="separator:a47afdababe6e10dd2e7bb6d427a08d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476b9b2770e10a1877c3177b2be58146"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a476b9b2770e10a1877c3177b2be58146">syscall_bf_handle_op_open_handle</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a476b9b2770e10a1877c3177b2be58146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_handle_op_open_handle syscall.  <a href="namespacemk.html#a476b9b2770e10a1877c3177b2be58146">More...</a><br /></td></tr>
<tr class="separator:a476b9b2770e10a1877c3177b2be58146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7dd3a519959ea7a0752b6128140afc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aaa7dd3a519959ea7a0752b6128140afc">syscall_bf_handle_op_close_handle</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:aaa7dd3a519959ea7a0752b6128140afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_handle_op_close_handle syscall.  <a href="namespacemk.html#aaa7dd3a519959ea7a0752b6128140afc">More...</a><br /></td></tr>
<tr class="separator:aaa7dd3a519959ea7a0752b6128140afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0b280be30c71238da9a5b6e6ef8536"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a2e0b280be30c71238da9a5b6e6ef8536">dispatch_syscall_bf_handle_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a2e0b280be30c71238da9a5b6e6ef8536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_handle_op syscalls.  <a href="namespacemk.html#a2e0b280be30c71238da9a5b6e6ef8536">More...</a><br /></td></tr>
<tr class="separator:a2e0b280be30c71238da9a5b6e6ef8536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e78789d74bf16c9d67d6034bbdf2f9e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a9e78789d74bf16c9d67d6034bbdf2f9e">syscall_bf_mem_op_alloc_page</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a9e78789d74bf16c9d67d6034bbdf2f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_mem_op_alloc_page syscall.  <a href="namespacemk.html#a9e78789d74bf16c9d67d6034bbdf2f9e">More...</a><br /></td></tr>
<tr class="separator:a9e78789d74bf16c9d67d6034bbdf2f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141d8cc0c90fee0c07adf1e7183a23c9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a141d8cc0c90fee0c07adf1e7183a23c9">syscall_bf_mem_op_alloc_huge</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;mut_huge_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a141d8cc0c90fee0c07adf1e7183a23c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_mem_op_alloc_huge syscall.  <a href="namespacemk.html#a141d8cc0c90fee0c07adf1e7183a23c9">More...</a><br /></td></tr>
<tr class="separator:a141d8cc0c90fee0c07adf1e7183a23c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae7db5482172a0e175db5478b79742d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#adae7db5482172a0e175db5478b79742d">dispatch_syscall_bf_mem_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;mut_huge_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:adae7db5482172a0e175db5478b79742d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_mem_op syscalls.  <a href="namespacemk.html#adae7db5482172a0e175db5478b79742d">More...</a><br /></td></tr>
<tr class="separator:adae7db5482172a0e175db5478b79742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf1419b3b93083466403c24fde3b528"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#acdf1419b3b93083466403c24fde3b528">syscall_bf_vm_op_create_vm</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:acdf1419b3b93083466403c24fde3b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vm_op_create_vm syscall.  <a href="namespacemk.html#acdf1419b3b93083466403c24fde3b528">More...</a><br /></td></tr>
<tr class="separator:acdf1419b3b93083466403c24fde3b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b61c75777c9f60c9594da5a8a4e6589"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a7b61c75777c9f60c9594da5a8a4e6589">syscall_bf_vm_op_destroy_vm</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a7b61c75777c9f60c9594da5a8a4e6589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vm_op_destroy_vm syscall.  <a href="namespacemk.html#a7b61c75777c9f60c9594da5a8a4e6589">More...</a><br /></td></tr>
<tr class="separator:a7b61c75777c9f60c9594da5a8a4e6589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3003baba48d788a2e93543562f769b86"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a3003baba48d788a2e93543562f769b86">syscall_bf_vm_op_map_direct</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;vm_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a3003baba48d788a2e93543562f769b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vm_op_map_direct syscall.  <a href="namespacemk.html#a3003baba48d788a2e93543562f769b86">More...</a><br /></td></tr>
<tr class="separator:a3003baba48d788a2e93543562f769b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65d49f5bbf5c04479a0ca6aacf6b7f7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ae65d49f5bbf5c04479a0ca6aacf6b7f7">syscall_bf_vm_op_unmap_direct</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;vm_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:ae65d49f5bbf5c04479a0ca6aacf6b7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vm_op_unmap_direct syscall.  <a href="namespacemk.html#ae65d49f5bbf5c04479a0ca6aacf6b7f7">More...</a><br /></td></tr>
<tr class="separator:ae65d49f5bbf5c04479a0ca6aacf6b7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac514b504bb4979b2ca94a0bc414e4d53"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ac514b504bb4979b2ca94a0bc414e4d53">syscall_bf_vm_op_unmap_direct_broadcast</a> () noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:ac514b504bb4979b2ca94a0bc414e4d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vm_op_unmap_direct_broadcast syscall.  <a href="namespacemk.html#ac514b504bb4979b2ca94a0bc414e4d53">More...</a><br /></td></tr>
<tr class="separator:ac514b504bb4979b2ca94a0bc414e4d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1fe838fdcd20b7dbf1274d6eba524f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a4c1fe838fdcd20b7dbf1274d6eba524f">syscall_bf_vm_op_tlb_flush</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;vm_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a4c1fe838fdcd20b7dbf1274d6eba524f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vm_op_tlb_flush syscall.  <a href="namespacemk.html#a4c1fe838fdcd20b7dbf1274d6eba524f">More...</a><br /></td></tr>
<tr class="separator:a4c1fe838fdcd20b7dbf1274d6eba524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b602e0eaac7f3322b317efc38629c9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a92b602e0eaac7f3322b317efc38629c9">dispatch_syscall_bf_vm_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a92b602e0eaac7f3322b317efc38629c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_vm_op syscalls.  <a href="namespacemk.html#a92b602e0eaac7f3322b317efc38629c9">More...</a><br /></td></tr>
<tr class="separator:a92b602e0eaac7f3322b317efc38629c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fca857182b52c2175eb9361725e966"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a97fca857182b52c2175eb9361725e966">syscall_bf_vp_op_create_vp</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a97fca857182b52c2175eb9361725e966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vp_op_create_vp syscall.  <a href="namespacemk.html#a97fca857182b52c2175eb9361725e966">More...</a><br /></td></tr>
<tr class="separator:a97fca857182b52c2175eb9361725e966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19471bf7fe69104e467e583110d94d05"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a19471bf7fe69104e467e583110d94d05">syscall_bf_vp_op_destroy_vp</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a19471bf7fe69104e467e583110d94d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vp_op_destroy_vp syscall.  <a href="namespacemk.html#a19471bf7fe69104e467e583110d94d05">More...</a><br /></td></tr>
<tr class="separator:a19471bf7fe69104e467e583110d94d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf626dc7af8cb4b66c49a4995cfa53d7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#acf626dc7af8cb4b66c49a4995cfa53d7">dispatch_syscall_bf_vp_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:acf626dc7af8cb4b66c49a4995cfa53d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_vp_op syscalls.  <a href="namespacemk.html#acf626dc7af8cb4b66c49a4995cfa53d7">More...</a><br /></td></tr>
<tr class="separator:acf626dc7af8cb4b66c49a4995cfa53d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f7c45aef53b2a2d74a219f22135fe3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a81f7c45aef53b2a2d74a219f22135fe3">syscall_bf_vs_op_set_active</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool, bool const advance_ip) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a81f7c45aef53b2a2d74a219f22135fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_set_active syscall.  <a href="namespacemk.html#a81f7c45aef53b2a2d74a219f22135fe3">More...</a><br /></td></tr>
<tr class="separator:a81f7c45aef53b2a2d74a219f22135fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac391aa1224fde38193b1cd8d5bef9e18"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ac391aa1224fde38193b1cd8d5bef9e18">syscall_bf_vs_op_create_vs</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:ac391aa1224fde38193b1cd8d5bef9e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_create_vs syscall.  <a href="namespacemk.html#ac391aa1224fde38193b1cd8d5bef9e18">More...</a><br /></td></tr>
<tr class="separator:ac391aa1224fde38193b1cd8d5bef9e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1a3d9949692ff6e1137e257e1661b5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a1d1a3d9949692ff6e1137e257e1661b5">syscall_bf_vs_op_destroy_vs</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a1d1a3d9949692ff6e1137e257e1661b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_destroy_vs syscall.  <a href="namespacemk.html#a1d1a3d9949692ff6e1137e257e1661b5">More...</a><br /></td></tr>
<tr class="separator:a1d1a3d9949692ff6e1137e257e1661b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e455a57629b4340354beef27650f3f7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a9e455a57629b4340354beef27650f3f7">syscall_bf_vs_op_init_as_root</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a9e455a57629b4340354beef27650f3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_init_as_root syscall.  <a href="namespacemk.html#a9e455a57629b4340354beef27650f3f7">More...</a><br /></td></tr>
<tr class="separator:a9e455a57629b4340354beef27650f3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f94052f4b64ac71452d17cf27bf44cd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a4f94052f4b64ac71452d17cf27bf44cd">syscall_bf_vs_op_read</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a4f94052f4b64ac71452d17cf27bf44cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_read syscall.  <a href="namespacemk.html#a4f94052f4b64ac71452d17cf27bf44cd">More...</a><br /></td></tr>
<tr class="separator:a4f94052f4b64ac71452d17cf27bf44cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c2b8b58b510efe221679131fd15b80"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a71c2b8b58b510efe221679131fd15b80">syscall_bf_vs_op_write</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a71c2b8b58b510efe221679131fd15b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_write syscall.  <a href="namespacemk.html#a71c2b8b58b510efe221679131fd15b80">More...</a><br /></td></tr>
<tr class="separator:a71c2b8b58b510efe221679131fd15b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2acf56598a7bc5c792cb48f7c3934d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a4c2acf56598a7bc5c792cb48f7c3934d">syscall_bf_vs_op_run</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool, bool const advance_ip) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a4c2acf56598a7bc5c792cb48f7c3934d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_run syscall.  <a href="namespacemk.html#a4c2acf56598a7bc5c792cb48f7c3934d">More...</a><br /></td></tr>
<tr class="separator:a4c2acf56598a7bc5c792cb48f7c3934d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebf1f9c353fa65adec51aae626954a1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#abebf1f9c353fa65adec51aae626954a1">syscall_bf_vs_op_run_current</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, bool const advance_ip) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:abebf1f9c353fa65adec51aae626954a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_run_current syscall.  <a href="namespacemk.html#abebf1f9c353fa65adec51aae626954a1">More...</a><br /></td></tr>
<tr class="separator:abebf1f9c353fa65adec51aae626954a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf840d1227a58c118f26c80e35e559b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aebf840d1227a58c118f26c80e35e559b">syscall_bf_vs_op_advance_ip_and_run</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:aebf840d1227a58c118f26c80e35e559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_advance_ip syscall.  <a href="namespacemk.html#aebf840d1227a58c118f26c80e35e559b">More...</a><br /></td></tr>
<tr class="separator:aebf840d1227a58c118f26c80e35e559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8822641a948344f66befc4612e4edc2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ab8822641a948344f66befc4612e4edc2">syscall_bf_vs_op_advance_ip_and_run_current</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:ab8822641a948344f66befc4612e4edc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_advance_ip_and_run_current syscall.  <a href="namespacemk.html#ab8822641a948344f66befc4612e4edc2">More...</a><br /></td></tr>
<tr class="separator:ab8822641a948344f66befc4612e4edc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48af1a8fab207850a2bf9de42e2c67b0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a48af1a8fab207850a2bf9de42e2c67b0">syscall_bf_vs_op_promote</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a48af1a8fab207850a2bf9de42e2c67b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_promote syscall.  <a href="namespacemk.html#a48af1a8fab207850a2bf9de42e2c67b0">More...</a><br /></td></tr>
<tr class="separator:a48af1a8fab207850a2bf9de42e2c67b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5176f1bd8e832d3fc19c55bc420b1890"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a5176f1bd8e832d3fc19c55bc420b1890">syscall_bf_vs_op_clear</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a5176f1bd8e832d3fc19c55bc420b1890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_clear syscall.  <a href="namespacemk.html#a5176f1bd8e832d3fc19c55bc420b1890">More...</a><br /></td></tr>
<tr class="separator:a5176f1bd8e832d3fc19c55bc420b1890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f802d1c7fb9d3df9469e458f9abb8d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ae2f802d1c7fb9d3df9469e458f9abb8d">syscall_bf_vs_op_migrate</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:ae2f802d1c7fb9d3df9469e458f9abb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_migrate syscall.  <a href="namespacemk.html#ae2f802d1c7fb9d3df9469e458f9abb8d">More...</a><br /></td></tr>
<tr class="separator:ae2f802d1c7fb9d3df9469e458f9abb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab331dfb5fad83ea3674dba33782e4f92"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ab331dfb5fad83ea3674dba33782e4f92">syscall_bf_vs_op_advance_ip_and_set_active</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:ab331dfb5fad83ea3674dba33782e4f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_advance_ip_and_set_active syscall.  <a href="namespacemk.html#ab331dfb5fad83ea3674dba33782e4f92">More...</a><br /></td></tr>
<tr class="separator:ab331dfb5fad83ea3674dba33782e4f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab242fd93aa872b79934850494ac4e78b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ab242fd93aa872b79934850494ac4e78b">syscall_bf_vs_op_tlb_flush</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:ab242fd93aa872b79934850494ac4e78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_vs_op_tlb_flush syscall.  <a href="namespacemk.html#ab242fd93aa872b79934850494ac4e78b">More...</a><br /></td></tr>
<tr class="separator:ab242fd93aa872b79934850494ac4e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543427590741f31acf43ccd5e5d938bd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a543427590741f31acf43ccd5e5d938bd">dispatch_syscall_bf_vs_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;mut_page_pool, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;mut_vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;mut_vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;mut_ext_pool) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a543427590741f31acf43ccd5e5d938bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_vs_op syscalls.  <a href="namespacemk.html#a543427590741f31acf43ccd5e5d938bd">More...</a><br /></td></tr>
<tr class="separator:a543427590741f31acf43ccd5e5d938bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e4a4968133560462fcc7a3af6867fb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a61e4a4968133560462fcc7a3af6867fb">has_active_ext_registered_a_callback</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, bsl::safe_umx const &amp;callback, bsl::string_view const &amp;name) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a61e4a4968133560462fcc7a3af6867fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a callback has already been registered by the active ext. Returns false otherwise.  <a href="namespacemk.html#a61e4a4968133560462fcc7a3af6867fb">More...</a><br /></td></tr>
<tr class="separator:a61e4a4968133560462fcc7a3af6867fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb6279b511466549899f8f6605824f8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a1cb6279b511466549899f8f6605824f8">has_any_ext_registered_a_callback</a> (<a class="el" href="classmk_1_1ext__t.html">ext_t</a> const *const ext, bsl::string_view const &amp;name) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a1cb6279b511466549899f8f6605824f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a callback has already been registered by any ext. Returns false otherwise.  <a href="namespacemk.html#a1cb6279b511466549899f8f6605824f8">More...</a><br /></td></tr>
<tr class="separator:a1cb6279b511466549899f8f6605824f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8287bedcf3b247f1f2955eb30d39e9e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#af8287bedcf3b247f1f2955eb30d39e9e">is_version_supported</a> (bsl::uint64 const reg) noexcept -&gt; bool</td></tr>
<tr class="memdesc:af8287bedcf3b247f1f2955eb30d39e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided version is supported. Returns false otherwise.  <a href="namespacemk.html#af8287bedcf3b247f1f2955eb30d39e9e">More...</a><br /></td></tr>
<tr class="separator:af8287bedcf3b247f1f2955eb30d39e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0058080476c0a511ebec4657a2668a4a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a0058080476c0a511ebec4657a2668a4a">verify_handle_for_current_ext</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a0058080476c0a511ebec4657a2668a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the handle provided in tls.reg0 is valid. Returns false otherwise.  <a href="namespacemk.html#a0058080476c0a511ebec4657a2668a4a">More...</a><br /></td></tr>
<tr class="separator:a0058080476c0a511ebec4657a2668a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9627329a7b9a859d48da79aa5c916da"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ac9627329a7b9a859d48da79aa5c916da">is_the_active_ext_the_vmexit_ext</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ac9627329a7b9a859d48da79aa5c916da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the active extension is the extension that registered for VMExits. Returns false otherwise.  <a href="namespacemk.html#ac9627329a7b9a859d48da79aa5c916da">More...</a><br /></td></tr>
<tr class="separator:ac9627329a7b9a859d48da79aa5c916da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032ea30af244751fd8a8eb4f66b39a0d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a032ea30af244751fd8a8eb4f66b39a0d">is_vm_destroyable</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;vm_pool, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, bsl::safe_u16 const &amp;vmid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a032ea30af244751fd8a8eb4f66b39a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmk_1_1vm__t.html" title="Defines the microkernel&#39;s notion of a VM.">vm_t</a> associated with the provided vmid is destroyable. Returns false otherwise.  <a href="namespacemk.html#a032ea30af244751fd8a8eb4f66b39a0d">More...</a><br /></td></tr>
<tr class="separator:a032ea30af244751fd8a8eb4f66b39a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d716286228edca03a2cd9ab79b4bee"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a96d716286228edca03a2cd9ab79b4bee">is_vp_destroyable</a> (<a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u16 const &amp;vpid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a96d716286228edca03a2cd9ab79b4bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> associated with the provided vpid is destroyable. Returns false otherwise.  <a href="namespacemk.html#a96d716286228edca03a2cd9ab79b4bee">More...</a><br /></td></tr>
<tr class="separator:a96d716286228edca03a2cd9ab79b4bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ce2a4ebd79459b707314370e4921ed"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a12ce2a4ebd79459b707314370e4921ed">is_vs_destroyable</a> (<a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a12ce2a4ebd79459b707314370e4921ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is destroyable. Returns false otherwise.  <a href="namespacemk.html#a12ce2a4ebd79459b707314370e4921ed">More...</a><br /></td></tr>
<tr class="separator:a12ce2a4ebd79459b707314370e4921ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdde4ffb5001f92b9ad3bac6a3cb3215"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#acdde4ffb5001f92b9ad3bac6a3cb3215">is_vs_migratable</a> (<a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:acdde4ffb5001f92b9ad3bac6a3cb3215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is migratable to the PP associated with the provided ppid. Returns false otherwise.  <a href="namespacemk.html#acdde4ffb5001f92b9ad3bac6a3cb3215">More...</a><br /></td></tr>
<tr class="separator:acdde4ffb5001f92b9ad3bac6a3cb3215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e1746633cc844f4239a66f65105f7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a46e1746633cc844f4239a66f65105f7c">is_vp_assigned_to_vm</a> (<a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, bsl::safe_u16 const &amp;vpid, bsl::safe_u16 const &amp;vmid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a46e1746633cc844f4239a66f65105f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> associated with the provided vpid is assigned to the provided VM. Returns false otherwise.  <a href="namespacemk.html#a46e1746633cc844f4239a66f65105f7c">More...</a><br /></td></tr>
<tr class="separator:a46e1746633cc844f4239a66f65105f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4490d7c6f76d65d7a6c1147be982bdf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa4490d7c6f76d65d7a6c1147be982bdf">is_vs_assigned_to_vp</a> (<a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u16 const &amp;vsid, bsl::safe_u16 const &amp;vpid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aa4490d7c6f76d65d7a6c1147be982bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is assigned to the provided VP. Returns false otherwise.  <a href="namespacemk.html#aa4490d7c6f76d65d7a6c1147be982bdf">More...</a><br /></td></tr>
<tr class="separator:aa4490d7c6f76d65d7a6c1147be982bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa5524e7c912547da85ecfb9cd567e5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#abfa5524e7c912547da85ecfb9cd567e5">is_vs_assigned_to_current_pp</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:abfa5524e7c912547da85ecfb9cd567e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is assigned to the provided PP. Returns false otherwise.  <a href="namespacemk.html#abfa5524e7c912547da85ecfb9cd567e5">More...</a><br /></td></tr>
<tr class="separator:abfa5524e7c912547da85ecfb9cd567e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1efc6dbba598be2c36974f76a988a07"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa1efc6dbba598be2c36974f76a988a07">is_vs_a_root_vs</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aa1efc6dbba598be2c36974f76a988a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> is a root <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a>, meaning it is a <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> that is allowed to contain root state. A root VS will have the same ID as the ppid. Using the current VMID will not work because a VMID is not present when a root VM is being set up, and the root VM is able to create additional <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a>'s for VSM and nested virtualization support, just like guests, so the only way to determine this is, the VSID is the same as the PPID, which is only possible when a root VS is being created. All other VSIDs will be larger then the PPIDs once the system has been bootstrapped which means they will not be the same.  <a href="namespacemk.html#aa1efc6dbba598be2c36974f76a988a07">More...</a><br /></td></tr>
<tr class="separator:aa1efc6dbba598be2c36974f76a988a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1fb04f12addcf9c885a79788ca5026"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a6f1fb04f12addcf9c885a79788ca5026">is_vp_active_on_another_pp</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool, bsl::safe_u16 const &amp;vpid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a6f1fb04f12addcf9c885a79788ca5026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the requested <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> is active on another PP. Returns false otherwise.  <a href="namespacemk.html#a6f1fb04f12addcf9c885a79788ca5026">More...</a><br /></td></tr>
<tr class="separator:a6f1fb04f12addcf9c885a79788ca5026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421ef72c6b7e3447e2e57ec983ac5e79"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a421ef72c6b7e3447e2e57ec983ac5e79">is_vs_active_on_another_pp</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool, bsl::safe_u16 const &amp;vsid) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a421ef72c6b7e3447e2e57ec983ac5e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the requested <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> is active on another PP. Returns false otherwise.  <a href="namespacemk.html#a421ef72c6b7e3447e2e57ec983ac5e79">More...</a><br /></td></tr>
<tr class="separator:a421ef72c6b7e3447e2e57ec983ac5e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8a206593609b6b553bef3e3c42dc69"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a2f8a206593609b6b553bef3e3c42dc69">get_callback</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a2f8a206593609b6b553bef3e3c42dc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a callback address on success, or bsl::safe_umx::failure() on failure.  <a href="namespacemk.html#a2f8a206593609b6b553bef3e3c42dc69">More...</a><br /></td></tr>
<tr class="separator:a2f8a206593609b6b553bef3e3c42dc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53273256d4a209969f3286e8baa010ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a53273256d4a209969f3286e8baa010ec">get_ppid</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, bsl::uint64 const reg) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a53273256d4a209969f3286e8baa010ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a ppid if the provided register contains a valid ppid. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#a53273256d4a209969f3286e8baa010ec">More...</a><br /></td></tr>
<tr class="separator:a53273256d4a209969f3286e8baa010ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155df731475bb86c52d4fc45adabaab5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a155df731475bb86c52d4fc45adabaab5">get_vmid</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a155df731475bb86c52d4fc45adabaab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a vmid if the provided register contains a valid vmid. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#a155df731475bb86c52d4fc45adabaab5">More...</a><br /></td></tr>
<tr class="separator:a155df731475bb86c52d4fc45adabaab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b92320ce1ae23d5031c864e19df4eb4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a8b92320ce1ae23d5031c864e19df4eb4">get_allocated_vmid</a> (bsl::uint64 const reg, <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;vm_pool) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a8b92320ce1ae23d5031c864e19df4eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a vmid if the provided register contains a valid vmid and the VM associated with the vmid is allocated. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#a8b92320ce1ae23d5031c864e19df4eb4">More...</a><br /></td></tr>
<tr class="separator:a8b92320ce1ae23d5031c864e19df4eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa515649dfbc48d3fe328728ec4ece4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#adfa515649dfbc48d3fe328728ec4ece4">get_vpid</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:adfa515649dfbc48d3fe328728ec4ece4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a vpid if the provided register contains a valid vpid. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#adfa515649dfbc48d3fe328728ec4ece4">More...</a><br /></td></tr>
<tr class="separator:adfa515649dfbc48d3fe328728ec4ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe461716b7039448199b5601ecd874e1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#afe461716b7039448199b5601ecd874e1">get_allocated_vpid</a> (bsl::uint64 const reg, <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;vp_pool) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:afe461716b7039448199b5601ecd874e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a vpid if the provided register contains a valid vpid and the VM associated with the vpid is allocated. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#afe461716b7039448199b5601ecd874e1">More...</a><br /></td></tr>
<tr class="separator:afe461716b7039448199b5601ecd874e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7a280b14132134dd68de49e1c244a2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a6b7a280b14132134dd68de49e1c244a2">get_vsid</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a6b7a280b14132134dd68de49e1c244a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a vsid if the provided register contains a valid vsid. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#a6b7a280b14132134dd68de49e1c244a2">More...</a><br /></td></tr>
<tr class="separator:a6b7a280b14132134dd68de49e1c244a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b13d2620568ce050973bc23c8daeb98"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a1b13d2620568ce050973bc23c8daeb98">get_allocated_vsid</a> (bsl::uint64 const reg, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:a1b13d2620568ce050973bc23c8daeb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a vsid if the provided register contains a valid vsid and the VM associated with the vsid is allocated. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#a1b13d2620568ce050973bc23c8daeb98">More...</a><br /></td></tr>
<tr class="separator:a1b13d2620568ce050973bc23c8daeb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2fccc0a99fde0555dadc13e5cd0b13"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aec2fccc0a99fde0555dadc13e5cd0b13">get_locally_assigned_vsid</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, bsl::uint64 const reg, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;vs_pool) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:aec2fccc0a99fde0555dadc13e5cd0b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a vsid if the provided register contains a valid vsid, the VM associated with the vsid is allocated and locally assigned to the current PP. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#aec2fccc0a99fde0555dadc13e5cd0b13">More...</a><br /></td></tr>
<tr class="separator:aec2fccc0a99fde0555dadc13e5cd0b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf01d4bf17d1e9167e0c6bf5dd5562e9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#abf01d4bf17d1e9167e0c6bf5dd5562e9">get_extid</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_u16</td></tr>
<tr class="memdesc:abf01d4bf17d1e9167e0c6bf5dd5562e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a extid if the provided register contains a valid extid. Otherwise, this function returns bsl::safe_u16::failure().  <a href="namespacemk.html#abf01d4bf17d1e9167e0c6bf5dd5562e9">More...</a><br /></td></tr>
<tr class="separator:abf01d4bf17d1e9167e0c6bf5dd5562e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace179a135eb47275e6ffbcd99ea9e98e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ace179a135eb47275e6ffbcd99ea9e98e">get_reg</a> (bsl::uint64 const reg) noexcept -&gt; <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">syscall::bf_reg_t</a></td></tr>
<tr class="memdesc:ace179a135eb47275e6ffbcd99ea9e98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a bf_reg_t if the provided register contains a valid bf_reg_t. Otherwise, this function returns <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7" title="defines an invalid bf_reg_t">syscall::bf_reg_t::bf_reg_t_invalid</a>.  <a href="namespacemk.html#ace179a135eb47275e6ffbcd99ea9e98e">More...</a><br /></td></tr>
<tr class="separator:ace179a135eb47275e6ffbcd99ea9e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64a8ba3d132b3bd204164930cfc9b00"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ad64a8ba3d132b3bd204164930cfc9b00">get_phys</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ad64a8ba3d132b3bd204164930cfc9b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a physical address if the provided register contains a valid physical address. Otherwise, this function returns bsl::safe_umx::failure().  <a href="namespacemk.html#ad64a8ba3d132b3bd204164930cfc9b00">More...</a><br /></td></tr>
<tr class="separator:ad64a8ba3d132b3bd204164930cfc9b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655021c523eb282865d4dd91cd328054"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a655021c523eb282865d4dd91cd328054">get_direct_map_virt</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a655021c523eb282865d4dd91cd328054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a virtual address if the provided register contains a valid virtual address. Otherwise, this function returns bsl::safe_umx::failure().  <a href="namespacemk.html#a655021c523eb282865d4dd91cd328054">More...</a><br /></td></tr>
<tr class="separator:a655021c523eb282865d4dd91cd328054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53893866baba0abfd4c855700e20083"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ad53893866baba0abfd4c855700e20083">get_gla</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ad53893866baba0abfd4c855700e20083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a guest linear address if the provided register contains a valid guest linear address. Otherwise, this function returns bsl::safe_umx::failure().  <a href="namespacemk.html#ad53893866baba0abfd4c855700e20083">More...</a><br /></td></tr>
<tr class="separator:ad53893866baba0abfd4c855700e20083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023e3d896ab35eacb98f4b2b6a649398"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a023e3d896ab35eacb98f4b2b6a649398">get_huge_size</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_u64</td></tr>
<tr class="memdesc:a023e3d896ab35eacb98f4b2b6a649398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns a huge allocation size if the provided register contains a valid huge allocation size. Otherwise, this function returns bsl::safe_u64::failure().  <a href="namespacemk.html#a023e3d896ab35eacb98f4b2b6a649398">More...</a><br /></td></tr>
<tr class="separator:a023e3d896ab35eacb98f4b2b6a649398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6138939aa797078c6c913852f8036bd3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a6138939aa797078c6c913852f8036bd3">get_msr</a> (bsl::uint64 const reg) noexcept -&gt; bsl::safe_u32</td></tr>
<tr class="memdesc:a6138939aa797078c6c913852f8036bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input register, returns an msr index if the provided register contains a valid msr index. Otherwise, this function returns bsl::safe_u32::failure().  <a href="namespacemk.html#a6138939aa797078c6c913852f8036bd3">More...</a><br /></td></tr>
<tr class="separator:a6138939aa797078c6c913852f8036bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79dcd69e2ef1acdb29be219ebf864b5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ae79dcd69e2ef1acdb29be219ebf864b5">report_syscall_unknown_unsupported</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:ae79dcd69e2ef1acdb29be219ebf864b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the user that the syscall is unknown or is not supported by this hypervisor.  <a href="namespacemk.html#ae79dcd69e2ef1acdb29be219ebf864b5">More...</a><br /></td></tr>
<tr class="separator:ae79dcd69e2ef1acdb29be219ebf864b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa9defe7ec65b4106bfd37668ddb27d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a7aa9defe7ec65b4106bfd37668ddb27d">get_current_tls</a> () noexcept -&gt; <a class="el" href="structmk_1_1tls__t.html">tls_t</a> *</td></tr>
<tr class="memdesc:a7aa9defe7ec65b4106bfd37668ddb27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current TLS block. DO NOT USE THIS API!!! The only code that should use this is the debugging logic.  <a href="namespacemk.html#a7aa9defe7ec65b4106bfd37668ddb27d">More...</a><br /></td></tr>
<tr class="separator:a7aa9defe7ec65b4106bfd37668ddb27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8928ef3355f6cdf6c9cca0fb0e261744"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a8928ef3355f6cdf6c9cca0fb0e261744">dispatch_esr_trampoline</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> *const pmut_tls) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a8928ef3355f6cdf6c9cca0fb0e261744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove me.  <a href="namespacemk.html#a8928ef3355f6cdf6c9cca0fb0e261744">More...</a><br /></td></tr>
<tr class="separator:a8928ef3355f6cdf6c9cca0fb0e261744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d595bab8d47eec8769e21497b123d2"><td class="memItemLeft" align="right" valign="top">C auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ae1d595bab8d47eec8769e21497b123d2">dispatch_syscall_trampoline</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> *const pmut_tls) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:ae1d595bab8d47eec8769e21497b123d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove me  <a href="namespacemk.html#ae1d595bab8d47eec8769e21497b123d2">More...</a><br /></td></tr>
<tr class="separator:ae1d595bab8d47eec8769e21497b123d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7302966b4039281516b43e6d5794996c"><td class="memItemLeft" align="right" valign="top">C auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a7302966b4039281516b43e6d5794996c">mk_main</a> (<a class="el" href="structloader_1_1mk__args__t.html">loader::mk_args_t</a> *const pmut_args, <a class="el" href="structmk_1_1tls__t.html">tls_t</a> *const pmut_tls) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a7302966b4039281516b43e6d5794996c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the main entry point of the microkernel. This function is called by the loader and is responsible for starting the hypervisor on a specific core.  <a href="namespacemk.html#a7302966b4039281516b43e6d5794996c">More...</a><br /></td></tr>
<tr class="separator:a7302966b4039281516b43e6d5794996c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874a7d6589f18d8cf6f37ef4589bea0e"><td class="memItemLeft" align="right" valign="top"><a id="a874a7d6589f18d8cf6f37ef4589bea0e" name="a874a7d6589f18d8cf6f37ef4589bea0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>msg_halt</b> () noexcept</td></tr>
<tr class="memdesc:a874a7d6589f18d8cf6f37ef4589bea0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the halt intrinsic, this function displays a message using the debuging facilities. <br /></td></tr>
<tr class="separator:a874a7d6589f18d8cf6f37ef4589bea0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc88b4732aca2935e3819846f30e802"><td class="memItemLeft" align="right" valign="top"><a id="a6dc88b4732aca2935e3819846f30e802" name="a6dc88b4732aca2935e3819846f30e802"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>msg_stack_chk_fail</b> () noexcept</td></tr>
<tr class="memdesc:a6dc88b4732aca2935e3819846f30e802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the __stack_chk_fail function, this function displays a message using the debuging facilities. <br /></td></tr>
<tr class="separator:a6dc88b4732aca2935e3819846f30e802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568aa5b325fc99b7a1fa277a4fbbdfc3"><td class="memItemLeft" align="right" valign="top"><a id="a568aa5b325fc99b7a1fa277a4fbbdfc3" name="a568aa5b325fc99b7a1fa277a4fbbdfc3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pause</b> () noexcept</td></tr>
<tr class="memdesc:a568aa5b325fc99b7a1fa277a4fbbdfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by endless loops as an optimization. <br /></td></tr>
<tr class="separator:a568aa5b325fc99b7a1fa277a4fbbdfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c708428e2e68ae29107d98031de2a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a56c708428e2e68ae29107d98031de2a0">promote</a> (void const *const state, bsl::uintmx const ec={}) noexcept</td></tr>
<tr class="memdesc:a56c708428e2e68ae29107d98031de2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the current physical processor. Specifically, this is called from the microkernel's POV and tells the microkernel to transition the CPU's execution to the provided state, which will conclude the execution of the microkernel in favor of whatever is in the state, effectively stopping the hypervisor.  <a href="namespacemk.html#a56c708428e2e68ae29107d98031de2a0">More...</a><br /></td></tr>
<tr class="separator:a56c708428e2e68ae29107d98031de2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662c83f9fb89c6b2c20bc15299fe35b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a662c83f9fb89c6b2c20bc15299fe35b9">return_to_mk</a> (bsl::errc_type const status) noexcept</td></tr>
<tr class="memdesc:a662c83f9fb89c6b2c20bc15299fe35b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns to the microkernel after the execution of call_ext.  <a href="namespacemk.html#a662c83f9fb89c6b2c20bc15299fe35b9">More...</a><br /></td></tr>
<tr class="separator:a662c83f9fb89c6b2c20bc15299fe35b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cee043f03590440fb01726b033ae7e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ad7cee043f03590440fb01726b033ae7e">serial_write</a> (bsl::cstr_type const str, bsl::uintmx const len) noexcept</td></tr>
<tr class="memdesc:ad7cee043f03590440fb01726b033ae7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a string to the serial port.  <a href="namespacemk.html#ad7cee043f03590440fb01726b033ae7e">More...</a><br /></td></tr>
<tr class="separator:ad7cee043f03590440fb01726b033ae7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be208ecee964c8a1442c00f99c9b342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a3be208ecee964c8a1442c00f99c9b342">serial_write_c</a> (bsl::char_type const c) noexcept</td></tr>
<tr class="memdesc:a3be208ecee964c8a1442c00f99c9b342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a character "c" to the serial device.  <a href="namespacemk.html#a3be208ecee964c8a1442c00f99c9b342">More...</a><br /></td></tr>
<tr class="separator:a3be208ecee964c8a1442c00f99c9b342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbdbf9e276ac3be9ca23c02ad0adc9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aecbdbf9e276ac3be9ca23c02ad0adc9d">serial_write_hex</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:aecbdbf9e276ac3be9ca23c02ad0adc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a hexidecimal number "val" to the serial device.  <a href="namespacemk.html#aecbdbf9e276ac3be9ca23c02ad0adc9d">More...</a><br /></td></tr>
<tr class="separator:aecbdbf9e276ac3be9ca23c02ad0adc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa941bbe2f352c72cafd766241f9ee689"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa941bbe2f352c72cafd766241f9ee689">vmexit_loop</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;mut_vs_pool, <a class="el" href="classmk_1_1vmexit__log__t.html">vmexit_log_t</a> &amp;mut_log) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa941bbe2f352c72cafd766241f9ee689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the main entry point for VMExits that occur after a successful launch of the hypervisor.  <a href="namespacemk.html#aa941bbe2f352c72cafd766241f9ee689">More...</a><br /></td></tr>
<tr class="separator:aa941bbe2f352c72cafd766241f9ee689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe65b2582c07218fc317cc3a2b4717aa"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#abe65b2582c07218fc317cc3a2b4717aa">dispatch_esr_nmi</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic) noexcept</td></tr>
<tr class="memdesc:abe65b2582c07218fc317cc3a2b4717aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the main entry point for NMI exceptions (which on AMD do not occur as NMIs are blocked).  <a href="namespacemk.html#abe65b2582c07218fc317cc3a2b4717aa">More...</a><br /></td></tr>
<tr class="separator:abe65b2582c07218fc317cc3a2b4717aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b10d3ace45267b4878cf94a3d02b0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a2b10d3ace45267b4878cf94a3d02b0ab">intrinsic_invlpga</a> (bsl::uint64 const addr, bsl::uint64 const asid) noexcept</td></tr>
<tr class="memdesc:a2b10d3ace45267b4878cf94a3d02b0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements intrinsic_t::invlpga.  <a href="namespacemk.html#a2b10d3ace45267b4878cf94a3d02b0ab">More...</a><br /></td></tr>
<tr class="separator:a2b10d3ace45267b4878cf94a3d02b0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0841f1656677dfadd9f6970520fe17e8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a0841f1656677dfadd9f6970520fe17e8">intrinsic_vmrun</a> (void *const pmut_guest_vmcb, bsl::uintmx const guest_vmcb_phys, void *const pmut_host_vmcb, bsl::uintmx const host_vmcb_phys, void *const pmut_missing_registers) noexcept -&gt; bsl::uintmx</td></tr>
<tr class="memdesc:a0841f1656677dfadd9f6970520fe17e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the VMRun instruction. When this function returns a "VMExit" has occurred and must be handled.  <a href="namespacemk.html#a0841f1656677dfadd9f6970520fe17e8">More...</a><br /></td></tr>
<tr class="separator:a0841f1656677dfadd9f6970520fe17e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78e6f5ee0d450c43ca06c103263cad3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa78e6f5ee0d450c43ca06c103263cad3">vector_to_name</a> (bsl::safe_umx const &amp;vector) noexcept -&gt; bsl::string_view</td></tr>
<tr class="memdesc:aa78e6f5ee0d450c43ca06c103263cad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an ESR given it's vector.  <a href="namespacemk.html#aa78e6f5ee0d450c43ca06c103263cad3">More...</a><br /></td></tr>
<tr class="separator:aa78e6f5ee0d450c43ca06c103263cad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccedebac879849914c598286b6f9245"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#afccedebac879849914c598286b6f9245">dispatch_esr_dump</a> (bsl::string_view const &amp;name, bsl::safe_umx const &amp;val) noexcept</td></tr>
<tr class="memdesc:afccedebac879849914c598286b6f9245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of a register.  <a href="namespacemk.html#afccedebac879849914c598286b6f9245">More...</a><br /></td></tr>
<tr class="separator:afccedebac879849914c598286b6f9245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefba1e2a5e3237767f02ea8f902b624b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aefba1e2a5e3237767f02ea8f902b624b">dispatch_esr_dump</a> (bsl::string_view const &amp;name, bsl::safe_u16 const &amp;val) noexcept</td></tr>
<tr class="memdesc:aefba1e2a5e3237767f02ea8f902b624b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of a register.  <a href="namespacemk.html#aefba1e2a5e3237767f02ea8f902b624b">More...</a><br /></td></tr>
<tr class="separator:aefba1e2a5e3237767f02ea8f902b624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7d6ebf9a08f95510e6bbc50fad3db7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ada7d6ebf9a08f95510e6bbc50fad3db7">dispatch_esr_dump_with_segment</a> (bsl::string_view const &amp;name, bsl::safe_umx const &amp;val, bsl::safe_umx const &amp;seg) noexcept</td></tr>
<tr class="memdesc:ada7d6ebf9a08f95510e6bbc50fad3db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of a register and it's segment.  <a href="namespacemk.html#ada7d6ebf9a08f95510e6bbc50fad3db7">More...</a><br /></td></tr>
<tr class="separator:ada7d6ebf9a08f95510e6bbc50fad3db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654cd9af16bc0d6d34bcd85bbbd4a781"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a654cd9af16bc0d6d34bcd85bbbd4a781">is_mk_exception</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a654cd9af16bc0d6d34bcd85bbbd4a781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the exception came from the microkernel. Returns false if the exception came from an extension.  <a href="namespacemk.html#a654cd9af16bc0d6d34bcd85bbbd4a781">More...</a><br /></td></tr>
<tr class="separator:a654cd9af16bc0d6d34bcd85bbbd4a781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99408faee38fd92c72a9ac179f2b5672"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a99408faee38fd92c72a9ac179f2b5672">send_exception_to_ext</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic, bsl::safe_u64 const &amp;errc, bsl::safe_u64 const &amp;addr) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a99408faee38fd92c72a9ac179f2b5672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the exception to the extension so that it can handle it. Only exceptions that originate from the extension can be handled by the exception.  <a href="namespacemk.html#a99408faee38fd92c72a9ac179f2b5672">More...</a><br /></td></tr>
<tr class="separator:a99408faee38fd92c72a9ac179f2b5672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970119f990969a19d895311c6f6f749e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a970119f990969a19d895311c6f6f749e">return_failure</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a970119f990969a19d895311c6f6f749e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a failure. If we can promote to the root VM, we will, otherwise, we will report an error, which will cause the PP to halt as there is nothing left to do.  <a href="namespacemk.html#a970119f990969a19d895311c6f6f749e">More...</a><br /></td></tr>
<tr class="separator:a970119f990969a19d895311c6f6f749e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32230428be5460be19281f6b5d61390"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ac32230428be5460be19281f6b5d61390">dispatch_esr</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ac32230428be5460be19281f6b5d61390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the main entry point for all exceptions. This function will dispatch exceptions as needed.  <a href="namespacemk.html#ac32230428be5460be19281f6b5d61390">More...</a><br /></td></tr>
<tr class="separator:ac32230428be5460be19281f6b5d61390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d80beb9a2ce05a3e08adca1c5122fc5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a4d80beb9a2ce05a3e08adca1c5122fc5">syscall_bf_intrinsic_op_rdmsr</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;intrinsic) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a4d80beb9a2ce05a3e08adca1c5122fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_intrinsic_op_rdmsr syscall.  <a href="namespacemk.html#a4d80beb9a2ce05a3e08adca1c5122fc5">More...</a><br /></td></tr>
<tr class="separator:a4d80beb9a2ce05a3e08adca1c5122fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40daf22cc6d8a1af8cbec2b33dd7cee0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a40daf22cc6d8a1af8cbec2b33dd7cee0">syscall_bf_intrinsic_op_wrmsr</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a40daf22cc6d8a1af8cbec2b33dd7cee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the bf_intrinsic_op_wrmsr syscall.  <a href="namespacemk.html#a40daf22cc6d8a1af8cbec2b33dd7cee0">More...</a><br /></td></tr>
<tr class="separator:a40daf22cc6d8a1af8cbec2b33dd7cee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4a5ed039b3041069013a9208420735"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a5e4a5ed039b3041069013a9208420735">dispatch_syscall_bf_intrinsic_op</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic) noexcept -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td></tr>
<tr class="memdesc:a5e4a5ed039b3041069013a9208420735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the bf_intrinsic_op syscalls.  <a href="namespacemk.html#a5e4a5ed039b3041069013a9208420735">More...</a><br /></td></tr>
<tr class="separator:a5e4a5ed039b3041069013a9208420735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b9afb3e79e51fb5d9044c077553ad0"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ab4b9afb3e79e51fb5d9044c077553ad0">dispatch_esr_nmi</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;mut_tls, <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;mut_intrinsic) noexcept</td></tr>
<tr class="memdesc:ab4b9afb3e79e51fb5d9044c077553ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the main entry point for NMI exceptions.  <a href="namespacemk.html#ab4b9afb3e79e51fb5d9044c077553ad0">More...</a><br /></td></tr>
<tr class="separator:ab4b9afb3e79e51fb5d9044c077553ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5e4d5a563bdec4deeac20da996a54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a6e5e4d5a563bdec4deeac20da996a54d">intrinsic_invept</a> (void const *const desc, bsl::uint64 const type) noexcept</td></tr>
<tr class="memdesc:a6e5e4d5a563bdec4deeac20da996a54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements intrinsic_t::invept.  <a href="namespacemk.html#a6e5e4d5a563bdec4deeac20da996a54d">More...</a><br /></td></tr>
<tr class="separator:a6e5e4d5a563bdec4deeac20da996a54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d57973c5c5d43bcb4c91a26d1538b04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a2d57973c5c5d43bcb4c91a26d1538b04">intrinsic_invvpid</a> (void const *const desc, bsl::uint64 const type) noexcept</td></tr>
<tr class="memdesc:a2d57973c5c5d43bcb4c91a26d1538b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements intrinsic_t::invvpid.  <a href="namespacemk.html#a2d57973c5c5d43bcb4c91a26d1538b04">More...</a><br /></td></tr>
<tr class="separator:a2d57973c5c5d43bcb4c91a26d1538b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62432334a71ca28b1215876178ddced"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ab62432334a71ca28b1215876178ddced">intrinsic_vmcl</a> (void const *const phys) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:ab62432334a71ca28b1215876178ddced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a19e0020e2fba55b09c1327be917f4632" title="Clears a VMCS given a pointer to the physical address of the VMCS.">intrinsic_t::vmcl</a>.  <a href="namespacemk.html#ab62432334a71ca28b1215876178ddced">More...</a><br /></td></tr>
<tr class="separator:ab62432334a71ca28b1215876178ddced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac086e02f2fdf5c1fa4ec0f3da5e386"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#abac086e02f2fdf5c1fa4ec0f3da5e386">intrinsic_vmld</a> (void const *const phys) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:abac086e02f2fdf5c1fa4ec0f3da5e386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a3a603877eb333198942721eefa46c4ec" title="Loads a VMCS given a pointer to the physical address of the VMCS.">intrinsic_t::vmld</a>.  <a href="namespacemk.html#abac086e02f2fdf5c1fa4ec0f3da5e386">More...</a><br /></td></tr>
<tr class="separator:abac086e02f2fdf5c1fa4ec0f3da5e386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991711a39274434a520cab8a86d8246d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a991711a39274434a520cab8a86d8246d">intrinsic_vmrd16</a> (bsl::uint64 const field, bsl::uint16 *const pmut_val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a991711a39274434a520cab8a86d8246d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a9c5b06a2c9e9feb788815a1e88a5f819" title="Returns the value of requested 16 bit VMCS field.">intrinsic_t::vmrd16</a>.  <a href="namespacemk.html#a991711a39274434a520cab8a86d8246d">More...</a><br /></td></tr>
<tr class="separator:a991711a39274434a520cab8a86d8246d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48941300bc76ed924bf8b0334ccffdf5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a48941300bc76ed924bf8b0334ccffdf5">intrinsic_vmrd32</a> (bsl::uint64 const field, bsl::uint32 *const pmut_val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a48941300bc76ed924bf8b0334ccffdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#ac1244a086a6c56c85e294a4895cd066a" title="Returns the value of requested 32 bit VMCS field.">intrinsic_t::vmrd32</a>.  <a href="namespacemk.html#a48941300bc76ed924bf8b0334ccffdf5">More...</a><br /></td></tr>
<tr class="separator:a48941300bc76ed924bf8b0334ccffdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379afadb475d3286223b82ea153d93c4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a379afadb475d3286223b82ea153d93c4">intrinsic_vmrd64</a> (bsl::uint64 const field, bsl::uint64 *const pmut_val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a379afadb475d3286223b82ea153d93c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a3caf041bdfbe63965faef69ff380dc5f" title="Returns the value of requested 64 bit VMCS field.">intrinsic_t::vmrd64</a>.  <a href="namespacemk.html#a379afadb475d3286223b82ea153d93c4">More...</a><br /></td></tr>
<tr class="separator:a379afadb475d3286223b82ea153d93c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ddf31737bf2f12fdabeceed1479c3d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#af8ddf31737bf2f12fdabeceed1479c3d">intrinsic_vmrun</a> (void *const pmut_missing_registers) noexcept -&gt; bsl::uintmx</td></tr>
<tr class="memdesc:af8ddf31737bf2f12fdabeceed1479c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the VMLaunch/VMResume instructions. When this function returns, a "VMExit" has occurred and must be handled.  <a href="namespacemk.html#af8ddf31737bf2f12fdabeceed1479c3d">More...</a><br /></td></tr>
<tr class="separator:af8ddf31737bf2f12fdabeceed1479c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c373a5d920a874648aee9e5f0d8a40"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#af5c373a5d920a874648aee9e5f0d8a40">intrinsic_vmwr16</a> (bsl::uint64 const field, bsl::uint16 const val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:af5c373a5d920a874648aee9e5f0d8a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a1ede8e5a2053f85952fb584837a647e5" title="Sets the value of requested 16 bit VMCS field.">intrinsic_t::vmwr16</a>.  <a href="namespacemk.html#af5c373a5d920a874648aee9e5f0d8a40">More...</a><br /></td></tr>
<tr class="separator:af5c373a5d920a874648aee9e5f0d8a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76be01ead50ae6d3bf637636a1ec0a6e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a76be01ead50ae6d3bf637636a1ec0a6e">intrinsic_vmwr32</a> (bsl::uint64 const field, bsl::uint32 const val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a76be01ead50ae6d3bf637636a1ec0a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a842fef895386d67c5cfcab154445b9e5" title="Sets the value of requested 32 bit VMCS field.">intrinsic_t::vmwr32</a>.  <a href="namespacemk.html#a76be01ead50ae6d3bf637636a1ec0a6e">More...</a><br /></td></tr>
<tr class="separator:a76be01ead50ae6d3bf637636a1ec0a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec53215cd4ae179dff402ec41b94c76"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a8ec53215cd4ae179dff402ec41b94c76">intrinsic_vmwr64</a> (bsl::uint64 const field, bsl::uint64 const val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a8ec53215cd4ae179dff402ec41b94c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#ad2715e7f279079b0bf69c3c97da54513" title="Sets the value of requested 64 bit VMCS field.">intrinsic_t::vmwr64</a>.  <a href="namespacemk.html#a8ec53215cd4ae179dff402ec41b94c76">More...</a><br /></td></tr>
<tr class="separator:a8ec53215cd4ae179dff402ec41b94c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa002b2992bb198976f7982d34947bf99"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa002b2992bb198976f7982d34947bf99">intrinsic_vmwrfunc</a> (bsl::uint64 const field, void(*const pmut_func)() noexcept) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:aa002b2992bb198976f7982d34947bf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a2615c3408536928fba62e851620161df" title="Sets the value of requested 64 bit VMCS field (function version)">intrinsic_t::vmwrfunc</a>.  <a href="namespacemk.html#aa002b2992bb198976f7982d34947bf99">More...</a><br /></td></tr>
<tr class="separator:aa002b2992bb198976f7982d34947bf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1329c1e1ddfa3c5b79698673a1aa14c"><td class="memItemLeft" align="right" valign="top"><a id="af1329c1e1ddfa3c5b79698673a1aa14c" name="af1329c1e1ddfa3c5b79698673a1aa14c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>intrinsic_vmexit</b> (void) noexcept</td></tr>
<tr class="memdesc:af1329c1e1ddfa3c5b79698673a1aa14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">entry point prototype <br /></td></tr>
<tr class="separator:af1329c1e1ddfa3c5b79698673a1aa14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7124930de59ec52ac8b0967b08c6666b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a7124930de59ec52ac8b0967b08c6666b">intrinsic_cr0</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a7124930de59ec52ac8b0967b08c6666b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#abd5608b0f721fa2a38b1c64bccc99974" title="Returns the value of CR0.">intrinsic_t::cr0</a>.  <a href="namespacemk.html#a7124930de59ec52ac8b0967b08c6666b">More...</a><br /></td></tr>
<tr class="separator:a7124930de59ec52ac8b0967b08c6666b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67adb3a0b4fff20635f843e0260afd95"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a67adb3a0b4fff20635f843e0260afd95">intrinsic_cr3</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a67adb3a0b4fff20635f843e0260afd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a419d77813034cfc77c5db154d0100ab2" title="Returns the value of CR3.">intrinsic_t::cr3</a>.  <a href="namespacemk.html#a67adb3a0b4fff20635f843e0260afd95">More...</a><br /></td></tr>
<tr class="separator:a67adb3a0b4fff20635f843e0260afd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4090f792c0780d66a2aa28f8e42f965d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a4090f792c0780d66a2aa28f8e42f965d">intrinsic_cr4</a> () noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a4090f792c0780d66a2aa28f8e42f965d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a23f3f83e0b0a2bd4792c606cc5ec7b04" title="Returns the value of CR4.">intrinsic_t::cr4</a>.  <a href="namespacemk.html#a4090f792c0780d66a2aa28f8e42f965d">More...</a><br /></td></tr>
<tr class="separator:a4090f792c0780d66a2aa28f8e42f965d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc56a2a0daa1d68ef32b4d78a63266"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ad1bc56a2a0daa1d68ef32b4d78a63266">intrinsic_cs_selector</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:ad1bc56a2a0daa1d68ef32b4d78a63266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>.  <a href="namespacemk.html#ad1bc56a2a0daa1d68ef32b4d78a63266">More...</a><br /></td></tr>
<tr class="separator:ad1bc56a2a0daa1d68ef32b4d78a63266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2723a77171b26e14db5f2e651f82d38a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a2723a77171b26e14db5f2e651f82d38a">intrinsic_ds_selector</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:a2723a77171b26e14db5f2e651f82d38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>.  <a href="namespacemk.html#a2723a77171b26e14db5f2e651f82d38a">More...</a><br /></td></tr>
<tr class="separator:a2723a77171b26e14db5f2e651f82d38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3518b8c18e2b945cd667a455bd13eb32"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a3518b8c18e2b945cd667a455bd13eb32">intrinsic_es_selector</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:a3518b8c18e2b945cd667a455bd13eb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>.  <a href="namespacemk.html#a3518b8c18e2b945cd667a455bd13eb32">More...</a><br /></td></tr>
<tr class="separator:a3518b8c18e2b945cd667a455bd13eb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca492e2266a947b7aa3d7ac19b936d14"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aca492e2266a947b7aa3d7ac19b936d14">intrinsic_fs_selector</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:aca492e2266a947b7aa3d7ac19b936d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>.  <a href="namespacemk.html#aca492e2266a947b7aa3d7ac19b936d14">More...</a><br /></td></tr>
<tr class="separator:aca492e2266a947b7aa3d7ac19b936d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c381e87dd2e79ad229640953c93096"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa2c381e87dd2e79ad229640953c93096">intrinsic_gs_selector</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:aa2c381e87dd2e79ad229640953c93096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>.  <a href="namespacemk.html#aa2c381e87dd2e79ad229640953c93096">More...</a><br /></td></tr>
<tr class="separator:aa2c381e87dd2e79ad229640953c93096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e09e1e6e62c40d9991739dcec76ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#af0e09e1e6e62c40d9991739dcec76ee4">intrinsic_invlpg</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:af0e09e1e6e62c40d9991739dcec76ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements intrinsic_t::invlpg.  <a href="namespacemk.html#af0e09e1e6e62c40d9991739dcec76ee4">More...</a><br /></td></tr>
<tr class="separator:af0e09e1e6e62c40d9991739dcec76ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8f15f653b892a7634042530547c56e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a3f8f15f653b892a7634042530547c56e">intrinsic_rdmsr</a> (bsl::uint32 const msr, bsl::uint64 *const pmut_val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a3f8f15f653b892a7634042530547c56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#af153a688aa5e0023598c0069a3aab400" title="Returns the value of requested MSR.">intrinsic_t::rdmsr</a>.  <a href="namespacemk.html#a3f8f15f653b892a7634042530547c56e">More...</a><br /></td></tr>
<tr class="separator:a3f8f15f653b892a7634042530547c56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e5314d32449eff5f1e6ba4aa16dba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a87e5314d32449eff5f1e6ba4aa16dba6">intrinsic_set_cr3</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:a87e5314d32449eff5f1e6ba4aa16dba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements intrinsic_t::set_cr3.  <a href="namespacemk.html#a87e5314d32449eff5f1e6ba4aa16dba6">More...</a><br /></td></tr>
<tr class="separator:a87e5314d32449eff5f1e6ba4aa16dba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2af3dcfdfaf2c87ae9a275e75e244b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa2af3dcfdfaf2c87ae9a275e75e244b9">intrinsic_set_tls_reg</a> (bsl::uint64 const reg, bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:aa2af3dcfdfaf2c87ae9a275e75e244b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#ac45a1927db5ff764babca38522567580" title="Sets the value of a requested TLS register.">intrinsic_t::set_tls_reg</a>.  <a href="namespacemk.html#aa2af3dcfdfaf2c87ae9a275e75e244b9">More...</a><br /></td></tr>
<tr class="separator:aa2af3dcfdfaf2c87ae9a275e75e244b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00898b0e5594f76545e699367178947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aa00898b0e5594f76545e699367178947">intrinsic_set_tp</a> (bsl::uint64 const val) noexcept</td></tr>
<tr class="memdesc:aa00898b0e5594f76545e699367178947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a3ded778669a4022370fb37a7ab896b59" title="Sets the value of tp (TLS pointer)">intrinsic_t::set_tp</a>.  <a href="namespacemk.html#aa00898b0e5594f76545e699367178947">More...</a><br /></td></tr>
<tr class="separator:aa00898b0e5594f76545e699367178947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ee32573da3ee725feb5f02e811ee7d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a81ee32573da3ee725feb5f02e811ee7d">intrinsic_ss_selector</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:a81ee32573da3ee725feb5f02e811ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>.  <a href="namespacemk.html#a81ee32573da3ee725feb5f02e811ee7d">More...</a><br /></td></tr>
<tr class="separator:a81ee32573da3ee725feb5f02e811ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3070295b284b4c85e79b9a001467230d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a3070295b284b4c85e79b9a001467230d">intrinsic_tls_reg</a> (bsl::uint64 const reg) noexcept -&gt; bsl::uint64</td></tr>
<tr class="memdesc:a3070295b284b4c85e79b9a001467230d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a1afec55b62b86fa06b57abb4a46ef86b" title="Returns the value of a requested TLS register.">intrinsic_t::tls_reg</a>.  <a href="namespacemk.html#a3070295b284b4c85e79b9a001467230d">More...</a><br /></td></tr>
<tr class="separator:a3070295b284b4c85e79b9a001467230d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee89096808e382c2b721f1c24e3bc84a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#aee89096808e382c2b721f1c24e3bc84a">intrinsic_tr_selector</a> () noexcept -&gt; bsl::uint16</td></tr>
<tr class="memdesc:aee89096808e382c2b721f1c24e3bc84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#aef6360a6d49b32f8896469e58d972817" title="Returns the value of TR.">intrinsic_t::tr_selector</a>.  <a href="namespacemk.html#aee89096808e382c2b721f1c24e3bc84a">More...</a><br /></td></tr>
<tr class="separator:aee89096808e382c2b721f1c24e3bc84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926351b032eec63cdb4dfee3d07a188a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a926351b032eec63cdb4dfee3d07a188a">intrinsic_wrmsr</a> (bsl::uint32 const msr, bsl::uint64 const val) noexcept -&gt; bsl::errc_type</td></tr>
<tr class="memdesc:a926351b032eec63cdb4dfee3d07a188a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmk_1_1intrinsic__t.html#a6638ea06bd1a39996aa896e2291e6f20" title="Sets the value of requested MSR.">intrinsic_t::wrmsr</a>.  <a href="namespacemk.html#a926351b032eec63cdb4dfee3d07a188a">More...</a><br /></td></tr>
<tr class="separator:a926351b032eec63cdb4dfee3d07a188a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b1e205c5f1fd2bf3e5c124113a19f9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a05b1e205c5f1fd2bf3e5c124113a19f9">tests</a> () noexcept -&gt; bsl::exit_code</td></tr>
<tr class="memdesc:a05b1e205c5f1fd2bf3e5c124113a19f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to execute the actual checks. We put the checks in this function so that we can validate the tests both at compile-time and at run-time. If a bsl::ut_check fails, the tests will either fail fast at run-time, or will produce a compile-time error.  <a href="namespacemk.html#a05b1e205c5f1fd2bf3e5c124113a19f9">More...</a><br /></td></tr>
<tr class="separator:a05b1e205c5f1fd2bf3e5c124113a19f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef2159d757677380c949f64d41eeebe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a1ef2159d757677380c949f64d41eeebe">get_elf_file_buf</a> () noexcept -&gt; <a class="el" href="namespacemk.html#a5f89a2fab3b6f7ca6c1829b7a32e35ad">elf_file_buf_t</a></td></tr>
<tr class="memdesc:a1ef2159d757677380c949f64d41eeebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an allocated and initialized ELF file buffer for use during testing.  <a href="namespacemk.html#a1ef2159d757677380c949f64d41eeebe">More...</a><br /></td></tr>
<tr class="separator:a1ef2159d757677380c949f64d41eeebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4829f09f58f372de3b2dfff834bb7cd"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ae4829f09f58f372de3b2dfff834bb7cd">clr_elf_file_buf</a> (<a class="el" href="namespacemk.html#a5f89a2fab3b6f7ca6c1829b7a32e35ad">elf_file_buf_t</a> const &amp;elf_file_buf) noexcept</td></tr>
<tr class="memdesc:ae4829f09f58f372de3b2dfff834bb7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the provided ELF file buffer.  <a href="namespacemk.html#ae4829f09f58f372de3b2dfff834bb7cd">More...</a><br /></td></tr>
<tr class="separator:ae4829f09f58f372de3b2dfff834bb7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891a0c045d595b15ce5becaa0f25cbb5"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a891a0c045d595b15ce5becaa0f25cbb5">load_phdr_table</a> (<a class="el" href="namespacemk.html#a1875b10bf8f00d422a0e4e6f59515d2e">phdr_table_t</a> &amp;mut_phdr_table, <a class="el" href="namespacemk.html#a5f89a2fab3b6f7ca6c1829b7a32e35ad">elf_file_buf_t</a> const &amp;elf_file_buf) noexcept</td></tr>
<tr class="memdesc:a891a0c045d595b15ce5becaa0f25cbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the initial state of the program header table.  <a href="namespacemk.html#a891a0c045d595b15ce5becaa0f25cbb5">More...</a><br /></td></tr>
<tr class="separator:a891a0c045d595b15ce5becaa0f25cbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8995415c1c097dccf58dc16c09cdd22"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#ae8995415c1c097dccf58dc16c09cdd22">load_phdr_table_without_tls</a> (<a class="el" href="namespacemk.html#a1875b10bf8f00d422a0e4e6f59515d2e">phdr_table_t</a> &amp;mut_phdr_table, <a class="el" href="namespacemk.html#a5f89a2fab3b6f7ca6c1829b7a32e35ad">elf_file_buf_t</a> const &amp;elf_file_buf) noexcept</td></tr>
<tr class="memdesc:ae8995415c1c097dccf58dc16c09cdd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the initial state of the program header table.  <a href="namespacemk.html#ae8995415c1c097dccf58dc16c09cdd22">More...</a><br /></td></tr>
<tr class="separator:ae8995415c1c097dccf58dc16c09cdd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35218501de38177ce14d977a6a565090"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a35218501de38177ce14d977a6a565090">load_elf_file</a> (<a class="el" href="namespaceloader.html#afd2bbbd3305d4d499c41035aee9f464e">loader::ext_elf_file_t</a> &amp;mut_file, <a class="el" href="namespacemk.html#a1875b10bf8f00d422a0e4e6f59515d2e">phdr_table_t</a> const &amp;phdr_table) noexcept</td></tr>
<tr class="memdesc:a35218501de38177ce14d977a6a565090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the initial state of an ELF file.  <a href="namespacemk.html#a35218501de38177ce14d977a6a565090">More...</a><br /></td></tr>
<tr class="separator:a35218501de38177ce14d977a6a565090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36987777237fe886236e5a0620e0c560"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a36987777237fe886236e5a0620e0c560">create_tls</a> () noexcept -&gt; <a class="el" href="structmk_1_1tls__t.html">tls_t</a></td></tr>
<tr class="memdesc:a36987777237fe886236e5a0620e0c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="structmk_1_1tls__t.html" title="Defines the layout of the microkernel&#39;s TLS block. This should not be confused with the TLS blocks gi...">tls_t</a> for testing.  <a href="namespacemk.html#a36987777237fe886236e5a0620e0c560">More...</a><br /></td></tr>
<tr class="separator:a36987777237fe886236e5a0620e0c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf8228ec2023145848f5d05fdc7ed0d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a0bf8228ec2023145848f5d05fdc7ed0d">create_args</a> () noexcept -&gt; <a class="el" href="structloader_1_1mk__args__t.html">loader::mk_args_t</a></td></tr>
<tr class="memdesc:a0bf8228ec2023145848f5d05fdc7ed0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="structloader_1_1mk__args__t.html" title="Defines the arguments sent to the _start function of the microkernel. The microkernel will have it&#39;s ...">loader::mk_args_t</a> for testing.  <a href="namespacemk.html#a0bf8228ec2023145848f5d05fdc7ed0d">More...</a><br /></td></tr>
<tr class="separator:a0bf8228ec2023145848f5d05fdc7ed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d514305bf5e255ea6f51e23462f1202"><td class="memItemLeft" align="right" valign="top"><a id="a7d514305bf5e255ea6f51e23462f1202" name="a7d514305bf5e255ea6f51e23462f1202"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HYPERVISOR_STACK_CHK_FAIL_NAME</b> () noexcept</td></tr>
<tr class="memdesc:a7d514305bf5e255ea6f51e23462f1202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a stack overflow occurs. <br /></td></tr>
<tr class="separator:a7d514305bf5e255ea6f51e23462f1202"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a63f360fd607caf4117218c1d8d124edf"><td class="memItemLeft" align="right" valign="top"><a id="a63f360fd607caf4117218c1d8d124edf" name="a63f360fd607caf4117218c1d8d124edf"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_L0T_ENTRIES</b> {512_umx}</td></tr>
<tr class="memdesc:a63f360fd607caf4117218c1d8d124edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines total number of entries in the L0T <br /></td></tr>
<tr class="separator:a63f360fd607caf4117218c1d8d124edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab064be64c49c48ccda9c17bdf19e99ba"><td class="memItemLeft" align="right" valign="top"><a id="ab064be64c49c48ccda9c17bdf19e99ba" name="ab064be64c49c48ccda9c17bdf19e99ba"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_L1T_ENTRIES</b> {512_umx}</td></tr>
<tr class="memdesc:ab064be64c49c48ccda9c17bdf19e99ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines total number of entries in the L1T <br /></td></tr>
<tr class="separator:ab064be64c49c48ccda9c17bdf19e99ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfa35a72903ce6f41f16525692ff28c"><td class="memItemLeft" align="right" valign="top"><a id="afcfa35a72903ce6f41f16525692ff28c" name="afcfa35a72903ce6f41f16525692ff28c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_L2T_ENTRIES</b> {512_umx}</td></tr>
<tr class="memdesc:afcfa35a72903ce6f41f16525692ff28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines total number of entries in the L2T <br /></td></tr>
<tr class="separator:afcfa35a72903ce6f41f16525692ff28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a49aa0c90269926d33f671933ee869"><td class="memItemLeft" align="right" valign="top"><a id="a87a49aa0c90269926d33f671933ee869" name="a87a49aa0c90269926d33f671933ee869"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_L3T_ENTRIES</b> {512_umx}</td></tr>
<tr class="memdesc:a87a49aa0c90269926d33f671933ee869"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines total number of entries in the L3T <br /></td></tr>
<tr class="separator:a87a49aa0c90269926d33f671933ee869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e27322aaf57952d03503d65a5ce571"><td class="memItemLeft" align="right" valign="top"><a id="a88e27322aaf57952d03503d65a5ce571" name="a88e27322aaf57952d03503d65a5ce571"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_T_RESERVED1_SIZE</b> {0x020_umx}</td></tr>
<tr class="memdesc:a88e27322aaf57952d03503d65a5ce571"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved1 field in the <a class="el" href="structmk_1_1tls__t.html" title="Defines the layout of the microkernel&#39;s TLS block. This should not be confused with the TLS blocks gi...">tls_t</a> <br /></td></tr>
<tr class="separator:a88e27322aaf57952d03503d65a5ce571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916861d48cb003a27096cedd9d801ede"><td class="memItemLeft" align="right" valign="top"><a id="a916861d48cb003a27096cedd9d801ede" name="a916861d48cb003a27096cedd9d801ede"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_T_RESERVED2_SIZE</b> {0x008_umx}</td></tr>
<tr class="memdesc:a916861d48cb003a27096cedd9d801ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved2 field in the <a class="el" href="structmk_1_1tls__t.html" title="Defines the layout of the microkernel&#39;s TLS block. This should not be confused with the TLS blocks gi...">tls_t</a> <br /></td></tr>
<tr class="separator:a916861d48cb003a27096cedd9d801ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2ee1b8665b18a140621c28d33da731"><td class="memItemLeft" align="right" valign="top"><a id="a4e2ee1b8665b18a140621c28d33da731" name="a4e2ee1b8665b18a140621c28d33da731"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_T_RESERVED3_SIZE</b> {0x007_umx}</td></tr>
<tr class="memdesc:a4e2ee1b8665b18a140621c28d33da731"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved3 field in the <a class="el" href="structmk_1_1tls__t.html" title="Defines the layout of the microkernel&#39;s TLS block. This should not be confused with the TLS blocks gi...">tls_t</a> <br /></td></tr>
<tr class="separator:a4e2ee1b8665b18a140621c28d33da731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77b1988b78b942cdb22a544f0bd1a45"><td class="memItemLeft" align="right" valign="top"><a id="aa77b1988b78b942cdb22a544f0bd1a45" name="aa77b1988b78b942cdb22a544f0bd1a45"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>TLS_T_RESERVED4_SIZE</b> {0x040_umx}</td></tr>
<tr class="memdesc:aa77b1988b78b942cdb22a544f0bd1a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved4 field in the <a class="el" href="structmk_1_1tls__t.html" title="Defines the layout of the microkernel&#39;s TLS block. This should not be confused with the TLS blocks gi...">tls_t</a> <br /></td></tr>
<tr class="separator:aa77b1988b78b942cdb22a544f0bd1a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c730786d5c27bb2c641f18704f75ed"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a72c730786d5c27bb2c641f18704f75ed">TLS_T_SIZE</a> {0x400_umx}</td></tr>
<tr class="memdesc:a72c730786d5c27bb2c641f18704f75ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the the total size of the TLS block  <a href="namespacemk.html#a72c730786d5c27bb2c641f18704f75ed">More...</a><br /></td></tr>
<tr class="separator:a72c730786d5c27bb2c641f18704f75ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53082c03e147035d333c4c8e7fd4152f"><td class="memItemLeft" align="right" valign="top"><a id="a53082c03e147035d333c4c8e7fd4152f" name="a53082c03e147035d333c4c8e7fd4152f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED1_SIZE</b> {0x24_umx}</td></tr>
<tr class="memdesc:a53082c03e147035d333c4c8e7fd4152f"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved1 field in the VMCB <br /></td></tr>
<tr class="separator:a53082c03e147035d333c4c8e7fd4152f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631b275ee6a8a7c2f1c18a2ba7480567"><td class="memItemLeft" align="right" valign="top"><a id="a631b275ee6a8a7c2f1c18a2ba7480567" name="a631b275ee6a8a7c2f1c18a2ba7480567"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED2_SIZE</b> {0x3_umx}</td></tr>
<tr class="memdesc:a631b275ee6a8a7c2f1c18a2ba7480567"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved2 field in the VMCB <br /></td></tr>
<tr class="separator:a631b275ee6a8a7c2f1c18a2ba7480567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dc72927480f2b7b30f74c26bad8390"><td class="memItemLeft" align="right" valign="top"><a id="ab9dc72927480f2b7b30f74c26bad8390" name="ab9dc72927480f2b7b30f74c26bad8390"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED3_SIZE</b> {0x4_umx}</td></tr>
<tr class="memdesc:ab9dc72927480f2b7b30f74c26bad8390"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved3 field in the VMCB <br /></td></tr>
<tr class="separator:ab9dc72927480f2b7b30f74c26bad8390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5af36bccd55424a500d59fa83d6d02"><td class="memItemLeft" align="right" valign="top"><a id="a6c5af36bccd55424a500d59fa83d6d02" name="a6c5af36bccd55424a500d59fa83d6d02"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED4_SIZE</b> {0x8_umx}</td></tr>
<tr class="memdesc:a6c5af36bccd55424a500d59fa83d6d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved4 field in the VMCB <br /></td></tr>
<tr class="separator:a6c5af36bccd55424a500d59fa83d6d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04248b3ec94857786fd592b9487fcd05"><td class="memItemLeft" align="right" valign="top"><a id="a04248b3ec94857786fd592b9487fcd05" name="a04248b3ec94857786fd592b9487fcd05"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED5_SIZE</b> {0x8_umx}</td></tr>
<tr class="memdesc:a04248b3ec94857786fd592b9487fcd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved5 field in the VMCB <br /></td></tr>
<tr class="separator:a04248b3ec94857786fd592b9487fcd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1878d612aabb70a052591327937651"><td class="memItemLeft" align="right" valign="top"><a id="a4b1878d612aabb70a052591327937651" name="a4b1878d612aabb70a052591327937651"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED6_SIZE</b> {0x2F0_umx}</td></tr>
<tr class="memdesc:a4b1878d612aabb70a052591327937651"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved6 field in the VMCB <br /></td></tr>
<tr class="separator:a4b1878d612aabb70a052591327937651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5cfb97387518fca3dae5af398aa865"><td class="memItemLeft" align="right" valign="top"><a id="a3e5cfb97387518fca3dae5af398aa865" name="a3e5cfb97387518fca3dae5af398aa865"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED7_SIZE</b> {0x2B_umx}</td></tr>
<tr class="memdesc:a3e5cfb97387518fca3dae5af398aa865"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved7 field in the VMCB <br /></td></tr>
<tr class="separator:a3e5cfb97387518fca3dae5af398aa865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc67eefdb2f666daf34cde5d0cef554"><td class="memItemLeft" align="right" valign="top"><a id="aefc67eefdb2f666daf34cde5d0cef554" name="aefc67eefdb2f666daf34cde5d0cef554"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED8_SIZE</b> {0x4_umx}</td></tr>
<tr class="memdesc:aefc67eefdb2f666daf34cde5d0cef554"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved8 field in the VMCB <br /></td></tr>
<tr class="separator:aefc67eefdb2f666daf34cde5d0cef554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dcd54581e205354656d80b650407cc"><td class="memItemLeft" align="right" valign="top"><a id="ab0dcd54581e205354656d80b650407cc" name="ab0dcd54581e205354656d80b650407cc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED9_SIZE</b> {0x70_umx}</td></tr>
<tr class="memdesc:ab0dcd54581e205354656d80b650407cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved9 field in the VMCB <br /></td></tr>
<tr class="separator:ab0dcd54581e205354656d80b650407cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cff3468b602a3477edafddc6af51162"><td class="memItemLeft" align="right" valign="top"><a id="a2cff3468b602a3477edafddc6af51162" name="a2cff3468b602a3477edafddc6af51162"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED10_SIZE</b> {0x58_umx}</td></tr>
<tr class="memdesc:a2cff3468b602a3477edafddc6af51162"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved10 field in the VMCB <br /></td></tr>
<tr class="separator:a2cff3468b602a3477edafddc6af51162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac820442d77c13a1292263040e23d357b"><td class="memItemLeft" align="right" valign="top"><a id="ac820442d77c13a1292263040e23d357b" name="ac820442d77c13a1292263040e23d357b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED11_SIZE</b> {0x18_umx}</td></tr>
<tr class="memdesc:ac820442d77c13a1292263040e23d357b"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved11 field in the VMCB <br /></td></tr>
<tr class="separator:ac820442d77c13a1292263040e23d357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca5d3ed16172abd82a45d9e0772221d"><td class="memItemLeft" align="right" valign="top"><a id="a6ca5d3ed16172abd82a45d9e0772221d" name="a6ca5d3ed16172abd82a45d9e0772221d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED12_SIZE</b> {0x20_umx}</td></tr>
<tr class="memdesc:a6ca5d3ed16172abd82a45d9e0772221d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved12 field in the VMCB <br /></td></tr>
<tr class="separator:a6ca5d3ed16172abd82a45d9e0772221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8660d1fc4259f6e8acc39d43372f0721"><td class="memItemLeft" align="right" valign="top"><a id="a8660d1fc4259f6e8acc39d43372f0721" name="a8660d1fc4259f6e8acc39d43372f0721"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_RESERVED13_SIZE</b> {0x968_umx}</td></tr>
<tr class="memdesc:a8660d1fc4259f6e8acc39d43372f0721"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved13 field in the VMCB <br /></td></tr>
<tr class="separator:a8660d1fc4259f6e8acc39d43372f0721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66348ca46a930622a6480098b7545a1"><td class="memItemLeft" align="right" valign="top"><a id="ac66348ca46a930622a6480098b7545a1" name="ac66348ca46a930622a6480098b7545a1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCB_GIB_SIZE</b> {0xF_umx}</td></tr>
<tr class="memdesc:ac66348ca46a930622a6480098b7545a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the size of the reserved13 field in the VMCB <br /></td></tr>
<tr class="separator:ac66348ca46a930622a6480098b7545a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5927f445ec99faf4c25b386a75b3dc04"><td class="memItemLeft" align="right" valign="top"><a id="a5927f445ec99faf4c25b386a75b3dc04" name="a5927f445ec99faf4c25b386a75b3dc04"></a>
constexpr bsl::errc_type&#160;</td><td class="memItemRight" valign="bottom"><b>vmexit_success</b> {1001}</td></tr>
<tr class="memdesc:a5927f445ec99faf4c25b386a75b3dc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned when a VMExit is a success. <br /></td></tr>
<tr class="separator:a5927f445ec99faf4c25b386a75b3dc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3af11581b70c593ff3b92cd324dc11"><td class="memItemLeft" align="right" valign="top"><a id="a5e3af11581b70c593ff3b92cd324dc11" name="a5e3af11581b70c593ff3b92cd324dc11"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_PAGE_READ</b> {lib::BASIC_MAP_PAGE_READ}</td></tr>
<tr class="memdesc:a5e3af11581b70c593ff3b92cd324dc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">map a page with read permmissions <br /></td></tr>
<tr class="separator:a5e3af11581b70c593ff3b92cd324dc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a4d4c764ff8bb7d47763dab7e5715c"><td class="memItemLeft" align="right" valign="top"><a id="a10a4d4c764ff8bb7d47763dab7e5715c" name="a10a4d4c764ff8bb7d47763dab7e5715c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_PAGE_WRITE</b> {lib::BASIC_MAP_PAGE_WRITE}</td></tr>
<tr class="memdesc:a10a4d4c764ff8bb7d47763dab7e5715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">map a page with write permmissions <br /></td></tr>
<tr class="separator:a10a4d4c764ff8bb7d47763dab7e5715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadb5330e1c43edd6b6fc3f383f89888"><td class="memItemLeft" align="right" valign="top"><a id="aaadb5330e1c43edd6b6fc3f383f89888" name="aaadb5330e1c43edd6b6fc3f383f89888"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_PAGE_EXECUTE</b> {lib::BASIC_MAP_PAGE_EXECUTE}</td></tr>
<tr class="memdesc:aaadb5330e1c43edd6b6fc3f383f89888"><td class="mdescLeft">&#160;</td><td class="mdescRight">map a page with execute permmissions <br /></td></tr>
<tr class="separator:aaadb5330e1c43edd6b6fc3f383f89888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb2d4190d1eb1c1a2ca104d579e536f"><td class="memItemLeft" align="right" valign="top"><a id="aeeb2d4190d1eb1c1a2ca104d579e536f" name="aeeb2d4190d1eb1c1a2ca104d579e536f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_PAGE_RW</b> {lib::BASIC_MAP_PAGE_RW}</td></tr>
<tr class="memdesc:aeeb2d4190d1eb1c1a2ca104d579e536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">map a page with read/write permmissions <br /></td></tr>
<tr class="separator:aeeb2d4190d1eb1c1a2ca104d579e536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb89da48d8f5eb8724d75e41547f298"><td class="memItemLeft" align="right" valign="top"><a id="aaeb89da48d8f5eb8724d75e41547f298" name="aaeb89da48d8f5eb8724d75e41547f298"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_PAGE_RE</b> {lib::BASIC_MAP_PAGE_RE}</td></tr>
<tr class="memdesc:aaeb89da48d8f5eb8724d75e41547f298"><td class="mdescLeft">&#160;</td><td class="mdescRight">map a page with read/execute permmissions <br /></td></tr>
<tr class="separator:aaeb89da48d8f5eb8724d75e41547f298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0862a50da81bd8c3847f3310758df5f0"><td class="memItemLeft" align="right" valign="top"><a id="a0862a50da81bd8c3847f3310758df5f0" name="a0862a50da81bd8c3847f3310758df5f0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>RESERVED_SIZE</b> {0xFFC_umx}</td></tr>
<tr class="memdesc:a0862a50da81bd8c3847f3310758df5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the size of reserved field <br /></td></tr>
<tr class="separator:a0862a50da81bd8c3847f3310758df5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed13ff5c6d0176018945b13ce6b5c52a"><td class="memItemLeft" align="right" valign="top"><a id="aed13ff5c6d0176018945b13ce6b5c52a" name="aed13ff5c6d0176018945b13ce6b5c52a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_UNUSABLE_SEGMENT</b> {0x10000_u32}</td></tr>
<tr class="memdesc:aed13ff5c6d0176018945b13ce6b5c52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an unusable segment descriptor <br /></td></tr>
<tr class="separator:aed13ff5c6d0176018945b13ce6b5c52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212b829f62b76f828a851aae3fa0a7c6"><td class="memItemLeft" align="right" valign="top"><a id="a212b829f62b76f828a851aae3fa0a7c6" name="a212b829f62b76f828a851aae3fa0a7c6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VIRTUAL_PROCESSOR_IDENTIFIER</b> {0x0000_umx}</td></tr>
<tr class="memdesc:a212b829f62b76f828a851aae3fa0a7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: virtual_processor_identifier <br /></td></tr>
<tr class="separator:a212b829f62b76f828a851aae3fa0a7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dada97d7e742d8fd19c251e1651935"><td class="memItemLeft" align="right" valign="top"><a id="ab3dada97d7e742d8fd19c251e1651935" name="ab3dada97d7e742d8fd19c251e1651935"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_POSTED_INTERRUPT_NOTIFICATION_VECTOR</b> {0x0002_umx}</td></tr>
<tr class="memdesc:ab3dada97d7e742d8fd19c251e1651935"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: posted_interrupt_notification_vector <br /></td></tr>
<tr class="separator:ab3dada97d7e742d8fd19c251e1651935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7687c1cfbf39ea46df145d2ae2a9e58e"><td class="memItemLeft" align="right" valign="top"><a id="a7687c1cfbf39ea46df145d2ae2a9e58e" name="a7687c1cfbf39ea46df145d2ae2a9e58e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EPTP_INDEX</b> {0x0004_umx}</td></tr>
<tr class="memdesc:a7687c1cfbf39ea46df145d2ae2a9e58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: eptp_index <br /></td></tr>
<tr class="separator:a7687c1cfbf39ea46df145d2ae2a9e58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426230704edb507fb020abd54a9a008c"><td class="memItemLeft" align="right" valign="top"><a id="a426230704edb507fb020abd54a9a008c" name="a426230704edb507fb020abd54a9a008c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_ES_SELECTOR</b> {0x0800_umx}</td></tr>
<tr class="memdesc:a426230704edb507fb020abd54a9a008c"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_es_selector <br /></td></tr>
<tr class="separator:a426230704edb507fb020abd54a9a008c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa9d63f45ae7d07244ee7eba8f34b55"><td class="memItemLeft" align="right" valign="top"><a id="aafa9d63f45ae7d07244ee7eba8f34b55" name="aafa9d63f45ae7d07244ee7eba8f34b55"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_CS_SELECTOR</b> {0x0802_umx}</td></tr>
<tr class="memdesc:aafa9d63f45ae7d07244ee7eba8f34b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_cs_selector <br /></td></tr>
<tr class="separator:aafa9d63f45ae7d07244ee7eba8f34b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da0a2cd0b49baa44d0a32ebf56b4d3"><td class="memItemLeft" align="right" valign="top"><a id="aa4da0a2cd0b49baa44d0a32ebf56b4d3" name="aa4da0a2cd0b49baa44d0a32ebf56b4d3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_SS_SELECTOR</b> {0x0804_umx}</td></tr>
<tr class="memdesc:aa4da0a2cd0b49baa44d0a32ebf56b4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ss_selector <br /></td></tr>
<tr class="separator:aa4da0a2cd0b49baa44d0a32ebf56b4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0140bcbe44be65be6d8b4079dcf11e2"><td class="memItemLeft" align="right" valign="top"><a id="af0140bcbe44be65be6d8b4079dcf11e2" name="af0140bcbe44be65be6d8b4079dcf11e2"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_DS_SELECTOR</b> {0x0806_umx}</td></tr>
<tr class="memdesc:af0140bcbe44be65be6d8b4079dcf11e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ds_selector <br /></td></tr>
<tr class="separator:af0140bcbe44be65be6d8b4079dcf11e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e212a8d11fb4f45507d9322de47228"><td class="memItemLeft" align="right" valign="top"><a id="a85e212a8d11fb4f45507d9322de47228" name="a85e212a8d11fb4f45507d9322de47228"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_FS_SELECTOR</b> {0x0808_umx}</td></tr>
<tr class="memdesc:a85e212a8d11fb4f45507d9322de47228"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_fs_selector <br /></td></tr>
<tr class="separator:a85e212a8d11fb4f45507d9322de47228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ac82e937aea1bbc11449f8023ae97c"><td class="memItemLeft" align="right" valign="top"><a id="a47ac82e937aea1bbc11449f8023ae97c" name="a47ac82e937aea1bbc11449f8023ae97c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_GS_SELECTOR</b> {0x080A_umx}</td></tr>
<tr class="memdesc:a47ac82e937aea1bbc11449f8023ae97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_gs_selector <br /></td></tr>
<tr class="separator:a47ac82e937aea1bbc11449f8023ae97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25458e41df690f5a0a444f52d51cf6cf"><td class="memItemLeft" align="right" valign="top"><a id="a25458e41df690f5a0a444f52d51cf6cf" name="a25458e41df690f5a0a444f52d51cf6cf"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_LDTR_SELECTOR</b> {0x080C_umx}</td></tr>
<tr class="memdesc:a25458e41df690f5a0a444f52d51cf6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ldtr_selector <br /></td></tr>
<tr class="separator:a25458e41df690f5a0a444f52d51cf6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefeb1fc94355234fdf810007ae95726"><td class="memItemLeft" align="right" valign="top"><a id="adefeb1fc94355234fdf810007ae95726" name="adefeb1fc94355234fdf810007ae95726"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_TR_SELECTOR</b> {0x080E_umx}</td></tr>
<tr class="memdesc:adefeb1fc94355234fdf810007ae95726"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_tr_selector <br /></td></tr>
<tr class="separator:adefeb1fc94355234fdf810007ae95726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f480c149a00a38995e951e800aa6db"><td class="memItemLeft" align="right" valign="top"><a id="a44f480c149a00a38995e951e800aa6db" name="a44f480c149a00a38995e951e800aa6db"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_INTERRUPT_STATUS</b> {0x0810_umx}</td></tr>
<tr class="memdesc:a44f480c149a00a38995e951e800aa6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_interrupt_status <br /></td></tr>
<tr class="separator:a44f480c149a00a38995e951e800aa6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae119c35ea5d37c9ce511428873b5f9fb"><td class="memItemLeft" align="right" valign="top"><a id="ae119c35ea5d37c9ce511428873b5f9fb" name="ae119c35ea5d37c9ce511428873b5f9fb"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_PML_INDEX</b> {0x0812_umx}</td></tr>
<tr class="memdesc:ae119c35ea5d37c9ce511428873b5f9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: pml_index <br /></td></tr>
<tr class="separator:ae119c35ea5d37c9ce511428873b5f9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b94afb9ee5ec19909efb9a60a879319"><td class="memItemLeft" align="right" valign="top"><a id="a4b94afb9ee5ec19909efb9a60a879319" name="a4b94afb9ee5ec19909efb9a60a879319"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_ES_SELECTOR</b> {0x0C00_umx}</td></tr>
<tr class="memdesc:a4b94afb9ee5ec19909efb9a60a879319"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_es_selector <br /></td></tr>
<tr class="separator:a4b94afb9ee5ec19909efb9a60a879319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1449435b3ee8e2b6bd053d99c4cad70"><td class="memItemLeft" align="right" valign="top"><a id="ab1449435b3ee8e2b6bd053d99c4cad70" name="ab1449435b3ee8e2b6bd053d99c4cad70"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_CS_SELECTOR</b> {0x0C02_umx}</td></tr>
<tr class="memdesc:ab1449435b3ee8e2b6bd053d99c4cad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_cs_selector <br /></td></tr>
<tr class="separator:ab1449435b3ee8e2b6bd053d99c4cad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5631842071a77c9254013f1b44d632"><td class="memItemLeft" align="right" valign="top"><a id="a0a5631842071a77c9254013f1b44d632" name="a0a5631842071a77c9254013f1b44d632"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_SS_SELECTOR</b> {0x0C04_umx}</td></tr>
<tr class="memdesc:a0a5631842071a77c9254013f1b44d632"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_ss_selector <br /></td></tr>
<tr class="separator:a0a5631842071a77c9254013f1b44d632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fe86c3416b6c3e56749ed1a3a0b19c"><td class="memItemLeft" align="right" valign="top"><a id="a21fe86c3416b6c3e56749ed1a3a0b19c" name="a21fe86c3416b6c3e56749ed1a3a0b19c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_DS_SELECTOR</b> {0x0C06_umx}</td></tr>
<tr class="memdesc:a21fe86c3416b6c3e56749ed1a3a0b19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_ds_selector <br /></td></tr>
<tr class="separator:a21fe86c3416b6c3e56749ed1a3a0b19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6348c0fee238fd353780aeaf78f8207"><td class="memItemLeft" align="right" valign="top"><a id="ac6348c0fee238fd353780aeaf78f8207" name="ac6348c0fee238fd353780aeaf78f8207"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_FS_SELECTOR</b> {0x0C08_umx}</td></tr>
<tr class="memdesc:ac6348c0fee238fd353780aeaf78f8207"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_fs_selector <br /></td></tr>
<tr class="separator:ac6348c0fee238fd353780aeaf78f8207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb0a45eaaac587c6a41df9ce6dd4e03"><td class="memItemLeft" align="right" valign="top"><a id="a2bb0a45eaaac587c6a41df9ce6dd4e03" name="a2bb0a45eaaac587c6a41df9ce6dd4e03"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_GS_SELECTOR</b> {0x0C0A_umx}</td></tr>
<tr class="memdesc:a2bb0a45eaaac587c6a41df9ce6dd4e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_gs_selector <br /></td></tr>
<tr class="separator:a2bb0a45eaaac587c6a41df9ce6dd4e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6024e4338e6cd8078a158444be511e38"><td class="memItemLeft" align="right" valign="top"><a id="a6024e4338e6cd8078a158444be511e38" name="a6024e4338e6cd8078a158444be511e38"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_TR_SELECTOR</b> {0x0C0C_umx}</td></tr>
<tr class="memdesc:a6024e4338e6cd8078a158444be511e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_tr_selector <br /></td></tr>
<tr class="separator:a6024e4338e6cd8078a158444be511e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928735466777d26725693b250c256335"><td class="memItemLeft" align="right" valign="top"><a id="a928735466777d26725693b250c256335" name="a928735466777d26725693b250c256335"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_ADDRESS_OF_IO_BITMAP_A</b> {0x2000_umx}</td></tr>
<tr class="memdesc:a928735466777d26725693b250c256335"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: address_of_io_bitmap_a <br /></td></tr>
<tr class="separator:a928735466777d26725693b250c256335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e82abbbd6cb2aaea453f227ad4703ad"><td class="memItemLeft" align="right" valign="top"><a id="a0e82abbbd6cb2aaea453f227ad4703ad" name="a0e82abbbd6cb2aaea453f227ad4703ad"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_ADDRESS_OF_IO_BITMAP_B</b> {0x2002_umx}</td></tr>
<tr class="memdesc:a0e82abbbd6cb2aaea453f227ad4703ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: address_of_io_bitmap_b <br /></td></tr>
<tr class="separator:a0e82abbbd6cb2aaea453f227ad4703ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b59b20257e6f3a834c61d960176747"><td class="memItemLeft" align="right" valign="top"><a id="a43b59b20257e6f3a834c61d960176747" name="a43b59b20257e6f3a834c61d960176747"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_ADDRESS_OF_MSR_BITMAPS</b> {0x2004_umx}</td></tr>
<tr class="memdesc:a43b59b20257e6f3a834c61d960176747"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: address_of_msr_bitmaps <br /></td></tr>
<tr class="separator:a43b59b20257e6f3a834c61d960176747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ecb2acc84d8cee5f2cdd090e11deeb"><td class="memItemLeft" align="right" valign="top"><a id="a47ecb2acc84d8cee5f2cdd090e11deeb" name="a47ecb2acc84d8cee5f2cdd090e11deeb"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_MSR_STORE_ADDRESS</b> {0x2006_umx}</td></tr>
<tr class="memdesc:a47ecb2acc84d8cee5f2cdd090e11deeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_msr_store_address <br /></td></tr>
<tr class="separator:a47ecb2acc84d8cee5f2cdd090e11deeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40223ea734170fba918c08f0d04fad0d"><td class="memItemLeft" align="right" valign="top"><a id="a40223ea734170fba918c08f0d04fad0d" name="a40223ea734170fba918c08f0d04fad0d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_MSR_LOAD_ADDRESS</b> {0x2008_umx}</td></tr>
<tr class="memdesc:a40223ea734170fba918c08f0d04fad0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_msr_load_address <br /></td></tr>
<tr class="separator:a40223ea734170fba918c08f0d04fad0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e239410e1441d8bcdd5fdb8b99aedab"><td class="memItemLeft" align="right" valign="top"><a id="a7e239410e1441d8bcdd5fdb8b99aedab" name="a7e239410e1441d8bcdd5fdb8b99aedab"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMENTRY_MSR_LOAD_ADDRESS</b> {0x200A_umx}</td></tr>
<tr class="memdesc:a7e239410e1441d8bcdd5fdb8b99aedab"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmentry_msr_load_address <br /></td></tr>
<tr class="separator:a7e239410e1441d8bcdd5fdb8b99aedab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168c8f375adcc1d1ee2e51cfd6e750e9"><td class="memItemLeft" align="right" valign="top"><a id="a168c8f375adcc1d1ee2e51cfd6e750e9" name="a168c8f375adcc1d1ee2e51cfd6e750e9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EXECUTIVE_VMCS_POINTER</b> {0x200C_umx}</td></tr>
<tr class="memdesc:a168c8f375adcc1d1ee2e51cfd6e750e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: executive_vmcs_pointer <br /></td></tr>
<tr class="separator:a168c8f375adcc1d1ee2e51cfd6e750e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586a97ce41b27c48819da5c1ade1fccf"><td class="memItemLeft" align="right" valign="top"><a id="a586a97ce41b27c48819da5c1ade1fccf" name="a586a97ce41b27c48819da5c1ade1fccf"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_PML_ADDRESS</b> {0x200E_umx}</td></tr>
<tr class="memdesc:a586a97ce41b27c48819da5c1ade1fccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: pml_address <br /></td></tr>
<tr class="separator:a586a97ce41b27c48819da5c1ade1fccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef68c0ce929e5716f6030e69f33d35d"><td class="memItemLeft" align="right" valign="top"><a id="a4ef68c0ce929e5716f6030e69f33d35d" name="a4ef68c0ce929e5716f6030e69f33d35d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_TSC_OFFSET</b> {0x2010_umx}</td></tr>
<tr class="memdesc:a4ef68c0ce929e5716f6030e69f33d35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: tsc_offset <br /></td></tr>
<tr class="separator:a4ef68c0ce929e5716f6030e69f33d35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca6d9cf7e5220678d1552c1a6506062"><td class="memItemLeft" align="right" valign="top"><a id="a6ca6d9cf7e5220678d1552c1a6506062" name="a6ca6d9cf7e5220678d1552c1a6506062"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VIRTUAL_APIC_ADDRESS</b> {0x2012_umx}</td></tr>
<tr class="memdesc:a6ca6d9cf7e5220678d1552c1a6506062"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: virtual_apic_address <br /></td></tr>
<tr class="separator:a6ca6d9cf7e5220678d1552c1a6506062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee63a2636eba1d8d52a580dab99230c"><td class="memItemLeft" align="right" valign="top"><a id="a6ee63a2636eba1d8d52a580dab99230c" name="a6ee63a2636eba1d8d52a580dab99230c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_APIC_ACCESS_ADDRESS</b> {0x2014_umx}</td></tr>
<tr class="memdesc:a6ee63a2636eba1d8d52a580dab99230c"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: apic_access_address <br /></td></tr>
<tr class="separator:a6ee63a2636eba1d8d52a580dab99230c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeb2fd7dc2441569ed201cc0e7b3fcb"><td class="memItemLeft" align="right" valign="top"><a id="abbeb2fd7dc2441569ed201cc0e7b3fcb" name="abbeb2fd7dc2441569ed201cc0e7b3fcb"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS</b> {0x2016_umx}</td></tr>
<tr class="memdesc:abbeb2fd7dc2441569ed201cc0e7b3fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: posted_interrupt_descriptor_address <br /></td></tr>
<tr class="separator:abbeb2fd7dc2441569ed201cc0e7b3fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dc9f5b20a94ae7bc9b6f5d7ab82f37"><td class="memItemLeft" align="right" valign="top"><a id="a59dc9f5b20a94ae7bc9b6f5d7ab82f37" name="a59dc9f5b20a94ae7bc9b6f5d7ab82f37"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VM_FUNCTION_CONTROLS</b> {0x2018_umx}</td></tr>
<tr class="memdesc:a59dc9f5b20a94ae7bc9b6f5d7ab82f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vm_function_controls <br /></td></tr>
<tr class="separator:a59dc9f5b20a94ae7bc9b6f5d7ab82f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e61df358f4945c6e947534a75d0116"><td class="memItemLeft" align="right" valign="top"><a id="a06e61df358f4945c6e947534a75d0116" name="a06e61df358f4945c6e947534a75d0116"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EPT_POINTER</b> {0x201A_umx}</td></tr>
<tr class="memdesc:a06e61df358f4945c6e947534a75d0116"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: ept_pointer <br /></td></tr>
<tr class="separator:a06e61df358f4945c6e947534a75d0116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea6cff487519461b34a9398807c7294"><td class="memItemLeft" align="right" valign="top"><a id="aaea6cff487519461b34a9398807c7294" name="aaea6cff487519461b34a9398807c7294"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EOI_EXIT_BITMAP0</b> {0x201C_umx}</td></tr>
<tr class="memdesc:aaea6cff487519461b34a9398807c7294"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: eoi_exit_bitmap0 <br /></td></tr>
<tr class="separator:aaea6cff487519461b34a9398807c7294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c97ed4cf8e25413c5eeb97d9005427"><td class="memItemLeft" align="right" valign="top"><a id="ae9c97ed4cf8e25413c5eeb97d9005427" name="ae9c97ed4cf8e25413c5eeb97d9005427"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EOI_EXIT_BITMAP1</b> {0x201E_umx}</td></tr>
<tr class="memdesc:ae9c97ed4cf8e25413c5eeb97d9005427"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: eoi_exit_bitmap1 <br /></td></tr>
<tr class="separator:ae9c97ed4cf8e25413c5eeb97d9005427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939de42d5502263afac9e1d2135896b8"><td class="memItemLeft" align="right" valign="top"><a id="a939de42d5502263afac9e1d2135896b8" name="a939de42d5502263afac9e1d2135896b8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EOI_EXIT_BITMAP2</b> {0x2020_umx}</td></tr>
<tr class="memdesc:a939de42d5502263afac9e1d2135896b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: eoi_exit_bitmap2 <br /></td></tr>
<tr class="separator:a939de42d5502263afac9e1d2135896b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08f183f32a97b8671b57e6dab7fecad"><td class="memItemLeft" align="right" valign="top"><a id="af08f183f32a97b8671b57e6dab7fecad" name="af08f183f32a97b8671b57e6dab7fecad"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EOI_EXIT_BITMAP3</b> {0x2022_umx}</td></tr>
<tr class="memdesc:af08f183f32a97b8671b57e6dab7fecad"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: eoi_exit_bitmap3 <br /></td></tr>
<tr class="separator:af08f183f32a97b8671b57e6dab7fecad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92315c3e72517a1b906e1761c1860d9"><td class="memItemLeft" align="right" valign="top"><a id="ad92315c3e72517a1b906e1761c1860d9" name="ad92315c3e72517a1b906e1761c1860d9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EPTP_LIST_ADDRESS</b> {0x2024_umx}</td></tr>
<tr class="memdesc:ad92315c3e72517a1b906e1761c1860d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: eptp_list_address <br /></td></tr>
<tr class="separator:ad92315c3e72517a1b906e1761c1860d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c95300d8835b1a3f511f68196c18bc"><td class="memItemLeft" align="right" valign="top"><a id="a53c95300d8835b1a3f511f68196c18bc" name="a53c95300d8835b1a3f511f68196c18bc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMREAD_BITMAP_ADDRESS</b> {0x2026_umx}</td></tr>
<tr class="memdesc:a53c95300d8835b1a3f511f68196c18bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmread_bitmap_address <br /></td></tr>
<tr class="separator:a53c95300d8835b1a3f511f68196c18bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8413aff74fc62fa9b9f04d521d86685"><td class="memItemLeft" align="right" valign="top"><a id="ae8413aff74fc62fa9b9f04d521d86685" name="ae8413aff74fc62fa9b9f04d521d86685"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMWRITE_BITMAP_ADDRESS</b> {0x2028_umx}</td></tr>
<tr class="memdesc:ae8413aff74fc62fa9b9f04d521d86685"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmwrite_bitmap_address <br /></td></tr>
<tr class="separator:ae8413aff74fc62fa9b9f04d521d86685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb668dad749ace58c8d1886ec33d060"><td class="memItemLeft" align="right" valign="top"><a id="a5eb668dad749ace58c8d1886ec33d060" name="a5eb668dad749ace58c8d1886ec33d060"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VIRT_EXCEPTION_INFORMATION_ADDRESS</b> {0x202A_umx}</td></tr>
<tr class="memdesc:a5eb668dad749ace58c8d1886ec33d060"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: virt_exception_information_address <br /></td></tr>
<tr class="separator:a5eb668dad749ace58c8d1886ec33d060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59856e40531491f50c8f5394fe40d6be"><td class="memItemLeft" align="right" valign="top"><a id="a59856e40531491f50c8f5394fe40d6be" name="a59856e40531491f50c8f5394fe40d6be"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_XSS_EXITING_BITMAP</b> {0x202C_umx}</td></tr>
<tr class="memdesc:a59856e40531491f50c8f5394fe40d6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: xss_exiting_bitmap <br /></td></tr>
<tr class="separator:a59856e40531491f50c8f5394fe40d6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f34fb424ca60ee5ccadb16c6065779d"><td class="memItemLeft" align="right" valign="top"><a id="a7f34fb424ca60ee5ccadb16c6065779d" name="a7f34fb424ca60ee5ccadb16c6065779d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_ENCLS_EXITING_BITMAP</b> {0x202E_umx}</td></tr>
<tr class="memdesc:a7f34fb424ca60ee5ccadb16c6065779d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: encls_exiting_bitmap <br /></td></tr>
<tr class="separator:a7f34fb424ca60ee5ccadb16c6065779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0e6f4e7694525bb5a6a60ff250a256"><td class="memItemLeft" align="right" valign="top"><a id="aea0e6f4e7694525bb5a6a60ff250a256" name="aea0e6f4e7694525bb5a6a60ff250a256"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_SUB_PAGE_PERMISSION_TABLE_POINTER</b> {0x2030_umx}</td></tr>
<tr class="memdesc:aea0e6f4e7694525bb5a6a60ff250a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: sub_page_permission_table_pointer <br /></td></tr>
<tr class="separator:aea0e6f4e7694525bb5a6a60ff250a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e4b817d3f03f717008b1178392711b"><td class="memItemLeft" align="right" valign="top"><a id="a51e4b817d3f03f717008b1178392711b" name="a51e4b817d3f03f717008b1178392711b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_TSC_MULTIPLIER</b> {0x2032_umx}</td></tr>
<tr class="memdesc:a51e4b817d3f03f717008b1178392711b"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: tsc_multiplier <br /></td></tr>
<tr class="separator:a51e4b817d3f03f717008b1178392711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa953ebff70d1cce1e90bc29a0073d981"><td class="memItemLeft" align="right" valign="top"><a id="aa953ebff70d1cce1e90bc29a0073d981" name="aa953ebff70d1cce1e90bc29a0073d981"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_PHYSICAL_ADDRESS</b> {0x2400_umx}</td></tr>
<tr class="memdesc:aa953ebff70d1cce1e90bc29a0073d981"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_physical_address <br /></td></tr>
<tr class="separator:aa953ebff70d1cce1e90bc29a0073d981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce98c8edfd0bb7dd8ea9be6c503dc58"><td class="memItemLeft" align="right" valign="top"><a id="a6ce98c8edfd0bb7dd8ea9be6c503dc58" name="a6ce98c8edfd0bb7dd8ea9be6c503dc58"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMCS_LINK_POINTER</b> {0x2800_umx}</td></tr>
<tr class="memdesc:a6ce98c8edfd0bb7dd8ea9be6c503dc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmcs_link_pointer <br /></td></tr>
<tr class="separator:a6ce98c8edfd0bb7dd8ea9be6c503dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9cc67212da392ddc4ac1c284e4b985"><td class="memItemLeft" align="right" valign="top"><a id="aca9cc67212da392ddc4ac1c284e4b985" name="aca9cc67212da392ddc4ac1c284e4b985"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_DEBUGCTL</b> {0x2802_umx}</td></tr>
<tr class="memdesc:aca9cc67212da392ddc4ac1c284e4b985"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_debugctl <br /></td></tr>
<tr class="separator:aca9cc67212da392ddc4ac1c284e4b985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563336a524d7c1fa3a5096475c0f14af"><td class="memItemLeft" align="right" valign="top"><a id="a563336a524d7c1fa3a5096475c0f14af" name="a563336a524d7c1fa3a5096475c0f14af"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_PAT</b> {0x2804_umx}</td></tr>
<tr class="memdesc:a563336a524d7c1fa3a5096475c0f14af"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_pat <br /></td></tr>
<tr class="separator:a563336a524d7c1fa3a5096475c0f14af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb94b18c3a6d04b36709203ebe6f7b9b"><td class="memItemLeft" align="right" valign="top"><a id="abb94b18c3a6d04b36709203ebe6f7b9b" name="abb94b18c3a6d04b36709203ebe6f7b9b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_EFER</b> {0x2806_umx}</td></tr>
<tr class="memdesc:abb94b18c3a6d04b36709203ebe6f7b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_efer <br /></td></tr>
<tr class="separator:abb94b18c3a6d04b36709203ebe6f7b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69c566de31ce623aa3948393dccaf2c"><td class="memItemLeft" align="right" valign="top"><a id="ae69c566de31ce623aa3948393dccaf2c" name="ae69c566de31ce623aa3948393dccaf2c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_PERF_GLOBAL_CTRL</b> {0x2808_umx}</td></tr>
<tr class="memdesc:ae69c566de31ce623aa3948393dccaf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_perf_global_ctrl <br /></td></tr>
<tr class="separator:ae69c566de31ce623aa3948393dccaf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a60b20515415a830701f6cfe565e50"><td class="memItemLeft" align="right" valign="top"><a id="a65a60b20515415a830701f6cfe565e50" name="a65a60b20515415a830701f6cfe565e50"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_PDPTE0</b> {0x280A_umx}</td></tr>
<tr class="memdesc:a65a60b20515415a830701f6cfe565e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_pdpte0 <br /></td></tr>
<tr class="separator:a65a60b20515415a830701f6cfe565e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613b9c47252698aa5d0c64dcef32f036"><td class="memItemLeft" align="right" valign="top"><a id="a613b9c47252698aa5d0c64dcef32f036" name="a613b9c47252698aa5d0c64dcef32f036"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_PDPTE1</b> {0x280C_umx}</td></tr>
<tr class="memdesc:a613b9c47252698aa5d0c64dcef32f036"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_pdpte1 <br /></td></tr>
<tr class="separator:a613b9c47252698aa5d0c64dcef32f036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168c0d83b8430323b6f47326275df1ea"><td class="memItemLeft" align="right" valign="top"><a id="a168c0d83b8430323b6f47326275df1ea" name="a168c0d83b8430323b6f47326275df1ea"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_PDPTE2</b> {0x280E_umx}</td></tr>
<tr class="memdesc:a168c0d83b8430323b6f47326275df1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_pdpte2 <br /></td></tr>
<tr class="separator:a168c0d83b8430323b6f47326275df1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60c688c82cad09a5223ab6d27692a60"><td class="memItemLeft" align="right" valign="top"><a id="af60c688c82cad09a5223ab6d27692a60" name="af60c688c82cad09a5223ab6d27692a60"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_PDPTE3</b> {0x2810_umx}</td></tr>
<tr class="memdesc:af60c688c82cad09a5223ab6d27692a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_pdpte3 <br /></td></tr>
<tr class="separator:af60c688c82cad09a5223ab6d27692a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee59ac69ec52f70016d77a155ac97e03"><td class="memItemLeft" align="right" valign="top"><a id="aee59ac69ec52f70016d77a155ac97e03" name="aee59ac69ec52f70016d77a155ac97e03"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_BNDCFGS</b> {0x2812_umx}</td></tr>
<tr class="memdesc:aee59ac69ec52f70016d77a155ac97e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_bndcfgs <br /></td></tr>
<tr class="separator:aee59ac69ec52f70016d77a155ac97e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7310b0e9c458f6955ef86f34571ce6"><td class="memItemLeft" align="right" valign="top"><a id="aec7310b0e9c458f6955ef86f34571ce6" name="aec7310b0e9c458f6955ef86f34571ce6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_RTIT_CTL</b> {0x2814_umx}</td></tr>
<tr class="memdesc:aec7310b0e9c458f6955ef86f34571ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_rtit_ctl <br /></td></tr>
<tr class="separator:aec7310b0e9c458f6955ef86f34571ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a441076c93db0a327608fab8400e40"><td class="memItemLeft" align="right" valign="top"><a id="a93a441076c93db0a327608fab8400e40" name="a93a441076c93db0a327608fab8400e40"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_PAT</b> {0x2C00_umx}</td></tr>
<tr class="memdesc:a93a441076c93db0a327608fab8400e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_pat <br /></td></tr>
<tr class="separator:a93a441076c93db0a327608fab8400e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8833cd18de1c82aa7c01585a4c3d8e1f"><td class="memItemLeft" align="right" valign="top"><a id="a8833cd18de1c82aa7c01585a4c3d8e1f" name="a8833cd18de1c82aa7c01585a4c3d8e1f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_EFER</b> {0x2C02_umx}</td></tr>
<tr class="memdesc:a8833cd18de1c82aa7c01585a4c3d8e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_efer <br /></td></tr>
<tr class="separator:a8833cd18de1c82aa7c01585a4c3d8e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cca1deb35e0e9ea269a8fd3ed58cad8"><td class="memItemLeft" align="right" valign="top"><a id="a5cca1deb35e0e9ea269a8fd3ed58cad8" name="a5cca1deb35e0e9ea269a8fd3ed58cad8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_PERF_GLOBAL_CTRL</b> {0x2C04_umx}</td></tr>
<tr class="memdesc:a5cca1deb35e0e9ea269a8fd3ed58cad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_perf_global_ctrl <br /></td></tr>
<tr class="separator:a5cca1deb35e0e9ea269a8fd3ed58cad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2a57fc631c4d928ddb11ad0252a91a"><td class="memItemLeft" align="right" valign="top"><a id="aae2a57fc631c4d928ddb11ad0252a91a" name="aae2a57fc631c4d928ddb11ad0252a91a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_PIN_BASED_VM_EXECUTION_CTLS</b> {0x4000_umx}</td></tr>
<tr class="memdesc:aae2a57fc631c4d928ddb11ad0252a91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: pin_based_vm_execution_ctls <br /></td></tr>
<tr class="separator:aae2a57fc631c4d928ddb11ad0252a91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fd02e0c7b5d17addb05ade8ac5ebbd"><td class="memItemLeft" align="right" valign="top"><a id="ae2fd02e0c7b5d17addb05ade8ac5ebbd" name="ae2fd02e0c7b5d17addb05ade8ac5ebbd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_PRIMARY_PROC_BASED_VM_EXECUTION_CTLS</b> {0x4002_umx}</td></tr>
<tr class="memdesc:ae2fd02e0c7b5d17addb05ade8ac5ebbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: primary_proc_based_vm_execution_ctls <br /></td></tr>
<tr class="separator:ae2fd02e0c7b5d17addb05ade8ac5ebbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb10975575225f2f712c23ce4d37188d"><td class="memItemLeft" align="right" valign="top"><a id="aeb10975575225f2f712c23ce4d37188d" name="aeb10975575225f2f712c23ce4d37188d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EXCEPTION_BITMAP</b> {0x4004_umx}</td></tr>
<tr class="memdesc:aeb10975575225f2f712c23ce4d37188d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: exception_bitmap <br /></td></tr>
<tr class="separator:aeb10975575225f2f712c23ce4d37188d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac580aed08550e6cbcbc83158794329be"><td class="memItemLeft" align="right" valign="top"><a id="ac580aed08550e6cbcbc83158794329be" name="ac580aed08550e6cbcbc83158794329be"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_PAGE_FAULT_ERROR_CODE_MASK</b> {0x4006_umx}</td></tr>
<tr class="memdesc:ac580aed08550e6cbcbc83158794329be"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: page_fault_error_code_mask <br /></td></tr>
<tr class="separator:ac580aed08550e6cbcbc83158794329be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e872892e78ca0bf87f577bfcdfd7985"><td class="memItemLeft" align="right" valign="top"><a id="a0e872892e78ca0bf87f577bfcdfd7985" name="a0e872892e78ca0bf87f577bfcdfd7985"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_PAGE_FAULT_ERROR_CODE_MATCH</b> {0x4008_umx}</td></tr>
<tr class="memdesc:a0e872892e78ca0bf87f577bfcdfd7985"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: page_fault_error_code_match <br /></td></tr>
<tr class="separator:a0e872892e78ca0bf87f577bfcdfd7985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2eee347eb81724c803da7736c8dd54"><td class="memItemLeft" align="right" valign="top"><a id="a3f2eee347eb81724c803da7736c8dd54" name="a3f2eee347eb81724c803da7736c8dd54"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR3_TARGET_COUNT</b> {0x400A_umx}</td></tr>
<tr class="memdesc:a3f2eee347eb81724c803da7736c8dd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr3_target_count <br /></td></tr>
<tr class="separator:a3f2eee347eb81724c803da7736c8dd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26eb615b3d80de6dcbfa31251fe7803"><td class="memItemLeft" align="right" valign="top"><a id="ae26eb615b3d80de6dcbfa31251fe7803" name="ae26eb615b3d80de6dcbfa31251fe7803"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_CTLS</b> {0x400C_umx}</td></tr>
<tr class="memdesc:ae26eb615b3d80de6dcbfa31251fe7803"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_ctls <br /></td></tr>
<tr class="separator:ae26eb615b3d80de6dcbfa31251fe7803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d66075a27c402fb994ea117c9b028d"><td class="memItemLeft" align="right" valign="top"><a id="ab0d66075a27c402fb994ea117c9b028d" name="ab0d66075a27c402fb994ea117c9b028d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_MSR_STORE_COUNT</b> {0x400E_umx}</td></tr>
<tr class="memdesc:ab0d66075a27c402fb994ea117c9b028d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_msr_store_count <br /></td></tr>
<tr class="separator:ab0d66075a27c402fb994ea117c9b028d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b9321079a2ca5d18fff6baacab305d"><td class="memItemLeft" align="right" valign="top"><a id="a51b9321079a2ca5d18fff6baacab305d" name="a51b9321079a2ca5d18fff6baacab305d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_MSR_LOAD_COUNT</b> {0x4010_umx}</td></tr>
<tr class="memdesc:a51b9321079a2ca5d18fff6baacab305d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_msr_load_count <br /></td></tr>
<tr class="separator:a51b9321079a2ca5d18fff6baacab305d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d448dd6f351c5b7db9dc052bdb1a917"><td class="memItemLeft" align="right" valign="top"><a id="a7d448dd6f351c5b7db9dc052bdb1a917" name="a7d448dd6f351c5b7db9dc052bdb1a917"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMENTRY_CTLS</b> {0x4012_umx}</td></tr>
<tr class="memdesc:a7d448dd6f351c5b7db9dc052bdb1a917"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmentry_ctls <br /></td></tr>
<tr class="separator:a7d448dd6f351c5b7db9dc052bdb1a917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4b32d4db8810e19443fe096ea2a4f1"><td class="memItemLeft" align="right" valign="top"><a id="a4f4b32d4db8810e19443fe096ea2a4f1" name="a4f4b32d4db8810e19443fe096ea2a4f1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMENTRY_MSR_LOAD_COUNT</b> {0x4014_umx}</td></tr>
<tr class="memdesc:a4f4b32d4db8810e19443fe096ea2a4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmentry_msr_load_count <br /></td></tr>
<tr class="separator:a4f4b32d4db8810e19443fe096ea2a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4886159f6951c8fc2e4a81c1b25c2d97"><td class="memItemLeft" align="right" valign="top"><a id="a4886159f6951c8fc2e4a81c1b25c2d97" name="a4886159f6951c8fc2e4a81c1b25c2d97"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMENTRY_INTERRUPT_INFORMATION_FIELD</b> {0x4016_umx}</td></tr>
<tr class="memdesc:a4886159f6951c8fc2e4a81c1b25c2d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmentry_interrupt_information_field <br /></td></tr>
<tr class="separator:a4886159f6951c8fc2e4a81c1b25c2d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c283334df1e2a267ce76904b59c10a4"><td class="memItemLeft" align="right" valign="top"><a id="a0c283334df1e2a267ce76904b59c10a4" name="a0c283334df1e2a267ce76904b59c10a4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMENTRY_EXCEPTION_ERROR_CODE</b> {0x4018_umx}</td></tr>
<tr class="memdesc:a0c283334df1e2a267ce76904b59c10a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmentry_exception_error_code <br /></td></tr>
<tr class="separator:a0c283334df1e2a267ce76904b59c10a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b584dbbc15b77fc504f7ae2a50fc29"><td class="memItemLeft" align="right" valign="top"><a id="a11b584dbbc15b77fc504f7ae2a50fc29" name="a11b584dbbc15b77fc504f7ae2a50fc29"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMENTRY_INSTRUCTION_LENGTH</b> {0x401A_umx}</td></tr>
<tr class="memdesc:a11b584dbbc15b77fc504f7ae2a50fc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmentry_instruction_length <br /></td></tr>
<tr class="separator:a11b584dbbc15b77fc504f7ae2a50fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f4b26a39a2f59c783d2cfd077f9581"><td class="memItemLeft" align="right" valign="top"><a id="ad7f4b26a39a2f59c783d2cfd077f9581" name="ad7f4b26a39a2f59c783d2cfd077f9581"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_TPR_THRESHOLD</b> {0x401C_umx}</td></tr>
<tr class="memdesc:ad7f4b26a39a2f59c783d2cfd077f9581"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: tpr_threshold <br /></td></tr>
<tr class="separator:ad7f4b26a39a2f59c783d2cfd077f9581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6149ccccba5abc66208f510a9527582"><td class="memItemLeft" align="right" valign="top"><a id="ae6149ccccba5abc66208f510a9527582" name="ae6149ccccba5abc66208f510a9527582"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_SECONDARY_PROC_BASED_VM_EXECUTION_CTLS</b> {0x401E_umx}</td></tr>
<tr class="memdesc:ae6149ccccba5abc66208f510a9527582"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: secondary_proc_based_vm_execution_ctls <br /></td></tr>
<tr class="separator:ae6149ccccba5abc66208f510a9527582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4956e57fd558fd2c82e5940d6ae09482"><td class="memItemLeft" align="right" valign="top"><a id="a4956e57fd558fd2c82e5940d6ae09482" name="a4956e57fd558fd2c82e5940d6ae09482"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_PLE_GAP</b> {0x4020_umx}</td></tr>
<tr class="memdesc:a4956e57fd558fd2c82e5940d6ae09482"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: ple_gap <br /></td></tr>
<tr class="separator:a4956e57fd558fd2c82e5940d6ae09482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9999da425706df0f89c625c5ceabe3ba"><td class="memItemLeft" align="right" valign="top"><a id="a9999da425706df0f89c625c5ceabe3ba" name="a9999da425706df0f89c625c5ceabe3ba"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_PLE_WINDOW</b> {0x4022_umx}</td></tr>
<tr class="memdesc:a9999da425706df0f89c625c5ceabe3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: ple_window <br /></td></tr>
<tr class="separator:a9999da425706df0f89c625c5ceabe3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf26a9be5234ef4251692a3ae53aaff1"><td class="memItemLeft" align="right" valign="top"><a id="aaf26a9be5234ef4251692a3ae53aaff1" name="aaf26a9be5234ef4251692a3ae53aaff1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VM_INSTRUCTION_ERROR</b> {0x4400_umx}</td></tr>
<tr class="memdesc:aaf26a9be5234ef4251692a3ae53aaff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vm_instruction_error <br /></td></tr>
<tr class="separator:aaf26a9be5234ef4251692a3ae53aaff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16812ed643cbdf2e406c5f9091bb2105"><td class="memItemLeft" align="right" valign="top"><a id="a16812ed643cbdf2e406c5f9091bb2105" name="a16812ed643cbdf2e406c5f9091bb2105"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EXIT_REASON</b> {0x4402_umx}</td></tr>
<tr class="memdesc:a16812ed643cbdf2e406c5f9091bb2105"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: exit_reason <br /></td></tr>
<tr class="separator:a16812ed643cbdf2e406c5f9091bb2105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580e2e02eb4c1e279f365b1209830c90"><td class="memItemLeft" align="right" valign="top"><a id="a580e2e02eb4c1e279f365b1209830c90" name="a580e2e02eb4c1e279f365b1209830c90"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_INTERRUPTION_INFORMATION</b> {0x4404_umx}</td></tr>
<tr class="memdesc:a580e2e02eb4c1e279f365b1209830c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_interruption_information <br /></td></tr>
<tr class="separator:a580e2e02eb4c1e279f365b1209830c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fea73f04df432e0f78c165c6c5476d"><td class="memItemLeft" align="right" valign="top"><a id="a68fea73f04df432e0f78c165c6c5476d" name="a68fea73f04df432e0f78c165c6c5476d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_INTERRUPTION_ERROR_CODE</b> {0x4406_umx}</td></tr>
<tr class="memdesc:a68fea73f04df432e0f78c165c6c5476d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_interruption_error_code <br /></td></tr>
<tr class="separator:a68fea73f04df432e0f78c165c6c5476d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285ebb09e34a5debcfb44e6bc6b2711e"><td class="memItemLeft" align="right" valign="top"><a id="a285ebb09e34a5debcfb44e6bc6b2711e" name="a285ebb09e34a5debcfb44e6bc6b2711e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_IDT_VECTORING_INFORMATION_FIELD</b> {0x4408_umx}</td></tr>
<tr class="memdesc:a285ebb09e34a5debcfb44e6bc6b2711e"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: idt_vectoring_information_field <br /></td></tr>
<tr class="separator:a285ebb09e34a5debcfb44e6bc6b2711e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cdfd205664d17b0d998851a01eb3f7"><td class="memItemLeft" align="right" valign="top"><a id="ab0cdfd205664d17b0d998851a01eb3f7" name="ab0cdfd205664d17b0d998851a01eb3f7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_IDT_VECTORING_ERROR_CODE</b> {0x440A_umx}</td></tr>
<tr class="memdesc:ab0cdfd205664d17b0d998851a01eb3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: idt_vectoring_error_code <br /></td></tr>
<tr class="separator:ab0cdfd205664d17b0d998851a01eb3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e6e3b5bb2dbe5f326993b3c9d0c5a9"><td class="memItemLeft" align="right" valign="top"><a id="a08e6e3b5bb2dbe5f326993b3c9d0c5a9" name="a08e6e3b5bb2dbe5f326993b3c9d0c5a9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_INSTRUCTION_LENGTH</b> {0x440C_umx}</td></tr>
<tr class="memdesc:a08e6e3b5bb2dbe5f326993b3c9d0c5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_instruction_length <br /></td></tr>
<tr class="separator:a08e6e3b5bb2dbe5f326993b3c9d0c5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98ddf0701d4b471441e129b015518bd"><td class="memItemLeft" align="right" valign="top"><a id="ac98ddf0701d4b471441e129b015518bd" name="ac98ddf0701d4b471441e129b015518bd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMEXIT_INSTRUCTION_INFORMATION</b> {0x440E_umx}</td></tr>
<tr class="memdesc:ac98ddf0701d4b471441e129b015518bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmexit_instruction_information <br /></td></tr>
<tr class="separator:ac98ddf0701d4b471441e129b015518bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a741f7ee853daa6038305b769cfb14"><td class="memItemLeft" align="right" valign="top"><a id="ac4a741f7ee853daa6038305b769cfb14" name="ac4a741f7ee853daa6038305b769cfb14"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_ES_LIMIT</b> {0x4800_umx}</td></tr>
<tr class="memdesc:ac4a741f7ee853daa6038305b769cfb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_es_limit <br /></td></tr>
<tr class="separator:ac4a741f7ee853daa6038305b769cfb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad39f397220b19886ad18143eb92793d"><td class="memItemLeft" align="right" valign="top"><a id="aad39f397220b19886ad18143eb92793d" name="aad39f397220b19886ad18143eb92793d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_CS_LIMIT</b> {0x4802_umx}</td></tr>
<tr class="memdesc:aad39f397220b19886ad18143eb92793d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_cs_limit <br /></td></tr>
<tr class="separator:aad39f397220b19886ad18143eb92793d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d93165bb999f6bfb0059dea882e32b1"><td class="memItemLeft" align="right" valign="top"><a id="a8d93165bb999f6bfb0059dea882e32b1" name="a8d93165bb999f6bfb0059dea882e32b1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_SS_LIMIT</b> {0x4804_umx}</td></tr>
<tr class="memdesc:a8d93165bb999f6bfb0059dea882e32b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ss_limit <br /></td></tr>
<tr class="separator:a8d93165bb999f6bfb0059dea882e32b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270517c25fe7c3d0f5162855c43a34ee"><td class="memItemLeft" align="right" valign="top"><a id="a270517c25fe7c3d0f5162855c43a34ee" name="a270517c25fe7c3d0f5162855c43a34ee"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_DS_LIMIT</b> {0x4806_umx}</td></tr>
<tr class="memdesc:a270517c25fe7c3d0f5162855c43a34ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ds_limit <br /></td></tr>
<tr class="separator:a270517c25fe7c3d0f5162855c43a34ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03edccb4fcb0fe542fbc7a6eccf51db1"><td class="memItemLeft" align="right" valign="top"><a id="a03edccb4fcb0fe542fbc7a6eccf51db1" name="a03edccb4fcb0fe542fbc7a6eccf51db1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_FS_LIMIT</b> {0x4808_umx}</td></tr>
<tr class="memdesc:a03edccb4fcb0fe542fbc7a6eccf51db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_fs_limit <br /></td></tr>
<tr class="separator:a03edccb4fcb0fe542fbc7a6eccf51db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87de827de4bd49e8cbbabaaba316adc"><td class="memItemLeft" align="right" valign="top"><a id="ab87de827de4bd49e8cbbabaaba316adc" name="ab87de827de4bd49e8cbbabaaba316adc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_GS_LIMIT</b> {0x480A_umx}</td></tr>
<tr class="memdesc:ab87de827de4bd49e8cbbabaaba316adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_gs_limit <br /></td></tr>
<tr class="separator:ab87de827de4bd49e8cbbabaaba316adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9094e7e77b86e3670e7001117cbbcd2f"><td class="memItemLeft" align="right" valign="top"><a id="a9094e7e77b86e3670e7001117cbbcd2f" name="a9094e7e77b86e3670e7001117cbbcd2f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_LDTR_LIMIT</b> {0x480C_umx}</td></tr>
<tr class="memdesc:a9094e7e77b86e3670e7001117cbbcd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ldtr_limit <br /></td></tr>
<tr class="separator:a9094e7e77b86e3670e7001117cbbcd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e9132a41b4bc438f1c1e4d9f1d02cc"><td class="memItemLeft" align="right" valign="top"><a id="ad0e9132a41b4bc438f1c1e4d9f1d02cc" name="ad0e9132a41b4bc438f1c1e4d9f1d02cc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_TR_LIMIT</b> {0x480E_umx}</td></tr>
<tr class="memdesc:ad0e9132a41b4bc438f1c1e4d9f1d02cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_tr_limit <br /></td></tr>
<tr class="separator:ad0e9132a41b4bc438f1c1e4d9f1d02cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a303a38a05fa62709fcedbe11906c7"><td class="memItemLeft" align="right" valign="top"><a id="a87a303a38a05fa62709fcedbe11906c7" name="a87a303a38a05fa62709fcedbe11906c7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_GDTR_LIMIT</b> {0x4810_umx}</td></tr>
<tr class="memdesc:a87a303a38a05fa62709fcedbe11906c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_gdtr_limit <br /></td></tr>
<tr class="separator:a87a303a38a05fa62709fcedbe11906c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40ec331cad90733e1ff6a77450b21cc"><td class="memItemLeft" align="right" valign="top"><a id="ae40ec331cad90733e1ff6a77450b21cc" name="ae40ec331cad90733e1ff6a77450b21cc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_IDTR_LIMIT</b> {0x4812_umx}</td></tr>
<tr class="memdesc:ae40ec331cad90733e1ff6a77450b21cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_idtr_limit <br /></td></tr>
<tr class="separator:ae40ec331cad90733e1ff6a77450b21cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e1f79b2bf88f64f9d221fbef9147d5"><td class="memItemLeft" align="right" valign="top"><a id="ab3e1f79b2bf88f64f9d221fbef9147d5" name="ab3e1f79b2bf88f64f9d221fbef9147d5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_ES_ACCESS_RIGHTS</b> {0x4814_umx}</td></tr>
<tr class="memdesc:ab3e1f79b2bf88f64f9d221fbef9147d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_es_access_rights <br /></td></tr>
<tr class="separator:ab3e1f79b2bf88f64f9d221fbef9147d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d175b674de7e1b098b2ab845654a22"><td class="memItemLeft" align="right" valign="top"><a id="aa4d175b674de7e1b098b2ab845654a22" name="aa4d175b674de7e1b098b2ab845654a22"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_CS_ACCESS_RIGHTS</b> {0x4816_umx}</td></tr>
<tr class="memdesc:aa4d175b674de7e1b098b2ab845654a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_cs_access_rights <br /></td></tr>
<tr class="separator:aa4d175b674de7e1b098b2ab845654a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c8274480c27fc74adb2dd1a012dab2"><td class="memItemLeft" align="right" valign="top"><a id="af4c8274480c27fc74adb2dd1a012dab2" name="af4c8274480c27fc74adb2dd1a012dab2"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_SS_ACCESS_RIGHTS</b> {0x4818_umx}</td></tr>
<tr class="memdesc:af4c8274480c27fc74adb2dd1a012dab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ss_access_rights <br /></td></tr>
<tr class="separator:af4c8274480c27fc74adb2dd1a012dab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25608ee30e036283034cb947aaa750d8"><td class="memItemLeft" align="right" valign="top"><a id="a25608ee30e036283034cb947aaa750d8" name="a25608ee30e036283034cb947aaa750d8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_DS_ACCESS_RIGHTS</b> {0x481A_umx}</td></tr>
<tr class="memdesc:a25608ee30e036283034cb947aaa750d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ds_access_rights <br /></td></tr>
<tr class="separator:a25608ee30e036283034cb947aaa750d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ef6e3a76556e1315a16d12340cf9cd"><td class="memItemLeft" align="right" valign="top"><a id="a93ef6e3a76556e1315a16d12340cf9cd" name="a93ef6e3a76556e1315a16d12340cf9cd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_FS_ACCESS_RIGHTS</b> {0x481C_umx}</td></tr>
<tr class="memdesc:a93ef6e3a76556e1315a16d12340cf9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_fs_access_rights <br /></td></tr>
<tr class="separator:a93ef6e3a76556e1315a16d12340cf9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f88058d01378d83b26b16af39d7e26"><td class="memItemLeft" align="right" valign="top"><a id="a32f88058d01378d83b26b16af39d7e26" name="a32f88058d01378d83b26b16af39d7e26"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_GS_ACCESS_RIGHTS</b> {0x481E_umx}</td></tr>
<tr class="memdesc:a32f88058d01378d83b26b16af39d7e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_gs_access_rights <br /></td></tr>
<tr class="separator:a32f88058d01378d83b26b16af39d7e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20ddbb5b997f798bd4009e43e76fb2a"><td class="memItemLeft" align="right" valign="top"><a id="ad20ddbb5b997f798bd4009e43e76fb2a" name="ad20ddbb5b997f798bd4009e43e76fb2a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_LDTR_ACCESS_RIGHTS</b> {0x4820_umx}</td></tr>
<tr class="memdesc:ad20ddbb5b997f798bd4009e43e76fb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ldtr_access_rights <br /></td></tr>
<tr class="separator:ad20ddbb5b997f798bd4009e43e76fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629e2f614562196a921377c778d0120e"><td class="memItemLeft" align="right" valign="top"><a id="a629e2f614562196a921377c778d0120e" name="a629e2f614562196a921377c778d0120e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_TR_ACCESS_RIGHTS</b> {0x4822_umx}</td></tr>
<tr class="memdesc:a629e2f614562196a921377c778d0120e"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_tr_access_rights <br /></td></tr>
<tr class="separator:a629e2f614562196a921377c778d0120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00edbc4dc2a0d54441da9d3d65cadbe2"><td class="memItemLeft" align="right" valign="top"><a id="a00edbc4dc2a0d54441da9d3d65cadbe2" name="a00edbc4dc2a0d54441da9d3d65cadbe2"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_INTERRUPTIBILITY_STATE</b> {0x4824_umx}</td></tr>
<tr class="memdesc:a00edbc4dc2a0d54441da9d3d65cadbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_interruptibility_state <br /></td></tr>
<tr class="separator:a00edbc4dc2a0d54441da9d3d65cadbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ba34a5748a4dead1c845654e3b043f"><td class="memItemLeft" align="right" valign="top"><a id="a90ba34a5748a4dead1c845654e3b043f" name="a90ba34a5748a4dead1c845654e3b043f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_ACTIVITY_STATE</b> {0x4826_umx}</td></tr>
<tr class="memdesc:a90ba34a5748a4dead1c845654e3b043f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_activity_state <br /></td></tr>
<tr class="separator:a90ba34a5748a4dead1c845654e3b043f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d28da6e065ee38783c397d360d53a5f"><td class="memItemLeft" align="right" valign="top"><a id="a0d28da6e065ee38783c397d360d53a5f" name="a0d28da6e065ee38783c397d360d53a5f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_SMBASE</b> {0x4828_umx}</td></tr>
<tr class="memdesc:a0d28da6e065ee38783c397d360d53a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_smbase <br /></td></tr>
<tr class="separator:a0d28da6e065ee38783c397d360d53a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bf1d31e9c07e8bbc719e3880de7f7a"><td class="memItemLeft" align="right" valign="top"><a id="ab6bf1d31e9c07e8bbc719e3880de7f7a" name="ab6bf1d31e9c07e8bbc719e3880de7f7a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_SYSENTER_CS</b> {0x482A_umx}</td></tr>
<tr class="memdesc:ab6bf1d31e9c07e8bbc719e3880de7f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_sysenter_cs <br /></td></tr>
<tr class="separator:ab6bf1d31e9c07e8bbc719e3880de7f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8695251851519b155013d25337592f1f"><td class="memItemLeft" align="right" valign="top"><a id="a8695251851519b155013d25337592f1f" name="a8695251851519b155013d25337592f1f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_VMX_PREEMPTION_TIMER_VALUE</b> {0x482E_umx}</td></tr>
<tr class="memdesc:a8695251851519b155013d25337592f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: vmx_preemption_timer_value <br /></td></tr>
<tr class="separator:a8695251851519b155013d25337592f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a42022fb74210b5b14271846130b0aa"><td class="memItemLeft" align="right" valign="top"><a id="a3a42022fb74210b5b14271846130b0aa" name="a3a42022fb74210b5b14271846130b0aa"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_SYSENTER_CS</b> {0x4C00_umx}</td></tr>
<tr class="memdesc:a3a42022fb74210b5b14271846130b0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_sysenter_cs <br /></td></tr>
<tr class="separator:a3a42022fb74210b5b14271846130b0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5469385e2741a1fa7171313559e4b5ea"><td class="memItemLeft" align="right" valign="top"><a id="a5469385e2741a1fa7171313559e4b5ea" name="a5469385e2741a1fa7171313559e4b5ea"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR0_GUEST_HOST_MASK</b> {0x6000_umx}</td></tr>
<tr class="memdesc:a5469385e2741a1fa7171313559e4b5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr0_guest_host_mask <br /></td></tr>
<tr class="separator:a5469385e2741a1fa7171313559e4b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1506dc6b0f8154fbef840bfd0b9fd548"><td class="memItemLeft" align="right" valign="top"><a id="a1506dc6b0f8154fbef840bfd0b9fd548" name="a1506dc6b0f8154fbef840bfd0b9fd548"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR4_GUEST_HOST_MASK</b> {0x6002_umx}</td></tr>
<tr class="memdesc:a1506dc6b0f8154fbef840bfd0b9fd548"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr4_guest_host_mask <br /></td></tr>
<tr class="separator:a1506dc6b0f8154fbef840bfd0b9fd548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6430e7ffcf5e9c78ca2e743143726020"><td class="memItemLeft" align="right" valign="top"><a id="a6430e7ffcf5e9c78ca2e743143726020" name="a6430e7ffcf5e9c78ca2e743143726020"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR0_READ_SHADOW</b> {0x6004_umx}</td></tr>
<tr class="memdesc:a6430e7ffcf5e9c78ca2e743143726020"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr0_read_shadow <br /></td></tr>
<tr class="separator:a6430e7ffcf5e9c78ca2e743143726020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624dacdfece741c837c48bd22444fc88"><td class="memItemLeft" align="right" valign="top"><a id="a624dacdfece741c837c48bd22444fc88" name="a624dacdfece741c837c48bd22444fc88"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR4_READ_SHADOW</b> {0x6006_umx}</td></tr>
<tr class="memdesc:a624dacdfece741c837c48bd22444fc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr4_read_shadow <br /></td></tr>
<tr class="separator:a624dacdfece741c837c48bd22444fc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e67979e4005bb38bd9bca2ad527798"><td class="memItemLeft" align="right" valign="top"><a id="ae0e67979e4005bb38bd9bca2ad527798" name="ae0e67979e4005bb38bd9bca2ad527798"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR3_TARGET_VALUE0</b> {0x6008_umx}</td></tr>
<tr class="memdesc:ae0e67979e4005bb38bd9bca2ad527798"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr3_target_value0 <br /></td></tr>
<tr class="separator:ae0e67979e4005bb38bd9bca2ad527798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a9c151095f9b24bda05c7669c8908b"><td class="memItemLeft" align="right" valign="top"><a id="a13a9c151095f9b24bda05c7669c8908b" name="a13a9c151095f9b24bda05c7669c8908b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR3_TARGET_VALUE1</b> {0x600A_umx}</td></tr>
<tr class="memdesc:a13a9c151095f9b24bda05c7669c8908b"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr3_target_value1 <br /></td></tr>
<tr class="separator:a13a9c151095f9b24bda05c7669c8908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66b71264cb50b8d171e5577045f2e53"><td class="memItemLeft" align="right" valign="top"><a id="af66b71264cb50b8d171e5577045f2e53" name="af66b71264cb50b8d171e5577045f2e53"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR3_TARGET_VALUE2</b> {0x600C_umx}</td></tr>
<tr class="memdesc:af66b71264cb50b8d171e5577045f2e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr3_target_value2 <br /></td></tr>
<tr class="separator:af66b71264cb50b8d171e5577045f2e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5be308fe88bc1bab12dcc8671f08973"><td class="memItemLeft" align="right" valign="top"><a id="af5be308fe88bc1bab12dcc8671f08973" name="af5be308fe88bc1bab12dcc8671f08973"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_CR3_TARGET_VALUE3</b> {0x600E_umx}</td></tr>
<tr class="memdesc:af5be308fe88bc1bab12dcc8671f08973"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: cr3_target_value3 <br /></td></tr>
<tr class="separator:af5be308fe88bc1bab12dcc8671f08973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ef57df4f111b7602ea922b015cac11"><td class="memItemLeft" align="right" valign="top"><a id="ae2ef57df4f111b7602ea922b015cac11" name="ae2ef57df4f111b7602ea922b015cac11"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_EXIT_QUALIFICATION</b> {0x6400_umx}</td></tr>
<tr class="memdesc:ae2ef57df4f111b7602ea922b015cac11"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: exit_qualification <br /></td></tr>
<tr class="separator:ae2ef57df4f111b7602ea922b015cac11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b31a38015c984a4bdccb4845688a14f"><td class="memItemLeft" align="right" valign="top"><a id="a1b31a38015c984a4bdccb4845688a14f" name="a1b31a38015c984a4bdccb4845688a14f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_IO_RCX</b> {0x6402_umx}</td></tr>
<tr class="memdesc:a1b31a38015c984a4bdccb4845688a14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: io_rcx <br /></td></tr>
<tr class="separator:a1b31a38015c984a4bdccb4845688a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703bac376e6e545a14710bc9040d7bf9"><td class="memItemLeft" align="right" valign="top"><a id="a703bac376e6e545a14710bc9040d7bf9" name="a703bac376e6e545a14710bc9040d7bf9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_IO_RSI</b> {0x6404_umx}</td></tr>
<tr class="memdesc:a703bac376e6e545a14710bc9040d7bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: io_rsi <br /></td></tr>
<tr class="separator:a703bac376e6e545a14710bc9040d7bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7aee9e1ffae4f794cba833ee2e048f"><td class="memItemLeft" align="right" valign="top"><a id="a0c7aee9e1ffae4f794cba833ee2e048f" name="a0c7aee9e1ffae4f794cba833ee2e048f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_IO_RDI</b> {0x6406_umx}</td></tr>
<tr class="memdesc:a0c7aee9e1ffae4f794cba833ee2e048f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: io_rdi <br /></td></tr>
<tr class="separator:a0c7aee9e1ffae4f794cba833ee2e048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af329974fc0c293a720dbbf95f680245f"><td class="memItemLeft" align="right" valign="top"><a id="af329974fc0c293a720dbbf95f680245f" name="af329974fc0c293a720dbbf95f680245f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_IO_RIP</b> {0x6408_umx}</td></tr>
<tr class="memdesc:af329974fc0c293a720dbbf95f680245f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: io_rip <br /></td></tr>
<tr class="separator:af329974fc0c293a720dbbf95f680245f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad12c0fa630b7007e150acf82711b3a"><td class="memItemLeft" align="right" valign="top"><a id="a9ad12c0fa630b7007e150acf82711b3a" name="a9ad12c0fa630b7007e150acf82711b3a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_LINEAR_ADDRESS</b> {0x640A_umx}</td></tr>
<tr class="memdesc:a9ad12c0fa630b7007e150acf82711b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_linear_address <br /></td></tr>
<tr class="separator:a9ad12c0fa630b7007e150acf82711b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cc5696d873686d7f26d92282cc4654"><td class="memItemLeft" align="right" valign="top"><a id="ab8cc5696d873686d7f26d92282cc4654" name="ab8cc5696d873686d7f26d92282cc4654"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_CR0</b> {0x6800_umx}</td></tr>
<tr class="memdesc:ab8cc5696d873686d7f26d92282cc4654"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_cr0 <br /></td></tr>
<tr class="separator:ab8cc5696d873686d7f26d92282cc4654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5451e8fee62facc28691c3afb19cd46f"><td class="memItemLeft" align="right" valign="top"><a id="a5451e8fee62facc28691c3afb19cd46f" name="a5451e8fee62facc28691c3afb19cd46f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_CR3</b> {0x6802_umx}</td></tr>
<tr class="memdesc:a5451e8fee62facc28691c3afb19cd46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_cr3 <br /></td></tr>
<tr class="separator:a5451e8fee62facc28691c3afb19cd46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16c5def4faec0b712a3a4ad3cdc1fc1"><td class="memItemLeft" align="right" valign="top"><a id="af16c5def4faec0b712a3a4ad3cdc1fc1" name="af16c5def4faec0b712a3a4ad3cdc1fc1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_CR4</b> {0x6804_umx}</td></tr>
<tr class="memdesc:af16c5def4faec0b712a3a4ad3cdc1fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_cr4 <br /></td></tr>
<tr class="separator:af16c5def4faec0b712a3a4ad3cdc1fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7bf235d7dea8a2861e0713d1e1eb74"><td class="memItemLeft" align="right" valign="top"><a id="a1e7bf235d7dea8a2861e0713d1e1eb74" name="a1e7bf235d7dea8a2861e0713d1e1eb74"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_ES_BASE</b> {0x6806_umx}</td></tr>
<tr class="memdesc:a1e7bf235d7dea8a2861e0713d1e1eb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_es_base <br /></td></tr>
<tr class="separator:a1e7bf235d7dea8a2861e0713d1e1eb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bc0e7926abec525df17f8042fda966"><td class="memItemLeft" align="right" valign="top"><a id="a14bc0e7926abec525df17f8042fda966" name="a14bc0e7926abec525df17f8042fda966"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_CS_BASE</b> {0x6808_umx}</td></tr>
<tr class="memdesc:a14bc0e7926abec525df17f8042fda966"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_cs_base <br /></td></tr>
<tr class="separator:a14bc0e7926abec525df17f8042fda966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517a46509a0e8dabff72a08b774503dd"><td class="memItemLeft" align="right" valign="top"><a id="a517a46509a0e8dabff72a08b774503dd" name="a517a46509a0e8dabff72a08b774503dd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_SS_BASE</b> {0x680A_umx}</td></tr>
<tr class="memdesc:a517a46509a0e8dabff72a08b774503dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ss_base <br /></td></tr>
<tr class="separator:a517a46509a0e8dabff72a08b774503dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32511c8c6297daaf89fa11803949088"><td class="memItemLeft" align="right" valign="top"><a id="ab32511c8c6297daaf89fa11803949088" name="ab32511c8c6297daaf89fa11803949088"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_DS_BASE</b> {0x680C_umx}</td></tr>
<tr class="memdesc:ab32511c8c6297daaf89fa11803949088"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ds_base <br /></td></tr>
<tr class="separator:ab32511c8c6297daaf89fa11803949088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6519947f313bf7871b3a5bf0bf0210"><td class="memItemLeft" align="right" valign="top"><a id="a9c6519947f313bf7871b3a5bf0bf0210" name="a9c6519947f313bf7871b3a5bf0bf0210"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_FS_BASE</b> {0x680E_umx}</td></tr>
<tr class="memdesc:a9c6519947f313bf7871b3a5bf0bf0210"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_fs_base <br /></td></tr>
<tr class="separator:a9c6519947f313bf7871b3a5bf0bf0210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1120f27bc5ac54355f4c777c1baa45"><td class="memItemLeft" align="right" valign="top"><a id="aae1120f27bc5ac54355f4c777c1baa45" name="aae1120f27bc5ac54355f4c777c1baa45"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_GS_BASE</b> {0x6810_umx}</td></tr>
<tr class="memdesc:aae1120f27bc5ac54355f4c777c1baa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_gs_base <br /></td></tr>
<tr class="separator:aae1120f27bc5ac54355f4c777c1baa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b901c66c583545264888f1178501b0"><td class="memItemLeft" align="right" valign="top"><a id="af6b901c66c583545264888f1178501b0" name="af6b901c66c583545264888f1178501b0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_LDTR_BASE</b> {0x6812_umx}</td></tr>
<tr class="memdesc:af6b901c66c583545264888f1178501b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_ldtr_base <br /></td></tr>
<tr class="separator:af6b901c66c583545264888f1178501b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadc1524bb9314803dee25ca27018f2f"><td class="memItemLeft" align="right" valign="top"><a id="adadc1524bb9314803dee25ca27018f2f" name="adadc1524bb9314803dee25ca27018f2f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_TR_BASE</b> {0x6814_umx}</td></tr>
<tr class="memdesc:adadc1524bb9314803dee25ca27018f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_tr_base <br /></td></tr>
<tr class="separator:adadc1524bb9314803dee25ca27018f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60d8866b08241c6413ad9afd8fec310"><td class="memItemLeft" align="right" valign="top"><a id="ab60d8866b08241c6413ad9afd8fec310" name="ab60d8866b08241c6413ad9afd8fec310"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_GDTR_BASE</b> {0x6816_umx}</td></tr>
<tr class="memdesc:ab60d8866b08241c6413ad9afd8fec310"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_gdtr_base <br /></td></tr>
<tr class="separator:ab60d8866b08241c6413ad9afd8fec310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb3f2cbc2325dc84f112c064cffb805"><td class="memItemLeft" align="right" valign="top"><a id="a1cb3f2cbc2325dc84f112c064cffb805" name="a1cb3f2cbc2325dc84f112c064cffb805"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_IDTR_BASE</b> {0x6818_umx}</td></tr>
<tr class="memdesc:a1cb3f2cbc2325dc84f112c064cffb805"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_idtr_base <br /></td></tr>
<tr class="separator:a1cb3f2cbc2325dc84f112c064cffb805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a65f1a879d06b45611be60eadf311a3"><td class="memItemLeft" align="right" valign="top"><a id="a2a65f1a879d06b45611be60eadf311a3" name="a2a65f1a879d06b45611be60eadf311a3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_DR7</b> {0x681A_umx}</td></tr>
<tr class="memdesc:a2a65f1a879d06b45611be60eadf311a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_dr7 <br /></td></tr>
<tr class="separator:a2a65f1a879d06b45611be60eadf311a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e0e1b8e0b4686a71e7d205eb01677b"><td class="memItemLeft" align="right" valign="top"><a id="af1e0e1b8e0b4686a71e7d205eb01677b" name="af1e0e1b8e0b4686a71e7d205eb01677b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_RSP</b> {0x681C_umx}</td></tr>
<tr class="memdesc:af1e0e1b8e0b4686a71e7d205eb01677b"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_rsp <br /></td></tr>
<tr class="separator:af1e0e1b8e0b4686a71e7d205eb01677b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bac9f0d1fcb1476b479c00d338b4ba7"><td class="memItemLeft" align="right" valign="top"><a id="a1bac9f0d1fcb1476b479c00d338b4ba7" name="a1bac9f0d1fcb1476b479c00d338b4ba7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_RIP</b> {0x681E_umx}</td></tr>
<tr class="memdesc:a1bac9f0d1fcb1476b479c00d338b4ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_rip <br /></td></tr>
<tr class="separator:a1bac9f0d1fcb1476b479c00d338b4ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbd6bb5f51989a9a98d77d859b23c46"><td class="memItemLeft" align="right" valign="top"><a id="a7dbd6bb5f51989a9a98d77d859b23c46" name="a7dbd6bb5f51989a9a98d77d859b23c46"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_RFLAGS</b> {0x6820_umx}</td></tr>
<tr class="memdesc:a7dbd6bb5f51989a9a98d77d859b23c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_rflags <br /></td></tr>
<tr class="separator:a7dbd6bb5f51989a9a98d77d859b23c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0378a29aacf7ddaf749b7dbb3d8d3017"><td class="memItemLeft" align="right" valign="top"><a id="a0378a29aacf7ddaf749b7dbb3d8d3017" name="a0378a29aacf7ddaf749b7dbb3d8d3017"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS</b> {0x6822_umx}</td></tr>
<tr class="memdesc:a0378a29aacf7ddaf749b7dbb3d8d3017"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_pending_debug_exceptions <br /></td></tr>
<tr class="separator:a0378a29aacf7ddaf749b7dbb3d8d3017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea173045a85986f1a043e10cb6e4b6f0"><td class="memItemLeft" align="right" valign="top"><a id="aea173045a85986f1a043e10cb6e4b6f0" name="aea173045a85986f1a043e10cb6e4b6f0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_SYSENTER_ESP</b> {0x6824_umx}</td></tr>
<tr class="memdesc:aea173045a85986f1a043e10cb6e4b6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_sysenter_esp <br /></td></tr>
<tr class="separator:aea173045a85986f1a043e10cb6e4b6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7201b60b4566ee04ff8747067f53742"><td class="memItemLeft" align="right" valign="top"><a id="ae7201b60b4566ee04ff8747067f53742" name="ae7201b60b4566ee04ff8747067f53742"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_GUEST_SYSENTER_EIP</b> {0x6826_umx}</td></tr>
<tr class="memdesc:ae7201b60b4566ee04ff8747067f53742"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: guest_sysenter_eip <br /></td></tr>
<tr class="separator:ae7201b60b4566ee04ff8747067f53742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fbadfba27e99a23c15c1174b36ee32"><td class="memItemLeft" align="right" valign="top"><a id="af7fbadfba27e99a23c15c1174b36ee32" name="af7fbadfba27e99a23c15c1174b36ee32"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_CR0</b> {0x6C00_umx}</td></tr>
<tr class="memdesc:af7fbadfba27e99a23c15c1174b36ee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_cr0 <br /></td></tr>
<tr class="separator:af7fbadfba27e99a23c15c1174b36ee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896f313fc39eb9c4835037ade5bfd20"><td class="memItemLeft" align="right" valign="top"><a id="a6896f313fc39eb9c4835037ade5bfd20" name="a6896f313fc39eb9c4835037ade5bfd20"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_CR3</b> {0x6C02_umx}</td></tr>
<tr class="memdesc:a6896f313fc39eb9c4835037ade5bfd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_cr3 <br /></td></tr>
<tr class="separator:a6896f313fc39eb9c4835037ade5bfd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96c1da811073b54d16b1ebdf976e3b1"><td class="memItemLeft" align="right" valign="top"><a id="af96c1da811073b54d16b1ebdf976e3b1" name="af96c1da811073b54d16b1ebdf976e3b1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_CR4</b> {0x6C04_umx}</td></tr>
<tr class="memdesc:af96c1da811073b54d16b1ebdf976e3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_cr4 <br /></td></tr>
<tr class="separator:af96c1da811073b54d16b1ebdf976e3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7824af953b0e6e4dd7a21ff81599ede"><td class="memItemLeft" align="right" valign="top"><a id="aa7824af953b0e6e4dd7a21ff81599ede" name="aa7824af953b0e6e4dd7a21ff81599ede"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_FS_BASE</b> {0x6C06_umx}</td></tr>
<tr class="memdesc:aa7824af953b0e6e4dd7a21ff81599ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_fs_base <br /></td></tr>
<tr class="separator:aa7824af953b0e6e4dd7a21ff81599ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943098ea3d24edfba4afd3df906e633e"><td class="memItemLeft" align="right" valign="top"><a id="a943098ea3d24edfba4afd3df906e633e" name="a943098ea3d24edfba4afd3df906e633e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_GS_BASE</b> {0x6C08_umx}</td></tr>
<tr class="memdesc:a943098ea3d24edfba4afd3df906e633e"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_gs_base <br /></td></tr>
<tr class="separator:a943098ea3d24edfba4afd3df906e633e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec3e769b83f9d2fd706aae06c94bec3"><td class="memItemLeft" align="right" valign="top"><a id="a1ec3e769b83f9d2fd706aae06c94bec3" name="a1ec3e769b83f9d2fd706aae06c94bec3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_TR_BASE</b> {0x6C0A_umx}</td></tr>
<tr class="memdesc:a1ec3e769b83f9d2fd706aae06c94bec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_tr_base <br /></td></tr>
<tr class="separator:a1ec3e769b83f9d2fd706aae06c94bec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a522df2f8c7a73a33b9dd2315c34fe"><td class="memItemLeft" align="right" valign="top"><a id="ad3a522df2f8c7a73a33b9dd2315c34fe" name="ad3a522df2f8c7a73a33b9dd2315c34fe"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_GDTR_BASE</b> {0x6C0C_umx}</td></tr>
<tr class="memdesc:ad3a522df2f8c7a73a33b9dd2315c34fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_gdtr_base <br /></td></tr>
<tr class="separator:ad3a522df2f8c7a73a33b9dd2315c34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5dafa490f99c9d6c09a01e0fba5f34"><td class="memItemLeft" align="right" valign="top"><a id="a7b5dafa490f99c9d6c09a01e0fba5f34" name="a7b5dafa490f99c9d6c09a01e0fba5f34"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_IDTR_BASE</b> {0x6C0E_umx}</td></tr>
<tr class="memdesc:a7b5dafa490f99c9d6c09a01e0fba5f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_idtr_base <br /></td></tr>
<tr class="separator:a7b5dafa490f99c9d6c09a01e0fba5f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec39e869584ad8ac445816ad0375eb0d"><td class="memItemLeft" align="right" valign="top"><a id="aec39e869584ad8ac445816ad0375eb0d" name="aec39e869584ad8ac445816ad0375eb0d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_SYSENTER_ESP</b> {0x6C10_umx}</td></tr>
<tr class="memdesc:aec39e869584ad8ac445816ad0375eb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_sysenter_esp <br /></td></tr>
<tr class="separator:aec39e869584ad8ac445816ad0375eb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2937c8848b207a7db7345979f4882645"><td class="memItemLeft" align="right" valign="top"><a id="a2937c8848b207a7db7345979f4882645" name="a2937c8848b207a7db7345979f4882645"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_SYSENTER_EIP</b> {0x6C12_umx}</td></tr>
<tr class="memdesc:a2937c8848b207a7db7345979f4882645"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_sysenter_eip <br /></td></tr>
<tr class="separator:a2937c8848b207a7db7345979f4882645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34bc63e63585f3e67370abfeb911d25"><td class="memItemLeft" align="right" valign="top"><a id="ad34bc63e63585f3e67370abfeb911d25" name="ad34bc63e63585f3e67370abfeb911d25"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_RSP</b> {0x6C14_umx}</td></tr>
<tr class="memdesc:ad34bc63e63585f3e67370abfeb911d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_rsp <br /></td></tr>
<tr class="separator:ad34bc63e63585f3e67370abfeb911d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b92e6e221c92f61ba2dca4358dcc79"><td class="memItemLeft" align="right" valign="top"><a id="a95b92e6e221c92f61ba2dca4358dcc79" name="a95b92e6e221c92f61ba2dca4358dcc79"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>VMCS_HOST_RIP</b> {0x6C16_umx}</td></tr>
<tr class="memdesc:a95b92e6e221c92f61ba2dca4358dcc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">encoding for: host_rip <br /></td></tr>
<tr class="separator:a95b92e6e221c92f61ba2dca4358dcc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fcf0bf80839db90d4efe860634c79a"><td class="memItemLeft" align="right" valign="top"><a id="a07fcf0bf80839db90d4efe860634c79a" name="a07fcf0bf80839db90d4efe860634c79a"></a>
constinit bsl::array&lt; <a class="el" href="structmk_1_1tls__t.html">tls_t</a>, HYPERVISOR_MAX_PPS.get()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_tls_blocks</b> {}</td></tr>
<tr class="memdesc:a07fcf0bf80839db90d4efe860634c79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the TLS blocks used by the microkernel. <br /></td></tr>
<tr class="separator:a07fcf0bf80839db90d4efe860634c79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7977ff8ad8aa375a5167d48160d7503"><td class="memItemLeft" align="right" valign="top"><a id="aa7977ff8ad8aa375a5167d48160d7503" name="aa7977ff8ad8aa375a5167d48160d7503"></a>
constinit <a class="el" href="structloader_1_1debug__ring__t.html">loader::debug_ring_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>g_pmut_mut_debug_ring</b> {}</td></tr>
<tr class="memdesc:aa7977ff8ad8aa375a5167d48160d7503"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores a pointer to the debug ring provided by the loader <br /></td></tr>
<tr class="separator:aa7977ff8ad8aa375a5167d48160d7503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7605b74575797d9f5f3983217a8a11"><td class="memItemLeft" align="right" valign="top"><a id="a2a7605b74575797d9f5f3983217a8a11" name="a2a7605b74575797d9f5f3983217a8a11"></a>
constinit <a class="el" href="classmk_1_1vmexit__log__t.html">vmexit_log_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_vmexit_log</b> {}</td></tr>
<tr class="memdesc:a2a7605b74575797d9f5f3983217a8a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the vmexit log used by the microkernel <br /></td></tr>
<tr class="separator:a2a7605b74575797d9f5f3983217a8a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20369e7d51039c61ed615d3d44102de1"><td class="memItemLeft" align="right" valign="top">constinit <a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a20369e7d51039c61ed615d3d44102de1">g_mut_page_pool</a> {}</td></tr>
<tr class="memdesc:a20369e7d51039c61ed615d3d44102de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the page_pool_t used by the microkernel  <a href="namespacemk.html#a20369e7d51039c61ed615d3d44102de1">More...</a><br /></td></tr>
<tr class="separator:a20369e7d51039c61ed615d3d44102de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cf374f6efe0be481ccc4ee1f801cae"><td class="memItemLeft" align="right" valign="top">constinit <a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemk.html#a47cf374f6efe0be481ccc4ee1f801cae">g_mut_huge_pool</a> {}</td></tr>
<tr class="memdesc:a47cf374f6efe0be481ccc4ee1f801cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the huge pool used by the microkernel  <a href="namespacemk.html#a47cf374f6efe0be481ccc4ee1f801cae">More...</a><br /></td></tr>
<tr class="separator:a47cf374f6efe0be481ccc4ee1f801cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c9a662d61f990db8bdff7dcd819ef8"><td class="memItemLeft" align="right" valign="top"><a id="aa9c9a662d61f990db8bdff7dcd819ef8" name="aa9c9a662d61f990db8bdff7dcd819ef8"></a>
constinit <a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_intrinsic</b> {}</td></tr>
<tr class="memdesc:aa9c9a662d61f990db8bdff7dcd819ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the intrinsics used by the microkernel <br /></td></tr>
<tr class="separator:aa9c9a662d61f990db8bdff7dcd819ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e215c9e73a2fde57750a688da5cfdf0"><td class="memItemLeft" align="right" valign="top"><a id="a8e215c9e73a2fde57750a688da5cfdf0" name="a8e215c9e73a2fde57750a688da5cfdf0"></a>
constinit <a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_vm_pool</b> {}</td></tr>
<tr class="memdesc:a8e215c9e73a2fde57750a688da5cfdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> used by the microkernel <br /></td></tr>
<tr class="separator:a8e215c9e73a2fde57750a688da5cfdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb87980cdeffd3736725906ecdf4307"><td class="memItemLeft" align="right" valign="top"><a id="adeb87980cdeffd3736725906ecdf4307" name="adeb87980cdeffd3736725906ecdf4307"></a>
constinit <a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_vp_pool</b> {}</td></tr>
<tr class="memdesc:adeb87980cdeffd3736725906ecdf4307"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> used by the microkernel <br /></td></tr>
<tr class="separator:adeb87980cdeffd3736725906ecdf4307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5751a45e4092e415d4729b1bb6ba2ec9"><td class="memItemLeft" align="right" valign="top"><a id="a5751a45e4092e415d4729b1bb6ba2ec9" name="a5751a45e4092e415d4729b1bb6ba2ec9"></a>
constinit <a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_vs_pool</b> {}</td></tr>
<tr class="memdesc:a5751a45e4092e415d4729b1bb6ba2ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> used by the microkernel <br /></td></tr>
<tr class="separator:a5751a45e4092e415d4729b1bb6ba2ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08df31ba6a390ea75be09ba3559375fc"><td class="memItemLeft" align="right" valign="top"><a id="a08df31ba6a390ea75be09ba3559375fc" name="a08df31ba6a390ea75be09ba3559375fc"></a>
constinit <a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_ext_pool</b> {}</td></tr>
<tr class="memdesc:a08df31ba6a390ea75be09ba3559375fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the ext pool used by the microkernel <br /></td></tr>
<tr class="separator:a08df31ba6a390ea75be09ba3559375fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8df4d831469dbd5dfd13da12e3149c"><td class="memItemLeft" align="right" valign="top"><a id="aba8df4d831469dbd5dfd13da12e3149c" name="aba8df4d831469dbd5dfd13da12e3149c"></a>
constinit <a class="el" href="namespacemk.html#a6eb130b521649a4ca56bb0f9902a2ce9">root_page_table_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_system_rpt</b> {}</td></tr>
<tr class="memdesc:aba8df4d831469dbd5dfd13da12e3149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the system RPT provided by the loader <br /></td></tr>
<tr class="separator:aba8df4d831469dbd5dfd13da12e3149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a12ea9dc461560bb2251add0e0a439"><td class="memItemLeft" align="right" valign="top"><a id="a83a12ea9dc461560bb2251add0e0a439" name="a83a12ea9dc461560bb2251add0e0a439"></a>
constinit <a class="el" href="classmk_1_1mk__main__t.html">mk_main_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_mk_main</b> {}</td></tr>
<tr class="memdesc:a83a12ea9dc461560bb2251add0e0a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the microkernel's main class <br /></td></tr>
<tr class="separator:a83a12ea9dc461560bb2251add0e0a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25bcc500ebbf328b393ee91c34d0fa6"><td class="memItemLeft" align="right" valign="top"><a id="ab25bcc500ebbf328b393ee91c34d0fa6" name="ab25bcc500ebbf328b393ee91c34d0fa6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_0</b> {0_umx}</td></tr>
<tr class="memdesc:ab25bcc500ebbf328b393ee91c34d0fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #0 <br /></td></tr>
<tr class="separator:ab25bcc500ebbf328b393ee91c34d0fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4807f86d175d7cfcd89b2372b9ed3c"><td class="memItemLeft" align="right" valign="top"><a id="aaf4807f86d175d7cfcd89b2372b9ed3c" name="aaf4807f86d175d7cfcd89b2372b9ed3c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_1</b> {1_umx}</td></tr>
<tr class="memdesc:aaf4807f86d175d7cfcd89b2372b9ed3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #1 <br /></td></tr>
<tr class="separator:aaf4807f86d175d7cfcd89b2372b9ed3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbc14d7a9557ee4d9a5cc78e944347a"><td class="memItemLeft" align="right" valign="top"><a id="a6dbc14d7a9557ee4d9a5cc78e944347a" name="a6dbc14d7a9557ee4d9a5cc78e944347a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_2</b> {2_umx}</td></tr>
<tr class="memdesc:a6dbc14d7a9557ee4d9a5cc78e944347a"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #2 <br /></td></tr>
<tr class="separator:a6dbc14d7a9557ee4d9a5cc78e944347a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d536371f542e52ae2dc4424c5f2492"><td class="memItemLeft" align="right" valign="top"><a id="ac5d536371f542e52ae2dc4424c5f2492" name="ac5d536371f542e52ae2dc4424c5f2492"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_3</b> {3_umx}</td></tr>
<tr class="memdesc:ac5d536371f542e52ae2dc4424c5f2492"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #3 <br /></td></tr>
<tr class="separator:ac5d536371f542e52ae2dc4424c5f2492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cab01d53cfc40a990c6cfa66699bfd"><td class="memItemLeft" align="right" valign="top"><a id="a57cab01d53cfc40a990c6cfa66699bfd" name="a57cab01d53cfc40a990c6cfa66699bfd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_4</b> {4_umx}</td></tr>
<tr class="memdesc:a57cab01d53cfc40a990c6cfa66699bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #4 <br /></td></tr>
<tr class="separator:a57cab01d53cfc40a990c6cfa66699bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a66c9698e5e40fa6b1a225cfd30e00"><td class="memItemLeft" align="right" valign="top"><a id="ae3a66c9698e5e40fa6b1a225cfd30e00" name="ae3a66c9698e5e40fa6b1a225cfd30e00"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_5</b> {5_umx}</td></tr>
<tr class="memdesc:ae3a66c9698e5e40fa6b1a225cfd30e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #5 <br /></td></tr>
<tr class="separator:ae3a66c9698e5e40fa6b1a225cfd30e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c19b7dbdc49cdb9a8d509a61f48eb1f"><td class="memItemLeft" align="right" valign="top"><a id="a0c19b7dbdc49cdb9a8d509a61f48eb1f" name="a0c19b7dbdc49cdb9a8d509a61f48eb1f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_6</b> {6_umx}</td></tr>
<tr class="memdesc:a0c19b7dbdc49cdb9a8d509a61f48eb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #6 <br /></td></tr>
<tr class="separator:a0c19b7dbdc49cdb9a8d509a61f48eb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4590d3114c68203c366b9fcd2259b2"><td class="memItemLeft" align="right" valign="top"><a id="a8b4590d3114c68203c366b9fcd2259b2" name="a8b4590d3114c68203c366b9fcd2259b2"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_7</b> {7_umx}</td></tr>
<tr class="memdesc:a8b4590d3114c68203c366b9fcd2259b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #7 <br /></td></tr>
<tr class="separator:a8b4590d3114c68203c366b9fcd2259b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd5f3e9ab630d8862361f6e66c4566d"><td class="memItemLeft" align="right" valign="top"><a id="aacd5f3e9ab630d8862361f6e66c4566d" name="aacd5f3e9ab630d8862361f6e66c4566d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_8</b> {8_umx}</td></tr>
<tr class="memdesc:aacd5f3e9ab630d8862361f6e66c4566d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #8 <br /></td></tr>
<tr class="separator:aacd5f3e9ab630d8862361f6e66c4566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df92731d616ba3d374abb393d6f9c16"><td class="memItemLeft" align="right" valign="top"><a id="a1df92731d616ba3d374abb393d6f9c16" name="a1df92731d616ba3d374abb393d6f9c16"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_10</b> {10_umx}</td></tr>
<tr class="memdesc:a1df92731d616ba3d374abb393d6f9c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #10 <br /></td></tr>
<tr class="separator:a1df92731d616ba3d374abb393d6f9c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ffc3e4180d443a839cbfb923b24f7c"><td class="memItemLeft" align="right" valign="top"><a id="a29ffc3e4180d443a839cbfb923b24f7c" name="a29ffc3e4180d443a839cbfb923b24f7c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_11</b> {11_umx}</td></tr>
<tr class="memdesc:a29ffc3e4180d443a839cbfb923b24f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #11 <br /></td></tr>
<tr class="separator:a29ffc3e4180d443a839cbfb923b24f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c27700ae5032ab44151c9e9603cc4ec"><td class="memItemLeft" align="right" valign="top"><a id="a9c27700ae5032ab44151c9e9603cc4ec" name="a9c27700ae5032ab44151c9e9603cc4ec"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_12</b> {12_umx}</td></tr>
<tr class="memdesc:a9c27700ae5032ab44151c9e9603cc4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #12 <br /></td></tr>
<tr class="separator:a9c27700ae5032ab44151c9e9603cc4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a06ee5eb60ef360d3b33b3925fdbb7a"><td class="memItemLeft" align="right" valign="top"><a id="a5a06ee5eb60ef360d3b33b3925fdbb7a" name="a5a06ee5eb60ef360d3b33b3925fdbb7a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_13</b> {13_umx}</td></tr>
<tr class="memdesc:a5a06ee5eb60ef360d3b33b3925fdbb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #13 <br /></td></tr>
<tr class="separator:a5a06ee5eb60ef360d3b33b3925fdbb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484718185a5eadb1d00f7287eb9302e1"><td class="memItemLeft" align="right" valign="top"><a id="a484718185a5eadb1d00f7287eb9302e1" name="a484718185a5eadb1d00f7287eb9302e1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_14</b> {14_umx}</td></tr>
<tr class="memdesc:a484718185a5eadb1d00f7287eb9302e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #14 <br /></td></tr>
<tr class="separator:a484718185a5eadb1d00f7287eb9302e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bbe02100793ffeed0464899ab52cf5"><td class="memItemLeft" align="right" valign="top"><a id="ae9bbe02100793ffeed0464899ab52cf5" name="ae9bbe02100793ffeed0464899ab52cf5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_16</b> {16_umx}</td></tr>
<tr class="memdesc:ae9bbe02100793ffeed0464899ab52cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #16 <br /></td></tr>
<tr class="separator:ae9bbe02100793ffeed0464899ab52cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f68997ebe232e279c256629376086e"><td class="memItemLeft" align="right" valign="top"><a id="a57f68997ebe232e279c256629376086e" name="a57f68997ebe232e279c256629376086e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_17</b> {17_umx}</td></tr>
<tr class="memdesc:a57f68997ebe232e279c256629376086e"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #17 <br /></td></tr>
<tr class="separator:a57f68997ebe232e279c256629376086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cfff7ae972423c7233091a5ed6ba1f"><td class="memItemLeft" align="right" valign="top"><a id="ab8cfff7ae972423c7233091a5ed6ba1f" name="ab8cfff7ae972423c7233091a5ed6ba1f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_18</b> {18_umx}</td></tr>
<tr class="memdesc:ab8cfff7ae972423c7233091a5ed6ba1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #18 <br /></td></tr>
<tr class="separator:ab8cfff7ae972423c7233091a5ed6ba1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60abeba9d794947a2dffd3adb75029d7"><td class="memItemLeft" align="right" valign="top"><a id="a60abeba9d794947a2dffd3adb75029d7" name="a60abeba9d794947a2dffd3adb75029d7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>EXCEPTION_VECTOR_19</b> {19_umx}</td></tr>
<tr class="memdesc:a60abeba9d794947a2dffd3adb75029d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a constant for the exception vector #19 <br /></td></tr>
<tr class="separator:a60abeba9d794947a2dffd3adb75029d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2136789db86e3a52a6373fe52a0216"><td class="memItemLeft" align="right" valign="top"><a id="a1b2136789db86e3a52a6373fe52a0216" name="a1b2136789db86e3a52a6373fe52a0216"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_BASIC</b> {0x480_u32}</td></tr>
<tr class="memdesc:a1b2136789db86e3a52a6373fe52a0216"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the VMX_BASIC MSR <br /></td></tr>
<tr class="separator:a1b2136789db86e3a52a6373fe52a0216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da4f7efaf3fb9c02ed044c7c700ecf3"><td class="memItemLeft" align="right" valign="top"><a id="a6da4f7efaf3fb9c02ed044c7c700ecf3" name="a6da4f7efaf3fb9c02ed044c7c700ecf3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_PAT</b> {0x277_u32}</td></tr>
<tr class="memdesc:a6da4f7efaf3fb9c02ed044c7c700ecf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the PAT MSR <br /></td></tr>
<tr class="separator:a6da4f7efaf3fb9c02ed044c7c700ecf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb490e244a92a8c9033b800ed18afaa5"><td class="memItemLeft" align="right" valign="top"><a id="acb490e244a92a8c9033b800ed18afaa5" name="acb490e244a92a8c9033b800ed18afaa5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_SYSENTER_CS</b> {0x174_u32}</td></tr>
<tr class="memdesc:acb490e244a92a8c9033b800ed18afaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the SYSENTER_CS MSR <br /></td></tr>
<tr class="separator:acb490e244a92a8c9033b800ed18afaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06216b1f9100bc6f477de8e9de0e4ebe"><td class="memItemLeft" align="right" valign="top"><a id="a06216b1f9100bc6f477de8e9de0e4ebe" name="a06216b1f9100bc6f477de8e9de0e4ebe"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_SYSENTER_ESP</b> {0x175_u32}</td></tr>
<tr class="memdesc:a06216b1f9100bc6f477de8e9de0e4ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the SYSENTER_ESP MSR <br /></td></tr>
<tr class="separator:a06216b1f9100bc6f477de8e9de0e4ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbed2633ca81a093e582416a38fc96f"><td class="memItemLeft" align="right" valign="top"><a id="abbbed2633ca81a093e582416a38fc96f" name="abbbed2633ca81a093e582416a38fc96f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_SYSENTER_EIP</b> {0x176_u32}</td></tr>
<tr class="memdesc:abbbed2633ca81a093e582416a38fc96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the SYSENTER_EIP MSR <br /></td></tr>
<tr class="separator:abbbed2633ca81a093e582416a38fc96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ae0c219cd22d31b6ee722f9841ce50"><td class="memItemLeft" align="right" valign="top"><a id="aa5ae0c219cd22d31b6ee722f9841ce50" name="aa5ae0c219cd22d31b6ee722f9841ce50"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_EFER</b> {0xC0000080_u32}</td></tr>
<tr class="memdesc:aa5ae0c219cd22d31b6ee722f9841ce50"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the EFER MSR <br /></td></tr>
<tr class="separator:aa5ae0c219cd22d31b6ee722f9841ce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9998a3dafb7c818a02deecd8ef7c90df"><td class="memItemLeft" align="right" valign="top"><a id="a9998a3dafb7c818a02deecd8ef7c90df" name="a9998a3dafb7c818a02deecd8ef7c90df"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_STAR</b> {0xC0000081_u32}</td></tr>
<tr class="memdesc:a9998a3dafb7c818a02deecd8ef7c90df"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the STAR MSR <br /></td></tr>
<tr class="separator:a9998a3dafb7c818a02deecd8ef7c90df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb87243c06c79710e5fdf448b63ab7c8"><td class="memItemLeft" align="right" valign="top"><a id="abb87243c06c79710e5fdf448b63ab7c8" name="abb87243c06c79710e5fdf448b63ab7c8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_LSTAR</b> {0xC0000082_u32}</td></tr>
<tr class="memdesc:abb87243c06c79710e5fdf448b63ab7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the LSTAR MSR <br /></td></tr>
<tr class="separator:abb87243c06c79710e5fdf448b63ab7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d43fbb234f146d8ac8b7a97626fd7b4"><td class="memItemLeft" align="right" valign="top"><a id="a4d43fbb234f146d8ac8b7a97626fd7b4" name="a4d43fbb234f146d8ac8b7a97626fd7b4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_CSTAR</b> {0xC0000083_u32}</td></tr>
<tr class="memdesc:a4d43fbb234f146d8ac8b7a97626fd7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the CSTAR MSR <br /></td></tr>
<tr class="separator:a4d43fbb234f146d8ac8b7a97626fd7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2bffeadc52768b92cb731a402101e4"><td class="memItemLeft" align="right" valign="top"><a id="a7a2bffeadc52768b92cb731a402101e4" name="a7a2bffeadc52768b92cb731a402101e4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_FMASK</b> {0xC0000084_u32}</td></tr>
<tr class="memdesc:a7a2bffeadc52768b92cb731a402101e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the FMASK MSR <br /></td></tr>
<tr class="separator:a7a2bffeadc52768b92cb731a402101e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf25183a0312280d4a7f648228033753"><td class="memItemLeft" align="right" valign="top"><a id="abf25183a0312280d4a7f648228033753" name="abf25183a0312280d4a7f648228033753"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_FS_BASE</b> {0xC0000100_u32}</td></tr>
<tr class="memdesc:abf25183a0312280d4a7f648228033753"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the FS_BASE MSR <br /></td></tr>
<tr class="separator:abf25183a0312280d4a7f648228033753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31632a8dd6865422773b5f1f2ff05dc"><td class="memItemLeft" align="right" valign="top"><a id="ab31632a8dd6865422773b5f1f2ff05dc" name="ab31632a8dd6865422773b5f1f2ff05dc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_GS_BASE</b> {0xC0000101_u32}</td></tr>
<tr class="memdesc:ab31632a8dd6865422773b5f1f2ff05dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the GS_BASE MSR <br /></td></tr>
<tr class="separator:ab31632a8dd6865422773b5f1f2ff05dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ae3ce18fb55a42c1d22b9c203a4eec"><td class="memItemLeft" align="right" valign="top"><a id="ad2ae3ce18fb55a42c1d22b9c203a4eec" name="ad2ae3ce18fb55a42c1d22b9c203a4eec"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_KERNEL_GS_BASE</b> {0xC0000102_u32}</td></tr>
<tr class="memdesc:ad2ae3ce18fb55a42c1d22b9c203a4eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the KERNEL_GS_BASE MSR <br /></td></tr>
<tr class="separator:ad2ae3ce18fb55a42c1d22b9c203a4eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4133edd6a77c865bd812902b6e82a30"><td class="memItemLeft" align="right" valign="top"><a id="ae4133edd6a77c865bd812902b6e82a30" name="ae4133edd6a77c865bd812902b6e82a30"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_CR0_FIXED0</b> {0x00000486_u32}</td></tr>
<tr class="memdesc:ae4133edd6a77c865bd812902b6e82a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_CR0_FIXED0 MSR <br /></td></tr>
<tr class="separator:ae4133edd6a77c865bd812902b6e82a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7798760bd8a1472166f6f2d1c01b5ad3"><td class="memItemLeft" align="right" valign="top"><a id="a7798760bd8a1472166f6f2d1c01b5ad3" name="a7798760bd8a1472166f6f2d1c01b5ad3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_CR0_FIXED1</b> {0x00000487_u32}</td></tr>
<tr class="memdesc:a7798760bd8a1472166f6f2d1c01b5ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_CR0_FIXED1 MSR <br /></td></tr>
<tr class="separator:a7798760bd8a1472166f6f2d1c01b5ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7d4e413554f3411c2de68c7718dbc4"><td class="memItemLeft" align="right" valign="top"><a id="aff7d4e413554f3411c2de68c7718dbc4" name="aff7d4e413554f3411c2de68c7718dbc4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_CR4_FIXED0</b> {0x00000488_u32}</td></tr>
<tr class="memdesc:aff7d4e413554f3411c2de68c7718dbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_CR4_FIXED0 MSR <br /></td></tr>
<tr class="separator:aff7d4e413554f3411c2de68c7718dbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0938113d9d09f9e62289903d8aaada4b"><td class="memItemLeft" align="right" valign="top"><a id="a0938113d9d09f9e62289903d8aaada4b" name="a0938113d9d09f9e62289903d8aaada4b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_CR4_FIXED1</b> {0x00000489_u32}</td></tr>
<tr class="memdesc:a0938113d9d09f9e62289903d8aaada4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_CR4_FIXED1 MSR <br /></td></tr>
<tr class="separator:a0938113d9d09f9e62289903d8aaada4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf280756e3b31aaf898dad944ebe6787"><td class="memItemLeft" align="right" valign="top"><a id="abf280756e3b31aaf898dad944ebe6787" name="abf280756e3b31aaf898dad944ebe6787"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_TRUE_PIN_CTLS</b> {0x0000048D_u32}</td></tr>
<tr class="memdesc:abf280756e3b31aaf898dad944ebe6787"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_TRUE_PIN_CTLS MSR <br /></td></tr>
<tr class="separator:abf280756e3b31aaf898dad944ebe6787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4110dae2ddfe1f1eb8c8b7b75fc99a"><td class="memItemLeft" align="right" valign="top"><a id="acf4110dae2ddfe1f1eb8c8b7b75fc99a" name="acf4110dae2ddfe1f1eb8c8b7b75fc99a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_TRUE_PROC_CTLS</b> {0x0000048E_u32}</td></tr>
<tr class="memdesc:acf4110dae2ddfe1f1eb8c8b7b75fc99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_TRUE_PROC_CTLS MSR <br /></td></tr>
<tr class="separator:acf4110dae2ddfe1f1eb8c8b7b75fc99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386533890826cd268a0e08997651b3f0"><td class="memItemLeft" align="right" valign="top"><a id="a386533890826cd268a0e08997651b3f0" name="a386533890826cd268a0e08997651b3f0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_TRUE_EXIT_CTLS</b> {0x0000048F_u32}</td></tr>
<tr class="memdesc:a386533890826cd268a0e08997651b3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_TRUE_EXIT_CTLS MSR <br /></td></tr>
<tr class="separator:a386533890826cd268a0e08997651b3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf749dbd32f0298e831fcac098aee0d1"><td class="memItemLeft" align="right" valign="top"><a id="aaf749dbd32f0298e831fcac098aee0d1" name="aaf749dbd32f0298e831fcac098aee0d1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_TRUE_ENTRY_CTLS</b> {0x00000490_u32}</td></tr>
<tr class="memdesc:aaf749dbd32f0298e831fcac098aee0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_TRUE_ENTRY_CTLS MSR <br /></td></tr>
<tr class="separator:aaf749dbd32f0298e831fcac098aee0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee24089f578c27e6262233f627852afa"><td class="memItemLeft" align="right" valign="top"><a id="aee24089f578c27e6262233f627852afa" name="aee24089f578c27e6262233f627852afa"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_VMX_TRUE_PROC2_CTLS</b> {0x0000048B_u32}</td></tr>
<tr class="memdesc:aee24089f578c27e6262233f627852afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the MSR_VMX_TRUE_PROC2_CTLS MSR <br /></td></tr>
<tr class="separator:aee24089f578c27e6262233f627852afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a848647ba045ab8a42c2ea95c78183d"><td class="memItemLeft" align="right" valign="top"><a id="a7a848647ba045ab8a42c2ea95c78183d" name="a7a848647ba045ab8a42c2ea95c78183d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PHNUM</b> {7_u64}</td></tr>
<tr class="memdesc:a7a848647ba045ab8a42c2ea95c78183d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the total number of program headers in our ELF file <br /></td></tr>
<tr class="separator:a7a848647ba045ab8a42c2ea95c78183d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9801e00bac24efa3d32304f8641919d8"><td class="memItemLeft" align="right" valign="top"><a id="a9801e00bac24efa3d32304f8641919d8" name="a9801e00bac24efa3d32304f8641919d8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_ONLINE_PPS</b> {2_u16}</td></tr>
<tr class="memdesc:a9801e00bac24efa3d32304f8641919d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the total number of online PPs in our unittests <br /></td></tr>
<tr class="separator:a9801e00bac24efa3d32304f8641919d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258748311f5dce3156685e6f7918492e"><td class="memItemLeft" align="right" valign="top"><a id="a258748311f5dce3156685e6f7918492e" name="a258748311f5dce3156685e6f7918492e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>ELF_FILE_BUF_SIZE</b> {0x200000_umx}</td></tr>
<tr class="memdesc:a258748311f5dce3156685e6f7918492e"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the total size of our ELF file <br /></td></tr>
<tr class="separator:a258748311f5dce3156685e6f7918492e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9bf3508b889bd4406c4cc551ff8ab0"><td class="memItemLeft" align="right" valign="top"><a id="a7b9bf3508b889bd4406c4cc551ff8ab0" name="a7b9bf3508b889bd4406c4cc551ff8ab0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PHDR_PT_LOAD_RE_IDX</b> {0_idx}</td></tr>
<tr class="memdesc:a7b9bf3508b889bd4406c4cc551ff8ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the index of our RE PT_LOAD segment <br /></td></tr>
<tr class="separator:a7b9bf3508b889bd4406c4cc551ff8ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea43890be17ac37bb316bd2d8aa48bb8"><td class="memItemLeft" align="right" valign="top"><a id="aea43890be17ac37bb316bd2d8aa48bb8" name="aea43890be17ac37bb316bd2d8aa48bb8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PHDR_PT_LOAD_RO_IDX</b> {1_idx}</td></tr>
<tr class="memdesc:aea43890be17ac37bb316bd2d8aa48bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the index of our RO PT_LOAD segment <br /></td></tr>
<tr class="separator:aea43890be17ac37bb316bd2d8aa48bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac452dd581d060a909a78f2261654d38"><td class="memItemLeft" align="right" valign="top"><a id="aac452dd581d060a909a78f2261654d38" name="aac452dd581d060a909a78f2261654d38"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PHDR_PT_LOAD_RW_IDX</b> {2_idx}</td></tr>
<tr class="memdesc:aac452dd581d060a909a78f2261654d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the index of our RW PT_LOAD segment <br /></td></tr>
<tr class="separator:aac452dd581d060a909a78f2261654d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a2d01ec094ecb91293f0b9b82fb52"><td class="memItemLeft" align="right" valign="top"><a id="a8e6a2d01ec094ecb91293f0b9b82fb52" name="a8e6a2d01ec094ecb91293f0b9b82fb52"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PHDR_PT_LOAD_TLS_IDX</b> {3_idx}</td></tr>
<tr class="memdesc:a8e6a2d01ec094ecb91293f0b9b82fb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the index of our TLS PT_LOAD segment <br /></td></tr>
<tr class="separator:a8e6a2d01ec094ecb91293f0b9b82fb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c386d6b3c55ed25d70706e88ddeb7a2"><td class="memItemLeft" align="right" valign="top"><a id="a0c386d6b3c55ed25d70706e88ddeb7a2" name="a0c386d6b3c55ed25d70706e88ddeb7a2"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PHDR_PT_TLS_IDX</b> {4_idx}</td></tr>
<tr class="memdesc:a0c386d6b3c55ed25d70706e88ddeb7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the index of our PT_TLS segment <br /></td></tr>
<tr class="separator:a0c386d6b3c55ed25d70706e88ddeb7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f7d7781106cff99b33179fb7d0b236"><td class="memItemLeft" align="right" valign="top"><a id="a97f7d7781106cff99b33179fb7d0b236" name="a97f7d7781106cff99b33179fb7d0b236"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PHDR_PT_GNU_STACK_IDX</b> {5_idx}</td></tr>
<tr class="memdesc:a97f7d7781106cff99b33179fb7d0b236"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the index of our GNU_STACK segment <br /></td></tr>
<tr class="separator:a97f7d7781106cff99b33179fb7d0b236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5970e12a22d86118ac476ec3de7f797"><td class="memItemLeft" align="right" valign="top"><a id="aa5970e12a22d86118ac476ec3de7f797" name="aa5970e12a22d86118ac476ec3de7f797"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RE_VADDR</b> {0x0000328000000000_u64}</td></tr>
<tr class="memdesc:aa5970e12a22d86118ac476ec3de7f797"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the virtual address of our RE PT_LOAD segment <br /></td></tr>
<tr class="separator:aa5970e12a22d86118ac476ec3de7f797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2c149bb3cdcd6fa94b6e2de95c1fa5"><td class="memItemLeft" align="right" valign="top"><a id="a9a2c149bb3cdcd6fa94b6e2de95c1fa5" name="a9a2c149bb3cdcd6fa94b6e2de95c1fa5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RE_PADDR</b> {0x0000328000000000_u64}</td></tr>
<tr class="memdesc:a9a2c149bb3cdcd6fa94b6e2de95c1fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the physical address of our RE PT_LOAD segment <br /></td></tr>
<tr class="separator:a9a2c149bb3cdcd6fa94b6e2de95c1fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5de46d7cd72765eaea5e2966aecdbe8"><td class="memItemLeft" align="right" valign="top"><a id="af5de46d7cd72765eaea5e2966aecdbe8" name="af5de46d7cd72765eaea5e2966aecdbe8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RE_FILSZ</b> {0x2000_u64}</td></tr>
<tr class="memdesc:af5de46d7cd72765eaea5e2966aecdbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the file size of our RE PT_LOAD segment <br /></td></tr>
<tr class="separator:af5de46d7cd72765eaea5e2966aecdbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96b85ff994a9a82d8fc00c41ef1f7a2"><td class="memItemLeft" align="right" valign="top"><a id="ac96b85ff994a9a82d8fc00c41ef1f7a2" name="ac96b85ff994a9a82d8fc00c41ef1f7a2"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RE_MEMSZ</b> {0x3000_u64}</td></tr>
<tr class="memdesc:ac96b85ff994a9a82d8fc00c41ef1f7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the memory size of our RE PT_LOAD segment <br /></td></tr>
<tr class="separator:ac96b85ff994a9a82d8fc00c41ef1f7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7343e96a95953873b10844a40975dad4"><td class="memItemLeft" align="right" valign="top"><a id="a7343e96a95953873b10844a40975dad4" name="a7343e96a95953873b10844a40975dad4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RO_VADDR</b> {0x0000328000003000_u64}</td></tr>
<tr class="memdesc:a7343e96a95953873b10844a40975dad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the virtual address of our RO PT_LOAD segment <br /></td></tr>
<tr class="separator:a7343e96a95953873b10844a40975dad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3547e76d2f1a7cdd032018112108a2f"><td class="memItemLeft" align="right" valign="top"><a id="ab3547e76d2f1a7cdd032018112108a2f" name="ab3547e76d2f1a7cdd032018112108a2f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RO_PADDR</b> {0x0000328000003000_u64}</td></tr>
<tr class="memdesc:ab3547e76d2f1a7cdd032018112108a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the physical address of our RO PT_LOAD segment <br /></td></tr>
<tr class="separator:ab3547e76d2f1a7cdd032018112108a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3698d4703b84409f6e8c53a2a82c2ac"><td class="memItemLeft" align="right" valign="top"><a id="aa3698d4703b84409f6e8c53a2a82c2ac" name="aa3698d4703b84409f6e8c53a2a82c2ac"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RO_FILSZ</b> {0x2000_u64}</td></tr>
<tr class="memdesc:aa3698d4703b84409f6e8c53a2a82c2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the file size of our RO PT_LOAD segment <br /></td></tr>
<tr class="separator:aa3698d4703b84409f6e8c53a2a82c2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f5f369cfd4273749af28c5de21d8dd"><td class="memItemLeft" align="right" valign="top"><a id="ac9f5f369cfd4273749af28c5de21d8dd" name="ac9f5f369cfd4273749af28c5de21d8dd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RO_MEMSZ</b> {0x3000_u64}</td></tr>
<tr class="memdesc:ac9f5f369cfd4273749af28c5de21d8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the memory size of our RO PT_LOAD segment <br /></td></tr>
<tr class="separator:ac9f5f369cfd4273749af28c5de21d8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46114c7847b819707126245d02987485"><td class="memItemLeft" align="right" valign="top"><a id="a46114c7847b819707126245d02987485" name="a46114c7847b819707126245d02987485"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RW_VADDR</b> {0x0000328000006000_u64}</td></tr>
<tr class="memdesc:a46114c7847b819707126245d02987485"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the virtual address of our RW PT_LOAD segment <br /></td></tr>
<tr class="separator:a46114c7847b819707126245d02987485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666467c373964edd7a1afdb6e7aeed46"><td class="memItemLeft" align="right" valign="top"><a id="a666467c373964edd7a1afdb6e7aeed46" name="a666467c373964edd7a1afdb6e7aeed46"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RW_PADDR</b> {0x0000328000006000_u64}</td></tr>
<tr class="memdesc:a666467c373964edd7a1afdb6e7aeed46"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the physical address of our RW PT_LOAD segment <br /></td></tr>
<tr class="separator:a666467c373964edd7a1afdb6e7aeed46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5564a7f1c75fc704c469127761e47dfd"><td class="memItemLeft" align="right" valign="top"><a id="a5564a7f1c75fc704c469127761e47dfd" name="a5564a7f1c75fc704c469127761e47dfd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RW_FILSZ</b> {0x2000_u64}</td></tr>
<tr class="memdesc:a5564a7f1c75fc704c469127761e47dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the file size of our RW PT_LOAD segment <br /></td></tr>
<tr class="separator:a5564a7f1c75fc704c469127761e47dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daca436e88dc6282f3deff1214f3d07"><td class="memItemLeft" align="right" valign="top"><a id="a3daca436e88dc6282f3deff1214f3d07" name="a3daca436e88dc6282f3deff1214f3d07"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_RW_MEMSZ</b> {0x3000_u64}</td></tr>
<tr class="memdesc:a3daca436e88dc6282f3deff1214f3d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the memory size of our RW PT_LOAD segment <br /></td></tr>
<tr class="separator:a3daca436e88dc6282f3deff1214f3d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd294b0ebee17631da06d9f0860a919"><td class="memItemLeft" align="right" valign="top"><a id="a4fd294b0ebee17631da06d9f0860a919" name="a4fd294b0ebee17631da06d9f0860a919"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_TLS_VADDR</b> {0x0000328000010000_u64}</td></tr>
<tr class="memdesc:a4fd294b0ebee17631da06d9f0860a919"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the virtual address of our TLS PT_LOAD segment <br /></td></tr>
<tr class="separator:a4fd294b0ebee17631da06d9f0860a919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974314fc9f3f350d2241cc5d0da2d48e"><td class="memItemLeft" align="right" valign="top"><a id="a974314fc9f3f350d2241cc5d0da2d48e" name="a974314fc9f3f350d2241cc5d0da2d48e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_TLS_PADDR</b> {0x0000328000010000_u64}</td></tr>
<tr class="memdesc:a974314fc9f3f350d2241cc5d0da2d48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the physical address of our TLS PT_LOAD segment <br /></td></tr>
<tr class="separator:a974314fc9f3f350d2241cc5d0da2d48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f974ee585ab8ececd08303a0a1e2f30"><td class="memItemLeft" align="right" valign="top"><a id="a2f974ee585ab8ececd08303a0a1e2f30" name="a2f974ee585ab8ececd08303a0a1e2f30"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_TLS_FILSZ</b> {0x10_u64}</td></tr>
<tr class="memdesc:a2f974ee585ab8ececd08303a0a1e2f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the file size of our TLS PT_LOAD segment <br /></td></tr>
<tr class="separator:a2f974ee585ab8ececd08303a0a1e2f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4466645355d762bff0d32378435316c6"><td class="memItemLeft" align="right" valign="top"><a id="a4466645355d762bff0d32378435316c6" name="a4466645355d762bff0d32378435316c6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOAD_TLS_MEMSZ</b> {0x28_u64}</td></tr>
<tr class="memdesc:a4466645355d762bff0d32378435316c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the memory size of our TLS PT_LOAD segment <br /></td></tr>
<tr class="separator:a4466645355d762bff0d32378435316c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e0c4fac39bf1d4ebc5acad61aff45"><td class="memItemLeft" align="right" valign="top"><a id="a1b5e0c4fac39bf1d4ebc5acad61aff45" name="a1b5e0c4fac39bf1d4ebc5acad61aff45"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_TLS_VADDR</b> {0x0000328000010000_u64}</td></tr>
<tr class="memdesc:a1b5e0c4fac39bf1d4ebc5acad61aff45"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the virtual address of our PT_TLS segment <br /></td></tr>
<tr class="separator:a1b5e0c4fac39bf1d4ebc5acad61aff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c708b766614d86f6b88f40e0302636c"><td class="memItemLeft" align="right" valign="top"><a id="a0c708b766614d86f6b88f40e0302636c" name="a0c708b766614d86f6b88f40e0302636c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_TLS_PADDR</b> {0x0000328000010000_u64}</td></tr>
<tr class="memdesc:a0c708b766614d86f6b88f40e0302636c"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the physical address of our PT_TLS segment <br /></td></tr>
<tr class="separator:a0c708b766614d86f6b88f40e0302636c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78785e9e1db88202adca48fe6eec8cc8"><td class="memItemLeft" align="right" valign="top"><a id="a78785e9e1db88202adca48fe6eec8cc8" name="a78785e9e1db88202adca48fe6eec8cc8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_TLS_FILSZ</b> {0x10_u64}</td></tr>
<tr class="memdesc:a78785e9e1db88202adca48fe6eec8cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the file size of our PT_TLS segment <br /></td></tr>
<tr class="separator:a78785e9e1db88202adca48fe6eec8cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3e5207c63fc2c65863c5d44d13f331"><td class="memItemLeft" align="right" valign="top"><a id="aed3e5207c63fc2c65863c5d44d13f331" name="aed3e5207c63fc2c65863c5d44d13f331"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_TLS_MEMSZ</b> {0x28_u64}</td></tr>
<tr class="memdesc:aed3e5207c63fc2c65863c5d44d13f331"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the memory size of our PT_TLS segment <br /></td></tr>
<tr class="separator:aed3e5207c63fc2c65863c5d44d13f331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011abec746309b3dc431380af24e4e56"><td class="memItemLeft" align="right" valign="top"><a id="a011abec746309b3dc431380af24e4e56" name="a011abec746309b3dc431380af24e4e56"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_GNU_STACK_VADDR</b> {0x0_u64}</td></tr>
<tr class="memdesc:a011abec746309b3dc431380af24e4e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the virtual address of our GNU_STACK segment <br /></td></tr>
<tr class="separator:a011abec746309b3dc431380af24e4e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997510426f1ccb263472650099e8c077"><td class="memItemLeft" align="right" valign="top"><a id="a997510426f1ccb263472650099e8c077" name="a997510426f1ccb263472650099e8c077"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_GNU_STACK_PADDR</b> {0x0_u64}</td></tr>
<tr class="memdesc:a997510426f1ccb263472650099e8c077"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the physical address of our GNU_STACK segment <br /></td></tr>
<tr class="separator:a997510426f1ccb263472650099e8c077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aac706a9b4053d935fd2039dcb3a2f"><td class="memItemLeft" align="right" valign="top"><a id="a33aac706a9b4053d935fd2039dcb3a2f" name="a33aac706a9b4053d935fd2039dcb3a2f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_GNU_STACK_FILSZ</b> {0x0_u64}</td></tr>
<tr class="memdesc:a33aac706a9b4053d935fd2039dcb3a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the file size of our GNU_STACK segment <br /></td></tr>
<tr class="separator:a33aac706a9b4053d935fd2039dcb3a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c606ead91d640dc76411bfea45e3be"><td class="memItemLeft" align="right" valign="top"><a id="ad4c606ead91d640dc76411bfea45e3be" name="ad4c606ead91d640dc76411bfea45e3be"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PT_GNU_STACK_MEMSZ</b> {0x0_u64}</td></tr>
<tr class="memdesc:ad4c606ead91d640dc76411bfea45e3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the memory size of our GNU_STACK segment <br /></td></tr>
<tr class="separator:ad4c606ead91d640dc76411bfea45e3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117821b8c8ad20e95f34850f6e0e0a06"><td class="memItemLeft" align="right" valign="top"><a id="a117821b8c8ad20e95f34850f6e0e0a06" name="a117821b8c8ad20e95f34850f6e0e0a06"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>POOL_SIZE</b> {4_umx}</td></tr>
<tr class="memdesc:a117821b8c8ad20e95f34850f6e0e0a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by most of the tests <br /></td></tr>
<tr class="separator:a117821b8c8ad20e95f34850f6e0e0a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91276df09dfde0a2549882000a12a473"><td class="memItemLeft" align="right" valign="top"><a id="a91276df09dfde0a2549882000a12a473" name="a91276df09dfde0a2549882000a12a473"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>LARGE_POOL_SIZE</b> {5000_umx}</td></tr>
<tr class="memdesc:a91276df09dfde0a2549882000a12a473"><td class="mdescLeft">&#160;</td><td class="mdescRight">only used by the dump test as this is too large for the stack <br /></td></tr>
<tr class="separator:a91276df09dfde0a2549882000a12a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837c93ffef232de5bee88ea310d6721e"><td class="memItemLeft" align="right" valign="top"><a id="a837c93ffef232de5bee88ea310d6721e" name="a837c93ffef232de5bee88ea310d6721e"></a>
bsl::array&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a>, LARGE_POOL_SIZE.get()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_pool</b> {}</td></tr>
<tr class="memdesc:a837c93ffef232de5bee88ea310d6721e"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for dump to prevent the unit test from running out of stack <br /></td></tr>
<tr class="separator:a837c93ffef232de5bee88ea310d6721e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22a8766a67a6ea11d6be39bc5d401ad"><td class="memItemLeft" align="right" valign="top"><a id="ac22a8766a67a6ea11d6be39bc5d401ad" name="ac22a8766a67a6ea11d6be39bc5d401ad"></a>
<a class="el" href="structloader_1_1state__save__t.html">loader::state_save_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_mk_state</b> {}</td></tr>
<tr class="memdesc:ac22a8766a67a6ea11d6be39bc5d401ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the mk_state for this test <br /></td></tr>
<tr class="separator:ac22a8766a67a6ea11d6be39bc5d401ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7966b9119363ff277141c4717c4f6385"><td class="memItemLeft" align="right" valign="top"><a id="a7966b9119363ff277141c4717c4f6385" name="a7966b9119363ff277141c4717c4f6385"></a>
<a class="el" href="structloader_1_1state__save__t.html">loader::state_save_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_root_vp_state</b> {}</td></tr>
<tr class="memdesc:a7966b9119363ff277141c4717c4f6385"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the root_vp_state for this test <br /></td></tr>
<tr class="separator:a7966b9119363ff277141c4717c4f6385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514c68d36e4888a8126151797dc08c17"><td class="memItemLeft" align="right" valign="top"><a id="a514c68d36e4888a8126151797dc08c17" name="a514c68d36e4888a8126151797dc08c17"></a>
<a class="el" href="structloader_1_1debug__ring__t.html">loader::debug_ring_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_debug_ring</b> {}</td></tr>
<tr class="memdesc:a514c68d36e4888a8126151797dc08c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the debug_ring for this test <br /></td></tr>
<tr class="separator:a514c68d36e4888a8126151797dc08c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7478459d0fdce571c78f36fd1baa04"><td class="memItemLeft" align="right" valign="top"><a id="a8a7478459d0fdce571c78f36fd1baa04" name="a8a7478459d0fdce571c78f36fd1baa04"></a>
<a class="el" href="namespaceloader.html#afd2bbbd3305d4d499c41035aee9f464e">loader::ext_elf_file_t</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>g_ext_elf_file</b> {}</td></tr>
<tr class="memdesc:a8a7478459d0fdce571c78f36fd1baa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the ext_elf_file for this test <br /></td></tr>
<tr class="separator:a8a7478459d0fdce571c78f36fd1baa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3227381992a93e8366b44c500c2442a7"><td class="memItemLeft" align="right" valign="top"><a id="a3227381992a93e8366b44c500c2442a7" name="a3227381992a93e8366b44c500c2442a7"></a>
lib::basic_page_table_t&lt; <a class="el" href="structlib_1_1l3e__t.html">lib::l3e_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>g_mut_rpt</b> {}</td></tr>
<tr class="memdesc:a3227381992a93e8366b44c500c2442a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the rpt for this test <br /></td></tr>
<tr class="separator:a3227381992a93e8366b44c500c2442a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2020 Assured Information Security, Inc.</dd>
<dd>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</dd>
<dd>
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</dd>
<dd>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</dd>
<dd>
Copyright (C) 2020 Assured Information Security, Inc.</dd>
<dd>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</dd>
<dd>
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</dd>
<dd>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. TODO:<ul>
<li>Add support for multiple extensions. For this to work, we will need support for PCID and the global flag should be turned off. This will ensure that swaps to another extension (which require a CR3 change), will not destroy performance. To ensure the hypervisor can support systems without PCID, projects that use more than one extension like MicroV should compile the additional extensions into both the main extension, and the additional ones. On systems that don't have PCID, it would call itself. Systems with PCID would call through IPC. You could then have compile/runtime flags for forcing one path over the other in situations where performace or security take precedence.</li>
<li>Since the microkernel doesn't have a timer, the only way another extension will execute is from some sort of IPC interface where an extension calls into another extension to perform an action and then returns a result. The best way to handle this would be to use an instruction sequence similar to a VMCall and VMExit. The extension would execute bf_ipc_op_call, which could take at most 6 arguments that match the SysV calling conventions. The additional extension would execute and then return using bf_ipc_op_return. There would need to be some logic in the syscall code to make sure that this return function was used properly (meaning you cannot return unless you have been called, and you cannot run if you have been called). From there, all that is finally needed is some way to share memory. There are two options here. Shared memory, or a memcpy ABI. IMO, we should use a memcpy ABI as shared memory really complicates things. If shared memory is used, we should make sure, that like freeing a page, unmapping shared memory is optional, meaning the microkernel is nor required to honor the request.</li>
<li>The TLS block that we use for the general purpose registers will need to be shared as it is currently a problem. This way, a swap to another extension only has to update the extension ID in that block, and then swap CR3. The best way to handle this would be to have the extension pool can allocate the shared portion of the TLS blocks for all of the online PPs and then give this page to each extension as it initializes. Then all we have to do is make sure that there is no state in there that would be a problem for the extensions to share, which right now is just the extension ID. If additional state is added to the ABI that is a problem, we will either have to copy the entire block on each swap, or make add a second page to the ABI, one that is shared, and one that is not. </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae65709df4ff7de439f99d4d60f00e461" name="ae65709df4ff7de439f99d4d60f00e461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65709df4ff7de439f99d4d60f00e461">&#9670;&nbsp;</a></span>dispatch_esr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_esr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__t.html">ext_t</a> *const&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the main entry point for all exceptions. This function will dispatch exceptions as needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">ext</td><td>the extension that made the syscall </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success if the exception was handled, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="aae4fe9f2dabf4bb568703d552a45bf46" name="aae4fe9f2dabf4bb568703d552a45bf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4fe9f2dabf4bb568703d552a45bf46">&#9670;&nbsp;</a></span>dispatch_syscall_intrinsic_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_intrinsic_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__t.html">ext_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_intrinsic_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">ext</td><td>the extension that made the syscall </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="namespacesyscall.html#a5d8fdd8c1f997a094e3a05f85caf9a8d" title="Indicates the syscall returned successfully.">syscall::BF_STATUS_SUCCESS</a> on success or an error code on failure. </dd></dl>

</div>
</div>
<a id="a84ae775746568d20d82e81eeaf1ca1de" name="a84ae775746568d20d82e81eeaf1ca1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ae775746568d20d82e81eeaf1ca1de">&#9670;&nbsp;</a></span>call_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::call_ext </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls an extension. This can be used to execute an extension's entry point, or it can be used to call an extension's callback that was registered using the entry point. It should be noted that once this function is called, it is likely that the extension will execute syscalls. When this happens, the extension will call back into the microkernel before this function has completed it's execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>the instruction pointer to call into </td></tr>
    <tr><td class="paramname">sp</td><td>the stack pointer to use </td></tr>
    <tr><td class="paramname">arg0</td><td>the first argument to pass the extension </td></tr>
    <tr><td class="paramname">arg1</td><td>the second argument to pass the extension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the exit status from the extension </dd></dl>

</div>
</div>
<a id="ad26d8c959ab4ef899aa1aacd865125cb" name="ad26d8c959ab4ef899aa1aacd865125cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26d8c959ab4ef899aa1aacd865125cb">&#9670;&nbsp;</a></span>debug_ring_write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::debug_ring_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structloader_1_1debug__ring__t.html">loader::debug_ring_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::char_type const&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs a character to the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_ring</td><td>the debug ring to output to </td></tr>
    <tr><td class="paramname">c</td><td>the character to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fa54b3ebcbb7d2912209b1d49ea465e" name="a8fa54b3ebcbb7d2912209b1d49ea465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa54b3ebcbb7d2912209b1d49ea465e">&#9670;&nbsp;</a></span>debug_ring_write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::debug_ring_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structloader_1_1debug__ring__t.html">loader::debug_ring_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::cstr_type const&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uintmx const&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs a string to the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_ring</td><td>the debug ring to output to </td></tr>
    <tr><td class="paramname">str</td><td>the string to output </td></tr>
    <tr><td class="paramname">len</td><td>the total number of bytes to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15e0f67879c50db1247bbbdfdb58f212" name="a15e0f67879c50db1247bbbdfdb58f212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e0f67879c50db1247bbbdfdb58f212">&#9670;&nbsp;</a></span>dispatch_syscall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_huge_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vmexit__log__t.html">vmexit_log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the main entry point for all syscalls. This function will dispatch syscalls as needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_huge_pool</td><td>the huge pool to use </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_log</td><td>the VMExit log to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a24800aba21a8559ecbd7ef285a47431a" name="a24800aba21a8559ecbd7ef285a47431a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24800aba21a8559ecbd7ef285a47431a">&#9670;&nbsp;</a></span>syscall_bf_callback_op_register_bootstrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_callback_op_register_bootstrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_callback_op_register_bootstrap syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a8b0214a050557fb168b6f5eecc231a03" name="a8b0214a050557fb168b6f5eecc231a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0214a050557fb168b6f5eecc231a03">&#9670;&nbsp;</a></span>syscall_bf_callback_op_register_vmexit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_callback_op_register_vmexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_callback_op_register_vmexit syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="aa19e7ef4800e9c4bfc9da8d13734e17f" name="aa19e7ef4800e9c4bfc9da8d13734e17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19e7ef4800e9c4bfc9da8d13734e17f">&#9670;&nbsp;</a></span>syscall_bf_callback_op_register_fail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_callback_op_register_fail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_callback_op_register_fail syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="af9523188a1f0f03fa2fe443d89714fb6" name="af9523188a1f0f03fa2fe443d89714fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9523188a1f0f03fa2fe443d89714fb6">&#9670;&nbsp;</a></span>dispatch_syscall_bf_callback_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_callback_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_callback_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a6478ca586a0561b7ff7e6e6293f3140a" name="a6478ca586a0561b7ff7e6e6293f3140a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6478ca586a0561b7ff7e6e6293f3140a">&#9670;&nbsp;</a></span>dispatch_syscall_bf_control_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_control_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_callback_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a47afdababe6e10dd2e7bb6d427a08d3b" name="a47afdababe6e10dd2e7bb6d427a08d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47afdababe6e10dd2e7bb6d427a08d3b">&#9670;&nbsp;</a></span>dispatch_syscall_bf_debug_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_debug_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>huge_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>ext_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vmexit__log__t.html">vmexit_log_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_debug_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">huge_pool</td><td>the huge pool to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
    <tr><td class="paramname">log</td><td>the VMExit log to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>
<p >TODO:</p><ul>
<li>If a bad address is given, it will segfault the kernel. This should be fixed to simply segfault the userspace application. To do that, we need to detect the page fault and return to userspace with the page fault information containing the state of the userspace ext and not the kernel, as the fault really came from the ext and not the kernel.</li>
<li>The reason this is not fixed right now is that either way, this will lead to something horrible happening, and execution will be stopped, so who segfaults is not that big of a deal, but for completness, this should be fixed in the future.</li>
</ul>

</div>
</div>
<a id="a476b9b2770e10a1877c3177b2be58146" name="a476b9b2770e10a1877c3177b2be58146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476b9b2770e10a1877c3177b2be58146">&#9670;&nbsp;</a></span>syscall_bf_handle_op_open_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_handle_op_open_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_handle_op_open_handle syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="aaa7dd3a519959ea7a0752b6128140afc" name="aaa7dd3a519959ea7a0752b6128140afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7dd3a519959ea7a0752b6128140afc">&#9670;&nbsp;</a></span>syscall_bf_handle_op_close_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_handle_op_close_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_handle_op_close_handle syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a2e0b280be30c71238da9a5b6e6ef8536" name="a2e0b280be30c71238da9a5b6e6ef8536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0b280be30c71238da9a5b6e6ef8536">&#9670;&nbsp;</a></span>dispatch_syscall_bf_handle_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_handle_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_handle_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a9e78789d74bf16c9d67d6034bbdf2f9e" name="a9e78789d74bf16c9d67d6034bbdf2f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78789d74bf16c9d67d6034bbdf2f9e">&#9670;&nbsp;</a></span>syscall_bf_mem_op_alloc_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_mem_op_alloc_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_mem_op_alloc_page syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a141d8cc0c90fee0c07adf1e7183a23c9" name="a141d8cc0c90fee0c07adf1e7183a23c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141d8cc0c90fee0c07adf1e7183a23c9">&#9670;&nbsp;</a></span>syscall_bf_mem_op_alloc_huge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_mem_op_alloc_huge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_huge_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_mem_op_alloc_huge syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_huge_pool</td><td>the huge pool to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="adae7db5482172a0e175db5478b79742d" name="adae7db5482172a0e175db5478b79742d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae7db5482172a0e175db5478b79742d">&#9670;&nbsp;</a></span>dispatch_syscall_bf_mem_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_mem_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_huge_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_mem_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_huge_pool</td><td>the huge pool to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="acdf1419b3b93083466403c24fde3b528" name="acdf1419b3b93083466403c24fde3b528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf1419b3b93083466403c24fde3b528">&#9670;&nbsp;</a></span>syscall_bf_vm_op_create_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vm_op_create_vm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vm_op_create_vm syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a7b61c75777c9f60c9594da5a8a4e6589" name="a7b61c75777c9f60c9594da5a8a4e6589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b61c75777c9f60c9594da5a8a4e6589">&#9670;&nbsp;</a></span>syscall_bf_vm_op_destroy_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vm_op_destroy_vm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vm_op_destroy_vm syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a3003baba48d788a2e93543562f769b86" name="a3003baba48d788a2e93543562f769b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3003baba48d788a2e93543562f769b86">&#9670;&nbsp;</a></span>syscall_bf_vm_op_map_direct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vm_op_map_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vm_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vm_op_map_direct syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="ae65d49f5bbf5c04479a0ca6aacf6b7f7" name="ae65d49f5bbf5c04479a0ca6aacf6b7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65d49f5bbf5c04479a0ca6aacf6b7f7">&#9670;&nbsp;</a></span>syscall_bf_vm_op_unmap_direct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vm_op_unmap_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vm_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vm_op_unmap_direct syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="ac514b504bb4979b2ca94a0bc414e4d53" name="ac514b504bb4979b2ca94a0bc414e4d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac514b504bb4979b2ca94a0bc414e4d53">&#9670;&nbsp;</a></span>syscall_bf_vm_op_unmap_direct_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vm_op_unmap_direct_broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vm_op_unmap_direct_broadcast syscall. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>
<p >TODO:</p><ul>
<li>We need to implement this. The reason this exists is that an extension may wish to map memory, and then access it from any PP. When this happens, the TLB will then contain the memory associated with that PP.</li>
</ul>

</div>
</div>
<a id="a4c1fe838fdcd20b7dbf1274d6eba524f" name="a4c1fe838fdcd20b7dbf1274d6eba524f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1fe838fdcd20b7dbf1274d6eba524f">&#9670;&nbsp;</a></span>syscall_bf_vm_op_tlb_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vm_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vm_op_tlb_flush syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a92b602e0eaac7f3322b317efc38629c9" name="a92b602e0eaac7f3322b317efc38629c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b602e0eaac7f3322b317efc38629c9">&#9670;&nbsp;</a></span>dispatch_syscall_bf_vm_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_vm_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_vm_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a97fca857182b52c2175eb9361725e966" name="a97fca857182b52c2175eb9361725e966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fca857182b52c2175eb9361725e966">&#9670;&nbsp;</a></span>syscall_bf_vp_op_create_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vp_op_create_vp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vp_op_create_vp syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a19471bf7fe69104e467e583110d94d05" name="a19471bf7fe69104e467e583110d94d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19471bf7fe69104e467e583110d94d05">&#9670;&nbsp;</a></span>syscall_bf_vp_op_destroy_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vp_op_destroy_vp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vp_op_destroy_vp syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="acf626dc7af8cb4b66c49a4995cfa53d7" name="acf626dc7af8cb4b66c49a4995cfa53d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf626dc7af8cb4b66c49a4995cfa53d7">&#9670;&nbsp;</a></span>dispatch_syscall_bf_vp_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_vp_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_vp_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a81f7c45aef53b2a2d74a219f22135fe3" name="a81f7c45aef53b2a2d74a219f22135fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f7c45aef53b2a2d74a219f22135fe3">&#9670;&nbsp;</a></span>syscall_bf_vs_op_set_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_set_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>advance_ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_set_active syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
    <tr><td class="paramname">advance_ip</td><td>if true, the IP of the requested VS is advanced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="ac391aa1224fde38193b1cd8d5bef9e18" name="ac391aa1224fde38193b1cd8d5bef9e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac391aa1224fde38193b1cd8d5bef9e18">&#9670;&nbsp;</a></span>syscall_bf_vs_op_create_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_create_vs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_create_vs syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a1d1a3d9949692ff6e1137e257e1661b5" name="a1d1a3d9949692ff6e1137e257e1661b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1a3d9949692ff6e1137e257e1661b5">&#9670;&nbsp;</a></span>syscall_bf_vs_op_destroy_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_destroy_vs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_destroy_vs syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a9e455a57629b4340354beef27650f3f7" name="a9e455a57629b4340354beef27650f3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e455a57629b4340354beef27650f3f7">&#9670;&nbsp;</a></span>syscall_bf_vs_op_init_as_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_init_as_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_init_as_root syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a4f94052f4b64ac71452d17cf27bf44cd" name="a4f94052f4b64ac71452d17cf27bf44cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f94052f4b64ac71452d17cf27bf44cd">&#9670;&nbsp;</a></span>syscall_bf_vs_op_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_read syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a71c2b8b58b510efe221679131fd15b80" name="a71c2b8b58b510efe221679131fd15b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c2b8b58b510efe221679131fd15b80">&#9670;&nbsp;</a></span>syscall_bf_vs_op_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_write syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a4c2acf56598a7bc5c792cb48f7c3934d" name="a4c2acf56598a7bc5c792cb48f7c3934d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2acf56598a7bc5c792cb48f7c3934d">&#9670;&nbsp;</a></span>syscall_bf_vs_op_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>advance_ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_run syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
    <tr><td class="paramname">advance_ip</td><td>if true, the IP of the requested VS is advanced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="abebf1f9c353fa65adec51aae626954a1" name="abebf1f9c353fa65adec51aae626954a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebf1f9c353fa65adec51aae626954a1">&#9670;&nbsp;</a></span>syscall_bf_vs_op_run_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_run_current </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>advance_ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_run_current syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">advance_ip</td><td>if true, the IP of the requested VS is advanced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="aebf840d1227a58c118f26c80e35e559b" name="aebf840d1227a58c118f26c80e35e559b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf840d1227a58c118f26c80e35e559b">&#9670;&nbsp;</a></span>syscall_bf_vs_op_advance_ip_and_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_advance_ip_and_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_advance_ip syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="ab8822641a948344f66befc4612e4edc2" name="ab8822641a948344f66befc4612e4edc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8822641a948344f66befc4612e4edc2">&#9670;&nbsp;</a></span>syscall_bf_vs_op_advance_ip_and_run_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_advance_ip_and_run_current </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_advance_ip_and_run_current syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a48af1a8fab207850a2bf9de42e2c67b0" name="a48af1a8fab207850a2bf9de42e2c67b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48af1a8fab207850a2bf9de42e2c67b0">&#9670;&nbsp;</a></span>syscall_bf_vs_op_promote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_promote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_promote syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a5176f1bd8e832d3fc19c55bc420b1890" name="a5176f1bd8e832d3fc19c55bc420b1890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5176f1bd8e832d3fc19c55bc420b1890">&#9670;&nbsp;</a></span>syscall_bf_vs_op_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_clear syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="ae2f802d1c7fb9d3df9469e458f9abb8d" name="ae2f802d1c7fb9d3df9469e458f9abb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f802d1c7fb9d3df9469e458f9abb8d">&#9670;&nbsp;</a></span>syscall_bf_vs_op_migrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_migrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_migrate syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="ab331dfb5fad83ea3674dba33782e4f92" name="ab331dfb5fad83ea3674dba33782e4f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab331dfb5fad83ea3674dba33782e4f92">&#9670;&nbsp;</a></span>syscall_bf_vs_op_advance_ip_and_set_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_advance_ip_and_set_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_advance_ip_and_set_active syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="ab242fd93aa872b79934850494ac4e78b" name="ab242fd93aa872b79934850494ac4e78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab242fd93aa872b79934850494ac4e78b">&#9670;&nbsp;</a></span>syscall_bf_vs_op_tlb_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_vs_op_tlb_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_vs_op_tlb_flush syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a543427590741f31acf43ccd5e5d938bd" name="a543427590741f31acf43ccd5e5d938bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543427590741f31acf43ccd5e5d938bd">&#9670;&nbsp;</a></span>dispatch_syscall_bf_vs_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_vs_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#ac368255bdd961fd8997f08099b0f0947">page_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_page_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__pool__t.html">ext_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_ext_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_vs_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_page_pool</td><td>the page_pool_t to use </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">mut_ext_pool</td><td>the <a class="el" href="classmk_1_1ext__pool__t.html" title="Defines the microkernel&#39;s extension pool.">ext_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a61e4a4968133560462fcc7a3af6867fb" name="a61e4a4968133560462fcc7a3af6867fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e4a4968133560462fcc7a3af6867fb">&#9670;&nbsp;</a></span>has_active_ext_registered_a_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::has_active_ext_registered_a_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::string_view const &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a callback has already been registered by the active ext. Returns false otherwise. </p>
<hr  />
 <h2>Validation Functions </h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">callback</td><td>the callback to verify </td></tr>
    <tr><td class="paramname">name</td><td>the name of the callback to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a callback has already been registered. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a1cb6279b511466549899f8f6605824f8" name="a1cb6279b511466549899f8f6605824f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb6279b511466549899f8f6605824f8">&#9670;&nbsp;</a></span>has_any_ext_registered_a_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::has_any_ext_registered_a_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmk_1_1ext__t.html">ext_t</a> const *const&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::string_view const &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a callback has already been registered by any ext. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ext</td><td>the registered extension </td></tr>
    <tr><td class="paramname">name</td><td>the name of the callback to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a callback has already been registered. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="af8287bedcf3b247f1f2955eb30d39e9e" name="af8287bedcf3b247f1f2955eb30d39e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8287bedcf3b247f1f2955eb30d39e9e">&#9670;&nbsp;</a></span>is_version_supported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_version_supported </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided version is supported. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register containing the version to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the provided version is supported. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a0058080476c0a511ebec4657a2668a4a" name="a0058080476c0a511ebec4657a2668a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0058080476c0a511ebec4657a2668a4a">&#9670;&nbsp;</a></span>verify_handle_for_current_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::verify_handle_for_current_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the handle provided in tls.reg0 is valid. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the handle provided in tls.reg0 is valid. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="ac9627329a7b9a859d48da79aa5c916da" name="ac9627329a7b9a859d48da79aa5c916da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9627329a7b9a859d48da79aa5c916da">&#9670;&nbsp;</a></span>is_the_active_ext_the_vmexit_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_the_active_ext_the_vmexit_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the active extension is the extension that registered for VMExits. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the active extension is the extension that registered for VMExits. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a032ea30af244751fd8a8eb4f66b39a0d" name="a032ea30af244751fd8a8eb4f66b39a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032ea30af244751fd8a8eb4f66b39a0d">&#9670;&nbsp;</a></span>is_vm_destroyable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vm_destroyable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vm_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmk_1_1vm__t.html" title="Defines the microkernel&#39;s notion of a VM.">vm_t</a> associated with the provided vmid is destroyable. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="classmk_1_1vm__t.html" title="Defines the microkernel&#39;s notion of a VM.">vm_t</a> associated with the provided vmid is destroyable. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a96d716286228edca03a2cd9ab79b4bee" name="a96d716286228edca03a2cd9ab79b4bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d716286228edca03a2cd9ab79b4bee">&#9670;&nbsp;</a></span>is_vp_destroyable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vp_destroyable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> associated with the provided vpid is destroyable. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vpid</td><td>the ID of the VP to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> associated with the provided vpid is destroyable. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a12ce2a4ebd79459b707314370e4921ed" name="a12ce2a4ebd79459b707314370e4921ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ce2a4ebd79459b707314370e4921ed">&#9670;&nbsp;</a></span>is_vs_destroyable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vs_destroyable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is destroyable. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is destroyable. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="acdde4ffb5001f92b9ad3bac6a3cb3215" name="acdde4ffb5001f92b9ad3bac6a3cb3215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdde4ffb5001f92b9ad3bac6a3cb3215">&#9670;&nbsp;</a></span>is_vs_migratable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vs_migratable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is migratable to the PP associated with the provided ppid. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VP to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is migratable to the PP associated with the provided ppid. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a46e1746633cc844f4239a66f65105f7c" name="a46e1746633cc844f4239a66f65105f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e1746633cc844f4239a66f65105f7c">&#9670;&nbsp;</a></span>is_vp_assigned_to_vm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vp_assigned_to_vm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> associated with the provided vpid is assigned to the provided VM. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vpid</td><td>the ID of the VP to query </td></tr>
    <tr><td class="paramname">vmid</td><td>the ID of the VM to verify assignment with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> associated with the provided vpid is assigned to the provided VM. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="aa4490d7c6f76d65d7a6c1147be982bdf" name="aa4490d7c6f76d65d7a6c1147be982bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4490d7c6f76d65d7a6c1147be982bdf">&#9670;&nbsp;</a></span>is_vs_assigned_to_vp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vs_assigned_to_vp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is assigned to the provided VP. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS to query </td></tr>
    <tr><td class="paramname">vpid</td><td>the ID of the VP to verify assignment with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is assigned to the provided VP. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="abfa5524e7c912547da85ecfb9cd567e5" name="abfa5524e7c912547da85ecfb9cd567e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa5524e7c912547da85ecfb9cd567e5">&#9670;&nbsp;</a></span>is_vs_assigned_to_current_pp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vs_assigned_to_current_pp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is assigned to the provided PP. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is assigned to the provided PP. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="aa1efc6dbba598be2c36974f76a988a07" name="aa1efc6dbba598be2c36974f76a988a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1efc6dbba598be2c36974f76a988a07">&#9670;&nbsp;</a></span>is_vs_a_root_vs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vs_a_root_vs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> is a root <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a>, meaning it is a <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> that is allowed to contain root state. A root VS will have the same ID as the ppid. Using the current VMID will not work because a VMID is not present when a root VM is being set up, and the root VM is able to create additional <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a>'s for VSM and nested virtualization support, just like guests, so the only way to determine this is, the VSID is the same as the PPID, which is only possible when a root VS is being created. All other VSIDs will be larger then the PPIDs once the system has been bootstrapped which means they will not be the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> associated with the provided vsid is assigned to the provided PP. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a6f1fb04f12addcf9c885a79788ca5026" name="a6f1fb04f12addcf9c885a79788ca5026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1fb04f12addcf9c885a79788ca5026">&#9670;&nbsp;</a></span>is_vp_active_on_another_pp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vp_active_on_another_pp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vpid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the requested <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> is active on another PP. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vpid</td><td>the ID of the VP to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the requested <a class="el" href="classmk_1_1vp__t.html" title="Defines the microkernel&#39;s notion of a VP.">vp_t</a> is active on another PP. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a421ef72c6b7e3447e2e57ec983ac5e79" name="a421ef72c6b7e3447e2e57ec983ac5e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421ef72c6b7e3447e2e57ec983ac5e79">&#9670;&nbsp;</a></span>is_vs_active_on_another_pp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_vs_active_on_another_pp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>vsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the requested <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> is active on another PP. Returns false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
    <tr><td class="paramname">vsid</td><td>the ID of the VS to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the requested <a class="el" href="classmk_1_1vs__t.html" title="Defines the microkernel&#39;s notion of a VS.">vs_t</a> is active on another PP. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a2f8a206593609b6b553bef3e3c42dc69" name="a2f8a206593609b6b553bef3e3c42dc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8a206593609b6b553bef3e3c42dc69">&#9670;&nbsp;</a></span>get_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_callback </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_umx
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a callback address on success, or bsl::safe_umx::failure() on failure. </p>
<hr  />
 <h2>Get Functions </h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the vmid from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a callback address on success, or bsl::safe_umx::failure() on failure. </dd></dl>
<p >NOTE:</p><ul>
<li>There is no way to know if the provided address actually points to a function that performs the action that is supposed to be handled, but we can at least ensure the address is in the right range as a sanity check.</li>
</ul>

</div>
</div>
<a id="a53273256d4a209969f3286e8baa010ec" name="a53273256d4a209969f3286e8baa010ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53273256d4a209969f3286e8baa010ec">&#9670;&nbsp;</a></span>get_ppid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_ppid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a ppid if the provided register contains a valid ppid. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">reg</td><td>the register to get the ppid from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a ppid if the provided register contains a valid ppid. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="a155df731475bb86c52d4fc45adabaab5" name="a155df731475bb86c52d4fc45adabaab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155df731475bb86c52d4fc45adabaab5">&#9670;&nbsp;</a></span>get_vmid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_vmid </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a vmid if the provided register contains a valid vmid. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the vmid from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a vmid if the provided register contains a valid vmid. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="a8b92320ce1ae23d5031c864e19df4eb4" name="a8b92320ce1ae23d5031c864e19df4eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b92320ce1ae23d5031c864e19df4eb4">&#9670;&nbsp;</a></span>get_allocated_vmid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_allocated_vmid </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vm__pool__t.html">vm_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vm_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a vmid if the provided register contains a valid vmid and the VM associated with the vmid is allocated. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the vmid from. </td></tr>
    <tr><td class="paramname">vm_pool</td><td>the <a class="el" href="classmk_1_1vm__pool__t.html" title="Defines the microkernel&#39;s vm_pool_t.">vm_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a vmid if the provided register contains a valid vmid and the VM associated with the vmid is allocated. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="adfa515649dfbc48d3fe328728ec4ece4" name="adfa515649dfbc48d3fe328728ec4ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa515649dfbc48d3fe328728ec4ece4">&#9670;&nbsp;</a></span>get_vpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_vpid </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a vpid if the provided register contains a valid vpid. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the vpid from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a vpid if the provided register contains a valid vpid. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="afe461716b7039448199b5601ecd874e1" name="afe461716b7039448199b5601ecd874e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe461716b7039448199b5601ecd874e1">&#9670;&nbsp;</a></span>get_allocated_vpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_allocated_vpid </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vp__pool__t.html">vp_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vp_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a vpid if the provided register contains a valid vpid and the VM associated with the vpid is allocated. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the vpid from. </td></tr>
    <tr><td class="paramname">vp_pool</td><td>the <a class="el" href="classmk_1_1vp__pool__t.html" title="Defines the microkernel&#39;s vp_pool_t.">vp_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a vpid if the provided register contains a valid vpid and the VM associated with the vpid is allocated. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="a6b7a280b14132134dd68de49e1c244a2" name="a6b7a280b14132134dd68de49e1c244a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7a280b14132134dd68de49e1c244a2">&#9670;&nbsp;</a></span>get_vsid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_vsid </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a vsid if the provided register contains a valid vsid. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the vsid from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a vsid if the provided register contains a valid vsid. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="a1b13d2620568ce050973bc23c8daeb98" name="a1b13d2620568ce050973bc23c8daeb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b13d2620568ce050973bc23c8daeb98">&#9670;&nbsp;</a></span>get_allocated_vsid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_allocated_vsid </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a vsid if the provided register contains a valid vsid and the VM associated with the vsid is allocated. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the vsid from. </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a vsid if the provided register contains a valid vsid and the VM associated with the vsid is allocated. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="aec2fccc0a99fde0555dadc13e5cd0b13" name="aec2fccc0a99fde0555dadc13e5cd0b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2fccc0a99fde0555dadc13e5cd0b13">&#9670;&nbsp;</a></span>get_locally_assigned_vsid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_locally_assigned_vsid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>vs_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a vsid if the provided register contains a valid vsid, the VM associated with the vsid is allocated and locally assigned to the current PP. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">reg</td><td>the register to get the vsid from. </td></tr>
    <tr><td class="paramname">vs_pool</td><td>the <a class="el" href="classmk_1_1vs__pool__t.html" title="Defines the microkernel&#39;s vs_pool_t.">vs_pool_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a vsid if the provided register contains a valid vsid, the VM associated with the vsid is allocated and locally assigned to the current PP. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="abf01d4bf17d1e9167e0c6bf5dd5562e9" name="abf01d4bf17d1e9167e0c6bf5dd5562e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf01d4bf17d1e9167e0c6bf5dd5562e9">&#9670;&nbsp;</a></span>get_extid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_extid </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_u16
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a extid if the provided register contains a valid extid. Otherwise, this function returns bsl::safe_u16::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the extid from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a extid if the provided register contains a valid extid. Otherwise, this function returns bsl::safe_u16::failure(). </dd></dl>

</div>
</div>
<a id="ace179a135eb47275e6ffbcd99ea9e98e" name="ace179a135eb47275e6ffbcd99ea9e98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace179a135eb47275e6ffbcd99ea9e98e">&#9670;&nbsp;</a></span>get_reg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_reg </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9">syscall::bf_reg_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a bf_reg_t if the provided register contains a valid bf_reg_t. Otherwise, this function returns <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7" title="defines an invalid bf_reg_t">syscall::bf_reg_t::bf_reg_t_invalid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the vsid from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a bf_reg_t if the provided register contains a valid bf_reg_t. Otherwise, this function returns <a class="el" href="namespacesyscall.html#a88e3c7a4f139e3d2c85be4c8b8fc90b9a4c9d880e0da77fe44c74e0f4c9d565b7" title="defines an invalid bf_reg_t">syscall::bf_reg_t::bf_reg_t_invalid</a>. </dd></dl>

</div>
</div>
<a id="ad64a8ba3d132b3bd204164930cfc9b00" name="ad64a8ba3d132b3bd204164930cfc9b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64a8ba3d132b3bd204164930cfc9b00">&#9670;&nbsp;</a></span>get_phys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_phys </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_umx
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a physical address if the provided register contains a valid physical address. Otherwise, this function returns bsl::safe_umx::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the physical address from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a physical address if the provided register contains a valid physical address. Otherwise, this function returns bsl::safe_umx::failure(). </dd></dl>

</div>
</div>
<a id="a655021c523eb282865d4dd91cd328054" name="a655021c523eb282865d4dd91cd328054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655021c523eb282865d4dd91cd328054">&#9670;&nbsp;</a></span>get_direct_map_virt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_direct_map_virt </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_umx
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a virtual address if the provided register contains a valid virtual address. Otherwise, this function returns bsl::safe_umx::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the virtual address from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a virtual address if the provided register contains a valid virtual address. Otherwise, this function returns bsl::safe_umx::failure(). </dd></dl>

</div>
</div>
<a id="ad53893866baba0abfd4c855700e20083" name="ad53893866baba0abfd4c855700e20083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53893866baba0abfd4c855700e20083">&#9670;&nbsp;</a></span>get_gla()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_gla </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_umx
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a guest linear address if the provided register contains a valid guest linear address. Otherwise, this function returns bsl::safe_umx::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the guest linear address from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a guest linear address if the provided register contains a valid guest linear address. Otherwise, this function returns bsl::safe_umx::failure(). </dd></dl>

</div>
</div>
<a id="a023e3d896ab35eacb98f4b2b6a649398" name="a023e3d896ab35eacb98f4b2b6a649398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023e3d896ab35eacb98f4b2b6a649398">&#9670;&nbsp;</a></span>get_huge_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_huge_size </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_u64
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns a huge allocation size if the provided register contains a valid huge allocation size. Otherwise, this function returns bsl::safe_u64::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the size from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns a huge allocation size if the provided register contains a valid huge allocation size. Otherwise, this function returns bsl::safe_u64::failure(). </dd></dl>

</div>
</div>
<a id="a6138939aa797078c6c913852f8036bd3" name="a6138939aa797078c6c913852f8036bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6138939aa797078c6c913852f8036bd3">&#9670;&nbsp;</a></span>get_msr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_msr </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt; bsl::safe_u32
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input register, returns an msr index if the provided register contains a valid msr index. Otherwise, this function returns bsl::safe_u32::failure(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the register to get the msr index from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given an input register, returns an msr index if the provided register contains a valid msr index. Otherwise, this function returns bsl::safe_u32::failure(). </dd></dl>
<p >TODO:</p><ul>
<li>We need to compile a whitelist of safe MSRs that an extension can read and then check to make sure that "reg" is in the list. The easiest way to do this is to see what MicroV needs and then limit this to that list. Any additional MSRs can be added on demand from the community as needed.</li>
</ul>

</div>
</div>
<a id="ae79dcd69e2ef1acdb29be219ebf864b5" name="ae79dcd69e2ef1acdb29be219ebf864b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79dcd69e2ef1acdb29be219ebf864b5">&#9670;&nbsp;</a></span>report_syscall_unknown_unsupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::report_syscall_unknown_unsupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the user that the syscall is unknown or is not supported by this hypervisor. </p>
<hr  />
 <h2>Report Unsupported Functions </h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns <a class="el" href="namespacesyscall.html#a159ff5cbb2d567a020ef371c22905182" title="Indicates the provided handle is invalid.">syscall::BF_STATUS_FAILURE_UNSUPPORTED</a>. </dd></dl>

</div>
</div>
<a id="a7aa9defe7ec65b4106bfd37668ddb27d" name="a7aa9defe7ec65b4106bfd37668ddb27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa9defe7ec65b4106bfd37668ddb27d">&#9670;&nbsp;</a></span>get_current_tls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::get_current_tls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structmk_1_1tls__t.html">tls_t</a> *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current TLS block. DO NOT USE THIS API!!! The only code that should use this is the debugging logic. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current TLS block </dd></dl>

</div>
</div>
<a id="a8928ef3355f6cdf6c9cca0fb0e261744" name="a8928ef3355f6cdf6c9cca0fb0e261744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8928ef3355f6cdf6c9cca0fb0e261744">&#9670;&nbsp;</a></span>dispatch_esr_trampoline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::dispatch_esr_trampoline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> *const&#160;</td>
          <td class="paramname"><em>pmut_tls</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove me. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success if the exception was handled, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="ae1d595bab8d47eec8769e21497b123d2" name="ae1d595bab8d47eec8769e21497b123d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d595bab8d47eec8769e21497b123d2">&#9670;&nbsp;</a></span>dispatch_syscall_trampoline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">C auto mk::dispatch_syscall_trampoline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> *const&#160;</td>
          <td class="paramname"><em>pmut_tls</em></td><td>)</td>
          <td> -&gt; bsl::uint64
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove me </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a7302966b4039281516b43e6d5794996c" name="a7302966b4039281516b43e6d5794996c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7302966b4039281516b43e6d5794996c">&#9670;&nbsp;</a></span>mk_main()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">C auto mk::mk_main </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structloader_1_1mk__args__t.html">loader::mk_args_t</a> *const&#160;</td>
          <td class="paramname"><em>pmut_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> *const&#160;</td>
          <td class="paramname"><em>pmut_tls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the main entry point of the microkernel. This function is called by the loader and is responsible for starting the hypervisor on a specific core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmut_args</td><td>the loader provided arguments to the microkernel. </td></tr>
    <tr><td class="paramname">pmut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a56c708428e2e68ae29107d98031de2a0" name="a56c708428e2e68ae29107d98031de2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c708428e2e68ae29107d98031de2a0">&#9670;&nbsp;</a></span>promote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::promote </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uintmx const&#160;</td>
          <td class="paramname"><em>ec</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promotes the current physical processor. Specifically, this is called from the microkernel's POV and tells the microkernel to transition the CPU's execution to the provided state, which will conclude the execution of the microkernel in favor of whatever is in the state, effectively stopping the hypervisor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state to promote to </td></tr>
    <tr><td class="paramname">ec</td><td>the exit code to provide </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a662c83f9fb89c6b2c20bc15299fe35b9" name="a662c83f9fb89c6b2c20bc15299fe35b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662c83f9fb89c6b2c20bc15299fe35b9">&#9670;&nbsp;</a></span>return_to_mk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::return_to_mk </td>
          <td>(</td>
          <td class="paramtype">bsl::errc_type const&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns to the microkernel after the execution of call_ext. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>the status code from the extension to forward to the microkernel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7cee043f03590440fb01726b033ae7e" name="ad7cee043f03590440fb01726b033ae7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cee043f03590440fb01726b033ae7e">&#9670;&nbsp;</a></span>serial_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::serial_write </td>
          <td>(</td>
          <td class="paramtype">bsl::cstr_type const&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uintmx const&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs a string to the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to output </td></tr>
    <tr><td class="paramname">len</td><td>the total number of bytes to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3be208ecee964c8a1442c00f99c9b342" name="a3be208ecee964c8a1442c00f99c9b342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be208ecee964c8a1442c00f99c9b342">&#9670;&nbsp;</a></span>serial_write_c()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::serial_write_c </td>
          <td>(</td>
          <td class="paramtype">bsl::char_type const&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a character "c" to the serial device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the character to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecbdbf9e276ac3be9ca23c02ad0adc9d" name="aecbdbf9e276ac3be9ca23c02ad0adc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbdbf9e276ac3be9ca23c02ad0adc9d">&#9670;&nbsp;</a></span>serial_write_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::serial_write_hex </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a hexidecimal number "val" to the serial device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the hexidecimal number to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa941bbe2f352c72cafd766241f9ee689" name="aa941bbe2f352c72cafd766241f9ee689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa941bbe2f352c72cafd766241f9ee689">&#9670;&nbsp;</a></span>vmexit_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::vmexit_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vs__pool__t.html">vs_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_vs_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1vmexit__log__t.html">vmexit_log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the main entry point for VMExits that occur after a successful launch of the hypervisor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">mut_vs_pool</td><td>the VPS pool to use </td></tr>
    <tr><td class="paramname">mut_log</td><td>the VMExit log to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success on success, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="abe65b2582c07218fc317cc3a2b4717aa" name="abe65b2582c07218fc317cc3a2b4717aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe65b2582c07218fc317cc3a2b4717aa">&#9670;&nbsp;</a></span>dispatch_esr_nmi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::dispatch_esr_nmi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the main entry point for NMI exceptions (which on AMD do not occur as NMIs are blocked). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b10d3ace45267b4878cf94a3d02b0ab" name="a2b10d3ace45267b4878cf94a3d02b0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b10d3ace45267b4878cf94a3d02b0ab">&#9670;&nbsp;</a></span>intrinsic_invlpga()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::intrinsic_invlpga </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>asid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements intrinsic_t::invlpga. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>n/a </td></tr>
    <tr><td class="paramname">asid</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0841f1656677dfadd9f6970520fe17e8" name="a0841f1656677dfadd9f6970520fe17e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0841f1656677dfadd9f6970520fe17e8">&#9670;&nbsp;</a></span>intrinsic_vmrun() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmrun </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pmut_guest_vmcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uintmx const&#160;</td>
          <td class="paramname"><em>guest_vmcb_phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pmut_host_vmcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uintmx const&#160;</td>
          <td class="paramname"><em>host_vmcb_phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pmut_missing_registers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::uintmx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the VMRun instruction. When this function returns a "VMExit" has occurred and must be handled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmut_guest_vmcb</td><td>a pointer to the guest VMCB </td></tr>
    <tr><td class="paramname">guest_vmcb_phys</td><td>the physical address of the guest VMCB </td></tr>
    <tr><td class="paramname">pmut_host_vmcb</td><td>a pointer to the host VMCB </td></tr>
    <tr><td class="paramname">host_vmcb_phys</td><td>the physical address of the host VMCB </td></tr>
    <tr><td class="paramname">pmut_missing_registers</td><td>a pointer to the missing registers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the exit reason associated with the VMExit </dd></dl>

</div>
</div>
<a id="aa78e6f5ee0d450c43ca06c103263cad3" name="aa78e6f5ee0d450c43ca06c103263cad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78e6f5ee0d450c43ca06c103263cad3">&#9670;&nbsp;</a></span>vector_to_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::vector_to_name </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> -&gt; bsl::string_view
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of an ESR given it's vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the vector of the ESR to get the name for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the name of an ESR given it's vector </dd></dl>

</div>
</div>
<a id="afccedebac879849914c598286b6f9245" name="afccedebac879849914c598286b6f9245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccedebac879849914c598286b6f9245">&#9670;&nbsp;</a></span>dispatch_esr_dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::dispatch_esr_dump </td>
          <td>(</td>
          <td class="paramtype">bsl::string_view const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the contents of a register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the register </td></tr>
    <tr><td class="paramname">val</td><td>the value of the register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefba1e2a5e3237767f02ea8f902b624b" name="aefba1e2a5e3237767f02ea8f902b624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefba1e2a5e3237767f02ea8f902b624b">&#9670;&nbsp;</a></span>dispatch_esr_dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::dispatch_esr_dump </td>
          <td>(</td>
          <td class="paramtype">bsl::string_view const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u16 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the contents of a register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the register </td></tr>
    <tr><td class="paramname">val</td><td>the value of the register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada7d6ebf9a08f95510e6bbc50fad3db7" name="ada7d6ebf9a08f95510e6bbc50fad3db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7d6ebf9a08f95510e6bbc50fad3db7">&#9670;&nbsp;</a></span>dispatch_esr_dump_with_segment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::dispatch_esr_dump_with_segment </td>
          <td>(</td>
          <td class="paramtype">bsl::string_view const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>seg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the contents of a register and it's segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the register </td></tr>
    <tr><td class="paramname">val</td><td>the value of the register </td></tr>
    <tr><td class="paramname">seg</td><td>the value of the register's segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a654cd9af16bc0d6d34bcd85bbbd4a781" name="a654cd9af16bc0d6d34bcd85bbbd4a781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654cd9af16bc0d6d34bcd85bbbd4a781">&#9670;&nbsp;</a></span>is_mk_exception()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::is_mk_exception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em></td><td>)</td>
          <td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the exception came from the microkernel. Returns false if the exception came from an extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the exception came from the microkernel. Returns false if the exception came from an extension </dd></dl>

</div>
</div>
<a id="a99408faee38fd92c72a9ac179f2b5672" name="a99408faee38fd92c72a9ac179f2b5672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99408faee38fd92c72a9ac179f2b5672">&#9670;&nbsp;</a></span>send_exception_to_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::send_exception_to_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>errc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_u64 const &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the exception to the extension so that it can handle it. Only exceptions that originate from the extension can be handled by the exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
    <tr><td class="paramname">errc</td><td>the reason for the failure, which is CPU specific. On x86, this is a combination of the exception vector and error code. </td></tr>
    <tr><td class="paramname">addr</td><td>contains a faulting address if the fail reason is associated with an error that involves a faulting address ( for example like a page fault). Otherwise, the value of this input is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success if the fail was handled, bsl::errc_failure otherwise. </dd></dl>
<p >NOTE:</p><ul>
<li>The fail handler has a couple of options on how it might attempt to return. It could return failure, which means that there is nothing we can do but return. If we have not successfully launched yet, we will be able to promote back to the root. If not, we will have to halt the PP</li>
<li>The fail handler could call bf_control_op_again. If it does, it is because it has corrected the issue, and the extension should try to execute the faulting instruction again. When bf_control_op_again is called, the microkernel will call return_to_mk with a success code. In this case, there is nothing for us to do but return success. This will make it's way back to the ESR entry point and IRET back to the extension.</li>
<li>There is another option though. The extension could ask to run a VS. This would normally be the case when the extension is implementing guest support and basically says the VM is dead, so lets execute something else. If this happens, we cannot return back to the extension. Instead, we need to return to where the microkenrel was when the VMExit occurred. When this happens, run will execute with the new VS. So we need to actually run return_to_mk again. This is because when the fail handler executes, it is really two calls deep at this point, so two return_to_mk calls is needed to get all the way back to where we started.</li>
</ul>
<p >Unreachable except during unit testing</p>

</div>
</div>
<a id="a970119f990969a19d895311c6f6f749e" name="a970119f990969a19d895311c6f6f749e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970119f990969a19d895311c6f6f749e">&#9670;&nbsp;</a></span>return_failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::return_failure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em></td><td>)</td>
          <td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a failure. If we can promote to the root VM, we will, otherwise, we will report an error, which will cause the PP to halt as there is nothing left to do. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success if the exception was handled, bsl::errc_failure otherwise </dd></dl>
<p >Header</p>
<p >IP/SP</p>
<p >Flags</p>
<p >General Purpose Registers</p>
<p >Control Registers</p>
<p >TLS State</p>
<p >Footer</p>
<p >Unreachable except during unit testing</p>

</div>
</div>
<a id="ac32230428be5460be19281f6b5d61390" name="ac32230428be5460be19281f6b5d61390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32230428be5460be19281f6b5d61390">&#9670;&nbsp;</a></span>dispatch_esr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_esr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::errc_type
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the main entry point for all exceptions. This function will dispatch exceptions as needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::errc_success if the exception was handled, bsl::errc_failure otherwise </dd></dl>

</div>
</div>
<a id="a4d80beb9a2ce05a3e08adca1c5122fc5" name="a4d80beb9a2ce05a3e08adca1c5122fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d80beb9a2ce05a3e08adca1c5122fc5">&#9670;&nbsp;</a></span>syscall_bf_intrinsic_op_rdmsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_intrinsic_op_rdmsr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_intrinsic_op_rdmsr syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a40daf22cc6d8a1af8cbec2b33dd7cee0" name="a40daf22cc6d8a1af8cbec2b33dd7cee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40daf22cc6d8a1af8cbec2b33dd7cee0">&#9670;&nbsp;</a></span>syscall_bf_intrinsic_op_wrmsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::syscall_bf_intrinsic_op_wrmsr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the bf_intrinsic_op_wrmsr syscall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="a5e4a5ed039b3041069013a9208420735" name="a5e4a5ed039b3041069013a9208420735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4a5ed039b3041069013a9208420735">&#9670;&nbsp;</a></span>dispatch_syscall_bf_intrinsic_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::dispatch_syscall_bf_intrinsic_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacesyscall.html#a5daf39a20babe9761034a4d005632ff0">syscall::bf_status_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the bf_intrinsic_op syscalls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bf_status_t containing success or failure </dd></dl>

</div>
</div>
<a id="ab4b9afb3e79e51fb5d9044c077553ad0" name="ab4b9afb3e79e51fb5d9044c077553ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b9afb3e79e51fb5d9044c077553ad0">&#9670;&nbsp;</a></span>dispatch_esr_nmi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::dispatch_esr_nmi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmk_1_1intrinsic__t.html">intrinsic_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the main entry point for NMI exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">mut_intrinsic</td><td>the <a class="el" href="classmk_1_1intrinsic__t.html" title="Provides raw access to intrinsics. Instead of using global functions, the intrinsics class provides a...">intrinsic_t</a> to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e5e4d5a563bdec4deeac20da996a54d" name="a6e5e4d5a563bdec4deeac20da996a54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5e4d5a563bdec4deeac20da996a54d">&#9670;&nbsp;</a></span>intrinsic_invept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::intrinsic_invept </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements intrinsic_t::invept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>n/a </td></tr>
    <tr><td class="paramname">type</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d57973c5c5d43bcb4c91a26d1538b04" name="a2d57973c5c5d43bcb4c91a26d1538b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d57973c5c5d43bcb4c91a26d1538b04">&#9670;&nbsp;</a></span>intrinsic_invvpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::intrinsic_invvpid </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements intrinsic_t::invvpid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>n/a </td></tr>
    <tr><td class="paramname">type</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab62432334a71ca28b1215876178ddced" name="ab62432334a71ca28b1215876178ddced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62432334a71ca28b1215876178ddced">&#9670;&nbsp;</a></span>intrinsic_vmcl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmcl </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>phys</em></td><td>)</td>
          <td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a19e0020e2fba55b09c1327be917f4632" title="Clears a VMCS given a pointer to the physical address of the VMCS.">intrinsic_t::vmcl</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phys</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="abac086e02f2fdf5c1fa4ec0f3da5e386" name="abac086e02f2fdf5c1fa4ec0f3da5e386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac086e02f2fdf5c1fa4ec0f3da5e386">&#9670;&nbsp;</a></span>intrinsic_vmld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmld </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>phys</em></td><td>)</td>
          <td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a3a603877eb333198942721eefa46c4ec" title="Loads a VMCS given a pointer to the physical address of the VMCS.">intrinsic_t::vmld</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phys</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a991711a39274434a520cab8a86d8246d" name="a991711a39274434a520cab8a86d8246d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991711a39274434a520cab8a86d8246d">&#9670;&nbsp;</a></span>intrinsic_vmrd16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmrd16 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 *const&#160;</td>
          <td class="paramname"><em>pmut_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a9c5b06a2c9e9feb788815a1e88a5f819" title="Returns the value of requested 16 bit VMCS field.">intrinsic_t::vmrd16</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a48941300bc76ed924bf8b0334ccffdf5" name="a48941300bc76ed924bf8b0334ccffdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48941300bc76ed924bf8b0334ccffdf5">&#9670;&nbsp;</a></span>intrinsic_vmrd32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmrd32 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint32 *const&#160;</td>
          <td class="paramname"><em>pmut_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#ac1244a086a6c56c85e294a4895cd066a" title="Returns the value of requested 32 bit VMCS field.">intrinsic_t::vmrd32</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a379afadb475d3286223b82ea153d93c4" name="a379afadb475d3286223b82ea153d93c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379afadb475d3286223b82ea153d93c4">&#9670;&nbsp;</a></span>intrinsic_vmrd64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmrd64 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a3caf041bdfbe63965faef69ff380dc5f" title="Returns the value of requested 64 bit VMCS field.">intrinsic_t::vmrd64</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="af8ddf31737bf2f12fdabeceed1479c3d" name="af8ddf31737bf2f12fdabeceed1479c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ddf31737bf2f12fdabeceed1479c3d">&#9670;&nbsp;</a></span>intrinsic_vmrun() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmrun </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pmut_missing_registers</em></td><td>)</td>
          <td> -&gt;  bsl::uintmx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the VMLaunch/VMResume instructions. When this function returns, a "VMExit" has occurred and must be handled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmut_missing_registers</td><td>a pointer to the missing registers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the exit reason associated with the VMExit </dd></dl>

</div>
</div>
<a id="af5c373a5d920a874648aee9e5f0d8a40" name="af5c373a5d920a874648aee9e5f0d8a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c373a5d920a874648aee9e5f0d8a40">&#9670;&nbsp;</a></span>intrinsic_vmwr16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmwr16 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint16 const&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a1ede8e5a2053f85952fb584837a647e5" title="Sets the value of requested 16 bit VMCS field.">intrinsic_t::vmwr16</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>n/a </td></tr>
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a76be01ead50ae6d3bf637636a1ec0a6e" name="a76be01ead50ae6d3bf637636a1ec0a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76be01ead50ae6d3bf637636a1ec0a6e">&#9670;&nbsp;</a></span>intrinsic_vmwr32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmwr32 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint32 const&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a842fef895386d67c5cfcab154445b9e5" title="Sets the value of requested 32 bit VMCS field.">intrinsic_t::vmwr32</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>n/a </td></tr>
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a8ec53215cd4ae179dff402ec41b94c76" name="a8ec53215cd4ae179dff402ec41b94c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec53215cd4ae179dff402ec41b94c76">&#9670;&nbsp;</a></span>intrinsic_vmwr64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmwr64 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#ad2715e7f279079b0bf69c3c97da54513" title="Sets the value of requested 64 bit VMCS field.">intrinsic_t::vmwr64</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>n/a </td></tr>
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aa002b2992bb198976f7982d34947bf99" name="aa002b2992bb198976f7982d34947bf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa002b2992bb198976f7982d34947bf99">&#9670;&nbsp;</a></span>intrinsic_vmwrfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_vmwrfunc </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)() noexcept&#160;</td>
          <td class="paramname"><em>pmut_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a2615c3408536928fba62e851620161df" title="Sets the value of requested 64 bit VMCS field (function version)">intrinsic_t::vmwrfunc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_func</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a7124930de59ec52ac8b0967b08c6666b" name="a7124930de59ec52ac8b0967b08c6666b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7124930de59ec52ac8b0967b08c6666b">&#9670;&nbsp;</a></span>intrinsic_cr0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_cr0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#abd5608b0f721fa2a38b1c64bccc99974" title="Returns the value of CR0.">intrinsic_t::cr0</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a67adb3a0b4fff20635f843e0260afd95" name="a67adb3a0b4fff20635f843e0260afd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67adb3a0b4fff20635f843e0260afd95">&#9670;&nbsp;</a></span>intrinsic_cr3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_cr3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a419d77813034cfc77c5db154d0100ab2" title="Returns the value of CR3.">intrinsic_t::cr3</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a4090f792c0780d66a2aa28f8e42f965d" name="a4090f792c0780d66a2aa28f8e42f965d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4090f792c0780d66a2aa28f8e42f965d">&#9670;&nbsp;</a></span>intrinsic_cr4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_cr4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a23f3f83e0b0a2bd4792c606cc5ec7b04" title="Returns the value of CR4.">intrinsic_t::cr4</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="ad1bc56a2a0daa1d68ef32b4d78a63266" name="ad1bc56a2a0daa1d68ef32b4d78a63266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc56a2a0daa1d68ef32b4d78a63266">&#9670;&nbsp;</a></span>intrinsic_cs_selector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_cs_selector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a2723a77171b26e14db5f2e651f82d38a" name="a2723a77171b26e14db5f2e651f82d38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2723a77171b26e14db5f2e651f82d38a">&#9670;&nbsp;</a></span>intrinsic_ds_selector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_ds_selector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a3518b8c18e2b945cd667a455bd13eb32" name="a3518b8c18e2b945cd667a455bd13eb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3518b8c18e2b945cd667a455bd13eb32">&#9670;&nbsp;</a></span>intrinsic_es_selector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_es_selector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aca492e2266a947b7aa3d7ac19b936d14" name="aca492e2266a947b7aa3d7ac19b936d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca492e2266a947b7aa3d7ac19b936d14">&#9670;&nbsp;</a></span>intrinsic_fs_selector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_fs_selector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aa2c381e87dd2e79ad229640953c93096" name="aa2c381e87dd2e79ad229640953c93096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c381e87dd2e79ad229640953c93096">&#9670;&nbsp;</a></span>intrinsic_gs_selector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_gs_selector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="af0e09e1e6e62c40d9991739dcec76ee4" name="af0e09e1e6e62c40d9991739dcec76ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e09e1e6e62c40d9991739dcec76ee4">&#9670;&nbsp;</a></span>intrinsic_invlpg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::intrinsic_invlpg </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements intrinsic_t::invlpg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f8f15f653b892a7634042530547c56e" name="a3f8f15f653b892a7634042530547c56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8f15f653b892a7634042530547c56e">&#9670;&nbsp;</a></span>intrinsic_rdmsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_rdmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::uint32 const&#160;</td>
          <td class="paramname"><em>msr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 *const&#160;</td>
          <td class="paramname"><em>pmut_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#af153a688aa5e0023598c0069a3aab400" title="Returns the value of requested MSR.">intrinsic_t::rdmsr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>n/a </td></tr>
    <tr><td class="paramname">pmut_val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a87e5314d32449eff5f1e6ba4aa16dba6" name="a87e5314d32449eff5f1e6ba4aa16dba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e5314d32449eff5f1e6ba4aa16dba6">&#9670;&nbsp;</a></span>intrinsic_set_cr3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::intrinsic_set_cr3 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements intrinsic_t::set_cr3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2af3dcfdfaf2c87ae9a275e75e244b9" name="aa2af3dcfdfaf2c87ae9a275e75e244b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2af3dcfdfaf2c87ae9a275e75e244b9">&#9670;&nbsp;</a></span>intrinsic_set_tls_reg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::intrinsic_set_tls_reg </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#ac45a1927db5ff764babca38522567580" title="Sets the value of a requested TLS register.">intrinsic_t::set_tls_reg</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>n/a </td></tr>
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa00898b0e5594f76545e699367178947" name="aa00898b0e5594f76545e699367178947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00898b0e5594f76545e699367178947">&#9670;&nbsp;</a></span>intrinsic_set_tp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mk::intrinsic_set_tp </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a3ded778669a4022370fb37a7ab896b59" title="Sets the value of tp (TLS pointer)">intrinsic_t::set_tp</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81ee32573da3ee725feb5f02e811ee7d" name="a81ee32573da3ee725feb5f02e811ee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ee32573da3ee725feb5f02e811ee7d">&#9670;&nbsp;</a></span>intrinsic_ss_selector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_ss_selector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a8e682e67fa4efe11e3237a403041a7ec" title="Returns the value of ES.">intrinsic_t::es_selector</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a3070295b284b4c85e79b9a001467230d" name="a3070295b284b4c85e79b9a001467230d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3070295b284b4c85e79b9a001467230d">&#9670;&nbsp;</a></span>intrinsic_tls_reg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_tls_reg </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td> -&gt;  bsl::uint64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a1afec55b62b86fa06b57abb4a46ef86b" title="Returns the value of a requested TLS register.">intrinsic_t::tls_reg</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="aee89096808e382c2b721f1c24e3bc84a" name="aee89096808e382c2b721f1c24e3bc84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee89096808e382c2b721f1c24e3bc84a">&#9670;&nbsp;</a></span>intrinsic_tr_selector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_tr_selector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  bsl::uint16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#aef6360a6d49b32f8896469e58d972817" title="Returns the value of TR.">intrinsic_t::tr_selector</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a926351b032eec63cdb4dfee3d07a188a" name="a926351b032eec63cdb4dfee3d07a188a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926351b032eec63cdb4dfee3d07a188a">&#9670;&nbsp;</a></span>intrinsic_wrmsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mk::intrinsic_wrmsr </td>
          <td>(</td>
          <td class="paramtype">bsl::uint32 const&#160;</td>
          <td class="paramname"><em>msr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64 const&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bsl::errc_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmk_1_1intrinsic__t.html#a6638ea06bd1a39996aa896e2291e6f20" title="Sets the value of requested MSR.">intrinsic_t::wrmsr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>n/a </td></tr>
    <tr><td class="paramname">val</td><td>n/a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n/a </dd></dl>

</div>
</div>
<a id="a05b1e205c5f1fd2bf3e5c124113a19f9" name="a05b1e205c5f1fd2bf3e5c124113a19f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b1e205c5f1fd2bf3e5c124113a19f9">&#9670;&nbsp;</a></span>tests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::tests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bsl::exit_code
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to execute the actual checks. We put the checks in this function so that we can validate the tests both at compile-time and at run-time. If a bsl::ut_check fails, the tests will either fail fast at run-time, or will produce a compile-time error. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns bsl::exit_success. </dd></dl>

</div>
</div>
<a id="a1ef2159d757677380c949f64d41eeebe" name="a1ef2159d757677380c949f64d41eeebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef2159d757677380c949f64d41eeebe">&#9670;&nbsp;</a></span>get_elf_file_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::get_elf_file_buf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacemk.html#a5f89a2fab3b6f7ca6c1829b7a32e35ad">elf_file_buf_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an allocated and initialized ELF file buffer for use during testing. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an allocated and initialized ELF file buffer for use during testing. </dd></dl>

</div>
</div>
<a id="ae4829f09f58f372de3b2dfff834bb7cd" name="ae4829f09f58f372de3b2dfff834bb7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4829f09f58f372de3b2dfff834bb7cd">&#9670;&nbsp;</a></span>clr_elf_file_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::clr_elf_file_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemk.html#a5f89a2fab3b6f7ca6c1829b7a32e35ad">elf_file_buf_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>elf_file_buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the provided ELF file buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elf_file_buf</td><td>the ELF file buffer to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a891a0c045d595b15ce5becaa0f25cbb5" name="a891a0c045d595b15ce5becaa0f25cbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891a0c045d595b15ce5becaa0f25cbb5">&#9670;&nbsp;</a></span>load_phdr_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::load_phdr_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemk.html#a1875b10bf8f00d422a0e4e6f59515d2e">phdr_table_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_phdr_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#a5f89a2fab3b6f7ca6c1829b7a32e35ad">elf_file_buf_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>elf_file_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the initial state of the program header table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_phdr_table</td><td>the program header table to initialize </td></tr>
    <tr><td class="paramname">elf_file_buf</td><td>the ELF file to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8995415c1c097dccf58dc16c09cdd22" name="ae8995415c1c097dccf58dc16c09cdd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8995415c1c097dccf58dc16c09cdd22">&#9670;&nbsp;</a></span>load_phdr_table_without_tls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::load_phdr_table_without_tls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemk.html#a1875b10bf8f00d422a0e4e6f59515d2e">phdr_table_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_phdr_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#a5f89a2fab3b6f7ca6c1829b7a32e35ad">elf_file_buf_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>elf_file_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the initial state of the program header table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_phdr_table</td><td>the program header table to initialize </td></tr>
    <tr><td class="paramname">elf_file_buf</td><td>the ELF file to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35218501de38177ce14d977a6a565090" name="a35218501de38177ce14d977a6a565090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35218501de38177ce14d977a6a565090">&#9670;&nbsp;</a></span>load_elf_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::load_elf_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceloader.html#afd2bbbd3305d4d499c41035aee9f464e">loader::ext_elf_file_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mut_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemk.html#a1875b10bf8f00d422a0e4e6f59515d2e">phdr_table_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>phdr_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the initial state of an ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_file</td><td>the ELF file to load </td></tr>
    <tr><td class="paramname">phdr_table</td><td>the program header table to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36987777237fe886236e5a0620e0c560" name="a36987777237fe886236e5a0620e0c560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36987777237fe886236e5a0620e0c560">&#9670;&nbsp;</a></span>create_tls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::create_tls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structmk_1_1tls__t.html">tls_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a <a class="el" href="structmk_1_1tls__t.html" title="Defines the layout of the microkernel&#39;s TLS block. This should not be confused with the TLS blocks gi...">tls_t</a> for testing. </p>
<dl class="section return"><dt>Returns</dt><dd>Creates and returns a <a class="el" href="structmk_1_1tls__t.html" title="Defines the layout of the microkernel&#39;s TLS block. This should not be confused with the TLS blocks gi...">tls_t</a> for testing </dd></dl>

</div>
</div>
<a id="a0bf8228ec2023145848f5d05fdc7ed0d" name="a0bf8228ec2023145848f5d05fdc7ed0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf8228ec2023145848f5d05fdc7ed0d">&#9670;&nbsp;</a></span>create_args()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::create_args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structloader_1_1mk__args__t.html">loader::mk_args_t</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a <a class="el" href="structloader_1_1mk__args__t.html" title="Defines the arguments sent to the _start function of the microkernel. The microkernel will have it&#39;s ...">loader::mk_args_t</a> for testing. </p>
<dl class="section return"><dt>Returns</dt><dd>Creates and returns a <a class="el" href="structloader_1_1mk__args__t.html" title="Defines the arguments sent to the _start function of the microkernel. The microkernel will have it&#39;s ...">loader::mk_args_t</a> for testing </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a72c730786d5c27bb2c641f18704f75ed" name="a72c730786d5c27bb2c641f18704f75ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c730786d5c27bb2c641f18704f75ed">&#9670;&nbsp;</a></span>TLS_T_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::TLS_T_SIZE {0x400_umx}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>defines the the total size of the TLS block </p>
<p >IMPORTANT:</p><ul>
<li>If the size of the TLS is changed, the mk_main_entry will need to be updated to reflect the new size. It might make sense to have a header file that defines a constant that both this code and the assembly logic can share </li>
</ul>

</div>
</div>
<a id="a20369e7d51039c61ed615d3d44102de1" name="a20369e7d51039c61ed615d3d44102de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20369e7d51039c61ed615d3d44102de1">&#9670;&nbsp;</a></span>g_mut_page_pool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::basic_page_pool_node_t mk::g_mut_page_pool {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stores the page_pool_t used by the microkernel </p>
<p >stores the page_pool for this test </p>

</div>
</div>
<a id="a47cf374f6efe0be481ccc4ee1f801cae" name="a47cf374f6efe0be481ccc4ee1f801cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cf374f6efe0be481ccc4ee1f801cae">&#9670;&nbsp;</a></span>g_mut_huge_pool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::basic_page_4k_t mk::g_mut_huge_pool {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stores the huge pool used by the microkernel </p>
<p >stores the huge_pool for this test </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemk.html">mk</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
