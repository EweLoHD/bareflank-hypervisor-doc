<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank Hypervisor: mk::huge_pool_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bareflank Hypervisor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmk_1_1huge__pool__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmk_1_1huge__pool__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mk::huge_pool_t Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The huge pool provides access to physically contiguous memory. The amount of memory that is available is really, really small (likely no more than 1 MB), but some is needed for different architectures that require it like AMD. This memory is only needed by the extensions, and we currently do not support the ability to free memory, so there is no need to over complicate how this allocator works. We simply use a cursor that is always increasing. Once you allocate all of the memory, that is it.  
 <a href="classmk_1_1huge__pool__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mocks_2huge__pool__t_8hpp_source.html">huge_pool_t.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a520369d89505b26f9c5b15676c32041c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a520369d89505b26f9c5b15676c32041c">allocate</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, bsl::safe_umx const &amp;pages) noexcept -&gt; bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt;</td></tr>
<tr class="memdesc:a520369d89505b26f9c5b15676c32041c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory from the huge pool.  <a href="classmk_1_1huge__pool__t.html#a520369d89505b26f9c5b15676c32041c">More...</a><br /></td></tr>
<tr class="separator:a520369d89505b26f9c5b15676c32041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75e85e8e0319df55e9342f223a9c06e"><td class="memItemLeft" align="right" valign="top"><a id="ad75e85e8e0319df55e9342f223a9c06e" name="ad75e85e8e0319df55e9342f223a9c06e"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>set_allocate_fails</b> () noexcept</td></tr>
<tr class="memdesc:ad75e85e8e0319df55e9342f223a9c06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells allocate to fail. <br /></td></tr>
<tr class="separator:ad75e85e8e0319df55e9342f223a9c06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43e9befe45a1ad07fcd9beaff04601"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a7a43e9befe45a1ad07fcd9beaff04601">deallocate</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt; const &amp;buf) noexcept</td></tr>
<tr class="memdesc:a7a43e9befe45a1ad07fcd9beaff04601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not supported.  <a href="classmk_1_1huge__pool__t.html#a7a43e9befe45a1ad07fcd9beaff04601">More...</a><br /></td></tr>
<tr class="separator:a7a43e9befe45a1ad07fcd9beaff04601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3199c36d99a72ba7a1620da54bf30c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c">size</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a0e3199c36d99a72ba7a1620da54bf30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes in the pool.  <a href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c">More...</a><br /></td></tr>
<tr class="separator:a0e3199c36d99a72ba7a1620da54bf30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab6ea2ebb94767bb145c2f3704e6583"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#acab6ea2ebb94767bb145c2f3704e6583">allocated</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:acab6ea2ebb94767bb145c2f3704e6583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes allocated.  <a href="classmk_1_1huge__pool__t.html#acab6ea2ebb94767bb145c2f3704e6583">More...</a><br /></td></tr>
<tr class="separator:acab6ea2ebb94767bb145c2f3704e6583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c60bcca320e95fec64725b339ef77e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a88c60bcca320e95fec64725b339ef77e">remaining</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a88c60bcca320e95fec64725b339ef77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this-&gt;<a class="el" href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c" title="Returns the number of bytes in the pool.">size()</a> - this-&gt;allocated().  <a href="classmk_1_1huge__pool__t.html#a88c60bcca320e95fec64725b339ef77e">More...</a><br /></td></tr>
<tr class="separator:a88c60bcca320e95fec64725b339ef77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac794d1af3178cb1722a24ff7ff213bc2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac794d1af3178cb1722a24ff7ff213bc2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#ac794d1af3178cb1722a24ff7ff213bc2">virt_to_phys</a> (T const *const virt) const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ac794d1af3178cb1722a24ff7ff213bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a virtual address to a physical address.  <a href="classmk_1_1huge__pool__t.html#ac794d1af3178cb1722a24ff7ff213bc2">More...</a><br /></td></tr>
<tr class="separator:ac794d1af3178cb1722a24ff7ff213bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7940588917a08ca1af40a77294446ee6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a7940588917a08ca1af40a77294446ee6">initialize</a> (bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt; &amp;mut_pool) noexcept</td></tr>
<tr class="memdesc:a7940588917a08ca1af40a77294446ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the huge pool given a mutable_buffer_t to the huge pool as well as the virtual address base of the huge pool which is used for virt to phys translations.  <a href="classmk_1_1huge__pool__t.html#a7940588917a08ca1af40a77294446ee6">More...</a><br /></td></tr>
<tr class="separator:a7940588917a08ca1af40a77294446ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520369d89505b26f9c5b15676c32041c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a520369d89505b26f9c5b15676c32041c">allocate</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, bsl::safe_umx const &amp;pages) noexcept -&gt; bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt;</td></tr>
<tr class="memdesc:a520369d89505b26f9c5b15676c32041c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory from the huge pool.  <a href="classmk_1_1huge__pool__t.html#a520369d89505b26f9c5b15676c32041c">More...</a><br /></td></tr>
<tr class="separator:a520369d89505b26f9c5b15676c32041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43e9befe45a1ad07fcd9beaff04601"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a7a43e9befe45a1ad07fcd9beaff04601">deallocate</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls, bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt; const &amp;buf) noexcept</td></tr>
<tr class="memdesc:a7a43e9befe45a1ad07fcd9beaff04601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not supported.  <a href="classmk_1_1huge__pool__t.html#a7a43e9befe45a1ad07fcd9beaff04601">More...</a><br /></td></tr>
<tr class="separator:a7a43e9befe45a1ad07fcd9beaff04601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3199c36d99a72ba7a1620da54bf30c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c">size</a> () const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a0e3199c36d99a72ba7a1620da54bf30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes in the pool.  <a href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c">More...</a><br /></td></tr>
<tr class="separator:a0e3199c36d99a72ba7a1620da54bf30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab6ea2ebb94767bb145c2f3704e6583"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#acab6ea2ebb94767bb145c2f3704e6583">allocated</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:acab6ea2ebb94767bb145c2f3704e6583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes allocated.  <a href="classmk_1_1huge__pool__t.html#acab6ea2ebb94767bb145c2f3704e6583">More...</a><br /></td></tr>
<tr class="separator:acab6ea2ebb94767bb145c2f3704e6583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c60bcca320e95fec64725b339ef77e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a88c60bcca320e95fec64725b339ef77e">remaining</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:a88c60bcca320e95fec64725b339ef77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this-&gt;<a class="el" href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c" title="Returns the number of bytes in the pool.">size()</a> - this-&gt;allocated().  <a href="classmk_1_1huge__pool__t.html#a88c60bcca320e95fec64725b339ef77e">More...</a><br /></td></tr>
<tr class="separator:a88c60bcca320e95fec64725b339ef77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac794d1af3178cb1722a24ff7ff213bc2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac794d1af3178cb1722a24ff7ff213bc2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#ac794d1af3178cb1722a24ff7ff213bc2">virt_to_phys</a> (T const *const virt) const noexcept -&gt; bsl::safe_umx</td></tr>
<tr class="memdesc:ac794d1af3178cb1722a24ff7ff213bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a virtual address to a physical address.  <a href="classmk_1_1huge__pool__t.html#ac794d1af3178cb1722a24ff7ff213bc2">More...</a><br /></td></tr>
<tr class="separator:ac794d1af3178cb1722a24ff7ff213bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6803030223c90cc1fa840bb0ba21e94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6803030223c90cc1fa840bb0ba21e94"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#ab6803030223c90cc1fa840bb0ba21e94">phys_to_virt</a> (bsl::safe_umx const &amp;phys) const noexcept -&gt; T *</td></tr>
<tr class="memdesc:ab6803030223c90cc1fa840bb0ba21e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a physical address to a virtual address.  <a href="classmk_1_1huge__pool__t.html#ab6803030223c90cc1fa840bb0ba21e94">More...</a><br /></td></tr>
<tr class="separator:ab6803030223c90cc1fa840bb0ba21e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac078679220244fd9ad7084afb728f1d5"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#ac078679220244fd9ad7084afb728f1d5">dump</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) const noexcept</td></tr>
<tr class="memdesc:ac078679220244fd9ad7084afb728f1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the page_pool_t.  <a href="classmk_1_1huge__pool__t.html#ac078679220244fd9ad7084afb728f1d5">More...</a><br /></td></tr>
<tr class="separator:ac078679220244fd9ad7084afb728f1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2086cd96e231f072493a1994e03ab545"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#a2086cd96e231f072493a1994e03ab545">initialize</a> (bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt; const &amp;pool) noexcept</td></tr>
<tr class="memdesc:a2086cd96e231f072493a1994e03ab545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the huge pool given a mutable_buffer_t to the huge pool as well as the virtual address base of the huge pool which is used for virt to phys translations.  <a href="classmk_1_1huge__pool__t.html#a2086cd96e231f072493a1994e03ab545">More...</a><br /></td></tr>
<tr class="separator:a2086cd96e231f072493a1994e03ab545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20539aaed60c66c75942dfe0ad5d0ff"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmk_1_1huge__pool__t.html#ab20539aaed60c66c75942dfe0ad5d0ff">dump</a> (<a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;tls) noexcept</td></tr>
<tr class="memdesc:ab20539aaed60c66c75942dfe0ad5d0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the page_pool_t.  <a href="classmk_1_1huge__pool__t.html#ab20539aaed60c66c75942dfe0ad5d0ff">More...</a><br /></td></tr>
<tr class="separator:ab20539aaed60c66c75942dfe0ad5d0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The huge pool provides access to physically contiguous memory. The amount of memory that is available is really, really small (likely no more than 1 MB), but some is needed for different architectures that require it like AMD. This memory is only needed by the extensions, and we currently do not support the ability to free memory, so there is no need to over complicate how this allocator works. We simply use a cursor that is always increasing. Once you allocate all of the memory, that is it. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2086cd96e231f072493a1994e03ab545" name="a2086cd96e231f072493a1994e03ab545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2086cd96e231f072493a1994e03ab545">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void mk::huge_pool_t::initialize </td>
          <td>(</td>
          <td class="paramtype">bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the huge pool given a mutable_buffer_t to the huge pool as well as the virtual address base of the huge pool which is used for virt to phys translations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the mutable_buffer_t of the huge pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a520369d89505b26f9c5b15676c32041c" name="a520369d89505b26f9c5b15676c32041c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520369d89505b26f9c5b15676c32041c">&#9670;&nbsp;</a></span>allocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::span&lt;<a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a>&gt;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory from the huge pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">pages</td><td>the total number of pages to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::span containing the allocated memory </dd></dl>
<p >BUG:</p><ul>
<li>There is a bug in Clang 10 where any array based allocations from a constexpr that get their size at runtime will produce a segfault in Clang itself. This bug was fixed in Clang 11, but Ubuntu 20.04 comes with Clang 10, and our goal is to try our best to continue to be able to use Clang 10. So to solve this, we hard code the size to something large enough that all unit tests should be able to play within this size. A ton of memory is wasted doing this, but this is only for unit testing, so that should be fine.</li>
</ul>

</div>
</div>
<a id="a7a43e9befe45a1ad07fcd9beaff04601" name="a7a43e9befe45a1ad07fcd9beaff04601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a43e9befe45a1ad07fcd9beaff04601">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::huge_pool_t::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">buf</td><td>the bsl::span containing the memory to deallocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e3199c36d99a72ba7a1620da54bf30c" name="a0e3199c36d99a72ba7a1620da54bf30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3199c36d99a72ba7a1620da54bf30c">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes in the pool. </dd></dl>

</div>
</div>
<a id="acab6ea2ebb94767bb145c2f3704e6583" name="acab6ea2ebb94767bb145c2f3704e6583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab6ea2ebb94767bb145c2f3704e6583">&#9670;&nbsp;</a></span>allocated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::allocated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes allocated. </dd></dl>

</div>
</div>
<a id="a88c60bcca320e95fec64725b339ef77e" name="a88c60bcca320e95fec64725b339ef77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c60bcca320e95fec64725b339ef77e">&#9670;&nbsp;</a></span>remaining() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this-&gt;<a class="el" href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c" title="Returns the number of bytes in the pool.">size()</a> - this-&gt;allocated(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns this-&gt;<a class="el" href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c" title="Returns the number of bytes in the pool.">size()</a> - this-&gt;allocated(). </dd></dl>

</div>
</div>
<a id="ac794d1af3178cb1722a24ff7ff213bc2" name="ac794d1af3178cb1722a24ff7ff213bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac794d1af3178cb1722a24ff7ff213bc2">&#9670;&nbsp;</a></span>virt_to_phys() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::virt_to_phys </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>virt</em></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a virtual address to a physical address. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>defines the type of virtual address being converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>the virtual address to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting physical address </dd></dl>

</div>
</div>
<a id="ab20539aaed60c66c75942dfe0ad5d0ff" name="ab20539aaed60c66c75942dfe0ad5d0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20539aaed60c66c75942dfe0ad5d0ff">&#9670;&nbsp;</a></span>dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void mk::huge_pool_t::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps the page_pool_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7940588917a08ca1af40a77294446ee6" name="a7940588917a08ca1af40a77294446ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7940588917a08ca1af40a77294446ee6">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::huge_pool_t::initialize </td>
          <td>(</td>
          <td class="paramtype">bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mut_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the huge pool given a mutable_buffer_t to the huge pool as well as the virtual address base of the huge pool which is used for virt to phys translations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut_pool</td><td>the mutable_buffer_t of the huge pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a520369d89505b26f9c5b15676c32041c" name="a520369d89505b26f9c5b15676c32041c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520369d89505b26f9c5b15676c32041c">&#9670;&nbsp;</a></span>allocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bsl::span&lt;<a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a>&gt;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory from the huge pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">pages</td><td>the total number of pages to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bsl::span containing the allocated memory </dd></dl>
<p >NOTE:</p><ul>
<li>It is impossible for the following to overflow because if it did, the span above would fail first, which is why it is marked as checked.</li>
</ul>

</div>
</div>
<a id="a7a43e9befe45a1ad07fcd9beaff04601" name="a7a43e9befe45a1ad07fcd9beaff04601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a43e9befe45a1ad07fcd9beaff04601">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::huge_pool_t::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::span&lt; <a class="el" href="namespacemk.html#a24cba738bd1691370b489f0ffb4187b9">page_4k_t</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
    <tr><td class="paramname">buf</td><td>the bsl::span containing the memory to deallocate </td></tr>
  </table>
  </dd>
</dl>
<p >NOTE:</p><ul>
<li>If this function is implemented, we will have to deal with deallocations being a page in size. Specifically, right now a huge page is allocated and mapped into the page tables one page at a time. When is is time to deallocate, this memory is released one page at a time. If the page tables are deallocating one page of a larger physically contiguous memory region, it should be assumed that the entire region will be freed, it will just happen in page increments.</li>
<li>What this means is this function could see a free for the same physically contiguous block of memory (one for each page in the block). We could ignore the extras, or we could set up the allocator so that it frees one page at a time. Just depends on how we want to do this... but in general, I would suggest using the later as a buddy allocator can support this without any added overhead.</li>
</ul>

</div>
</div>
<a id="a0e3199c36d99a72ba7a1620da54bf30c" name="a0e3199c36d99a72ba7a1620da54bf30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3199c36d99a72ba7a1620da54bf30c">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes in the pool. </dd></dl>
<p >NOTE:</p><ul>
<li>The following is marked checked because the initialize function ensures this math will never overflow.</li>
</ul>

</div>
</div>
<a id="acab6ea2ebb94767bb145c2f3704e6583" name="acab6ea2ebb94767bb145c2f3704e6583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab6ea2ebb94767bb145c2f3704e6583">&#9670;&nbsp;</a></span>allocated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::allocated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes allocated. </dd></dl>

</div>
</div>
<a id="a88c60bcca320e95fec64725b339ef77e" name="a88c60bcca320e95fec64725b339ef77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c60bcca320e95fec64725b339ef77e">&#9670;&nbsp;</a></span>remaining() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this-&gt;<a class="el" href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c" title="Returns the number of bytes in the pool.">size()</a> - this-&gt;allocated(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns this-&gt;<a class="el" href="classmk_1_1huge__pool__t.html#a0e3199c36d99a72ba7a1620da54bf30c" title="Returns the number of bytes in the pool.">size()</a> - this-&gt;allocated(). </dd></dl>

</div>
</div>
<a id="ac794d1af3178cb1722a24ff7ff213bc2" name="ac794d1af3178cb1722a24ff7ff213bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac794d1af3178cb1722a24ff7ff213bc2">&#9670;&nbsp;</a></span>virt_to_phys() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::virt_to_phys </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>virt</em></td><td>)</td>
          <td> const -&gt; bsl::safe_umx
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a virtual address to a physical address. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>defines the type of virtual address being converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>the virtual address to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting physical address </dd></dl>

</div>
</div>
<a id="ab6803030223c90cc1fa840bb0ba21e94" name="ab6803030223c90cc1fa840bb0ba21e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6803030223c90cc1fa840bb0ba21e94">&#9670;&nbsp;</a></span>phys_to_virt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mk::huge_pool_t::phys_to_virt </td>
          <td>(</td>
          <td class="paramtype">bsl::safe_umx const &amp;&#160;</td>
          <td class="paramname"><em>phys</em></td><td>)</td>
          <td> const -&gt; T *
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a physical address to a virtual address. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>defines the type of virtual address to convert to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phys</td><td>the physical address to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting virtual address </dd></dl>

</div>
</div>
<a id="ac078679220244fd9ad7084afb728f1d5" name="ac078679220244fd9ad7084afb728f1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac078679220244fd9ad7084afb728f1d5">&#9670;&nbsp;</a></span>dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mk::huge_pool_t::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmk_1_1tls__t.html">tls_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>tls</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps the page_pool_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>the current TLS block </td></tr>
  </table>
  </dd>
</dl>
<p >Header</p>
<p >Total</p>
<p >Used</p>
<p >Remaining</p>
<p >Footer</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>kernel/mocks/<a class="el" href="mocks_2huge__pool__t_8hpp_source.html">huge_pool_t.hpp</a></li>
<li>kernel/src/<a class="el" href="src_2huge__pool__t_8hpp_source.html">huge_pool_t.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemk.html">mk</a></li><li class="navelem"><a class="el" href="classmk_1_1huge__pool__t.html">huge_pool_t</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
